<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CoEvent</title>
      <link href="/2023/05/19/Doc/CoEvent/CoEvent-1/"/>
      <url>/2023/05/19/Doc/CoEvent/CoEvent-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CoEvent"><a href="#CoEvent" class="headerlink" title="CoEvent"></a>CoEvent</h1><p>CoEvent是一个能约束参数类型的，能约束调用类型的，参数和调用类型安全的轻量级本地消息系统，支持一切能支持Unsafe.As类似API的CSharp编程平台。</p><p>目前了解的支持平台有.NET CORE和Unity3D 2020.1 OR NEWER。</p><p>理论上版本更低的Unity3D也能实现(可能在后续版本提供支持)，不过没有提供原生的UnsafeUtility.As，可以自己实现一个替换上去。</p><p>CoEvent最近新增的单线程异步(Task-Like)，旨在完全消灭回调的使用，让您能像写同步方法一样去书写异步方法，而不需要设置无数个bool标记，也不需要设置无数个回调，极大的优化了回调书写体验，在异步方法能畅通无阻的访问Unity主线程能访问的一切资源。</p><h2 id="一、优势"><a href="#一、优势" class="headerlink" title="一、优势"></a>一、优势</h2><p>CoEvent 的优势主要在于“约束”  ，现在传统的消息系统一般有如下方式实现</p><ul><li>1.反射(Unity的SendMessage已经被无情抛弃了)</li><li>2.int，string，enum做消息标识(注册和取消要手动写一大串泛型参数，调用要手动写泛型参数，如果写错了…后果不堪设想)</li><li>3.接口化的，基类化的(部分类似的基于观察者模式写了接口，继承基类可以比较容易实现这种约束，但是继承接口的很难去做约束，不好判断消息类型，很多接口约束只能有唯一消息)</li></ul><p>给大家看看主流实现的方式怎么调用和实现的</p><pre><code class="csharp">//Unity原生SendMessage，通过反射，效率低，容易写错名字，写错时候字符串是没提示的，很难查错Monobehaviour.SendMessage(&quot;Ttt&quot;);//int，string，enum做标识的EventCenter.Add&lt;int,int&gt;(&quot;name&quot;,MyAction);//在注册时需要写泛型EventCenter.Send(&quot;name&quot;,10,20);  //调用时没有约束，我也可以传入错误的参数类型，当写多了就变成了灾难。//基类和接口继承的//基类不用说了，侵入性太强了//接口继承的，一般一个类只能有一个事件，不然很难判断类型的参数//当然也有写分析器的，那都是大牛，QAQ，本渣做不到</code></pre><p>而CoEvent是怎么实现的？<br>CoEvent采用了第二种方式，但是不同的是消息标识是接口，很巧妙的利用协变实现了约束.</p><p>CoEvent能根据泛型推断省略注册和取消时的泛型参数，也能限制发布事件时的参数类型。</p><p>也就是说，CoEvent是不会发生那种写错泛型参数的类型情况的，也不会发生Send注册，结果Call调用这种情况。</p><p>极大的降低了开发者的代码失误几率，减少了Debug的时间,提高了协作效率。</p><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p>CoEvent本着简单易用的原则实现了基于观察者模式的一个事件系统。能很轻松实现跨对象，跨模块之间的事件通信。</p><p>1.前期配置：</p><pre><code>如果你是在Unity3D 2020.1以上使用，无需配置任何内容。如果你是在.NetCore使用，需要在任意一个参与编译的文件里加上宏定义，#define NETCORE如果你在其他平台使用，可以在CoUnsafeAs.cs里去给出Unsafe.As的类似实现。无法实现？不支持该平台QAQ</code></pre><p>2.事件定义</p><pre><code class="csharp">//通用事件，可以Send可以Call，但是只能用一个！！！public interface MyEvent: IGenericEvent&lt;参数类型,参数类型...&gt;//可发送public interface MyEvent: ISendEvent&lt;...&gt;//可调用(最后一个泛型参数是返回值)public interface MyEvent: ICallEvent&lt;...&gt;</code></pre><p>3.注册和取消事件(MyAction也是被约束类型的)</p><pre><code class="csharp">this.Operator&lt;消息类型接口&gt;().Subcribe(MyAction);this.Operator&lt;消息类型接口&gt;().UnSubcribe(MyAction);</code></pre><p>4.调用和发送</p><pre><code class="csharp">this.Operator&lt;消息类型接口&gt;().Send(...参数们);var results = this.Operator&lt;消息类型接口&gt;().Call(...参数们);</code></pre><h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><pre><code class="csharp">using CoEvent;using UnityEngine;public interface IMyTest : ISendEvent&lt;int, int&gt; &#123; &#125;public class Test : MonoBehaviour&#123;    void Ttt(int t,int k)    &#123;        Debug.Log($&quot;&#123;t&#125;:&#123;k&#125;&quot;);    &#125;    void Start()    &#123;        this.Operator&lt;IMyTest&gt;().Subscribe(Ttt);        this.Operator&lt;IMyTest&gt;().UnSubscribe(Ttt);        this.Operator&lt;IMyTest&gt;().Send(10,100);    &#125;&#125;</code></pre><h2 id="四、单线程异步"><a href="#四、单线程异步" class="headerlink" title="四、单线程异步"></a>四、单线程异步</h2><p>CoEvent提供了一种极佳的方式来处理回调等异步逻辑</p><pre><code class="csharp">using CoEvent.Async;    //可等待的任务   public async CoTask mTest()    &#123;    //等待600帧        await Async.WaitForFrame(600);        Debug.Log(&quot;Hha&quot;);        //等待3秒        await Async.Delay(3);        Debug.Log(&quot;111&quot;);    &#125;</code></pre><p>使用方式非常的简单，都放在了Async类里，当然也支持取消，挂起等，只需要对CoTask调用拓展方法WithToken</p><pre><code class="csharp">mTest().WithToken(out var token);token.Yield();</code></pre><p>如果您需要进一步的拓展CoTask，只需要写一个方法,CoTask.Create拿到新的CoTask，然后在任务结束时调用它的SetResult即可，可以参考Async类的实现。<br>可以简单的与YooAsset等进行对接</p><h2 id="欢迎加入"><a href="#欢迎加入" class="headerlink" title="欢迎加入"></a>欢迎加入</h2><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305201805505.png" alt="GameDev游研社群聊二维码"></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> CoEvent </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoEvent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-1</title>
      <link href="/2023/05/19/Doc/WooAsset/WooAsset-1/"/>
      <url>/2023/05/19/Doc/WooAsset/WooAsset-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆角</title>
      <link href="/2023/05/16/Unity/Shader/%E5%9C%86%E8%A7%92/"/>
      <url>/2023/05/16/Unity/Shader/%E5%9C%86%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-效果与引言"><a href="#一、-效果与引言" class="headerlink" title="一、 效果与引言"></a>一、 效果与引言</h1><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728219.png" alt="在这里插入图片描述"><br>相信很多小伙伴都会遇到做<strong>圆角矩形</strong>的需求，网上的shader还不明白是怎么实现的，甚至还有一部分是错误的，本文讲从原理到代码讲解<strong>圆角矩形shader</strong>的实现</p><h1 id="二、-原理分析"><a href="#二、-原理分析" class="headerlink" title="二、 原理分析"></a>二、 原理分析</h1><p>想要实现一个圆角矩形，常见的是抽象成一个数学模型，如下图紫色区域，就是我们应该保留的区域，为了更准确的描述这个图形，我们在四个角创建四个相等的圆形。<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728401.png" alt="在这里插入图片描述"><br>因为控制每个像素的颜色主要是由<strong>片元着色器</strong>负责的，所以我们也通过<strong>Fragment Shader</strong>去实现这个效果，可以看到在这个函数里我们只能拿到 <strong>uv</strong>和vertex，所以我们<strong>根据uv坐标判定是否在上图的紫色区域，如果在则返回原本的颜色，如果不在返回完全透明的颜色。</strong><br><strong>(对每个像素都会执行一次frag函数获取真正渲染的颜色)</strong></p><pre><code class="c">struct v2f            &#123;                float2 uv : TEXCOORD0;                UNITY_FOG_COORDS(1)                float4 vertex : SV_POSITION;            &#125;;             fixed4 frag (v2f i) : SV_Target &#123;     //....省略 &#125;</code></pre><p>因为我们通过uv来判断是否是紫色区域，所以我们需要先了解uv坐标系<br>首先我们要了解<strong>UV坐标系</strong>，这并不是什么高深的数学概念，而是一个简单的道理。<br>首先，我们<strong>把水平方向定义为X轴，竖直方向为Y轴</strong>，<strong>把图片左下角定义为(0,0)，右上角定义为(1,1)，其他的坐标以此类推</strong></p><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728852.png" alt="在这里插入图片描述"></p><p>读者可能会产生疑惑，为什么xy两个轴长度不同，但是坐标却不相同？<br>笔者暂时只能这样描述：我们就如此定义一个坐标系，x轴和y轴单位长度不同</p><p>我们需要用户去调整四个<strong>圆形的半径 设为Radius</strong>，因为uv坐标系的xy单位长度不同，我们设<strong>Ratio &#x3D; Height&#x2F;Width</strong>，Ratio即为y轴单位长度与x轴单位长度之比。</p><blockquote><p>float Radius   圆形半径<br>float Ratio  Y单位长度&#x2F;X单位长度</p></blockquote><p>接下来我们在图上画四个圆形并作辅助线</p><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728534.png" alt="在这里插入图片描述"><br>通过观察，我们可以发现以下特征</p><blockquote><p>1.<strong>只有在红色区域才有可能被舍弃</strong><br>2.<strong>三个圆形R2，R3，R4对应红色区域的任意一个位置，都能在R1内找到等价位置</strong><br>3. <strong>UV坐标转正常坐标的公式为 f (x ,y)&#x3D; (uv.x  , uv.y * Ratio)</strong></p></blockquote><p>在UV坐标内，我们无法通过x^2^ + y^2^ 来计算长度，因为uv坐标的xy单位不同，所以我们通过上述的坐标转换公式来转化为相同的坐标系</p><p>我们需要按以下步骤进行处理</p><blockquote><p>1.<strong>将白色区域坐标在左下角找到等价uv坐标，position &#x3D; abs(step(0.5,uv) - uv)</strong><br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728432.png" alt="在这里插入图片描述"><br>2.<strong>判断等价uv是否在左下角可能舍弃区域，</strong>uv.x&lt;Raduis &amp;&amp; uv.y &lt;  Radius * Ratio**<br>如果不在，则返回原色，如果在则进入下一步**<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728553.png" alt="在这里插入图片描述"></p><ol start="3"><li><strong>求圆心距 distance &#x3D;   [f(uv.x,uv.y) - f(Radius,Radius)]的长度<br>如果大于半径则返回fixed(0,0,0,0)，否则返回原色</strong><br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728084.png" alt="在这里插入图片描述"></li></ol></blockquote><h1 id="三、着色器代码"><a href="#三、着色器代码" class="headerlink" title="三、着色器代码"></a>三、着色器代码</h1><p>在shader内尽量不要使用if语句<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191729794.png" alt="在这里插入图片描述"><br>以上来着自Hking_Auditore 大大的Shader入门书，通常我们用step和lerp等来代替if<br>step函数的逻辑可以等价为</p><pre><code class="c">step (a, x)&#123;  if (a&gt;x)  return 0;  else return 1;&#125;</code></pre><p>接下来的代码虽然看着多，实际上我们只写了两行<br>这就是这两行</p><pre><code class="csharp"> float2 p = abs(step(0.5,i.uv) - i.uv); fixed4 col =  tex2D(_MainTex, i.uv) * (step(_Radius,p.x) ||step( _Radius  ,p.y*_Ratio) || step(length(float2(p.x-_Radius,p.y*_Ratio-_Radius)),_Radius));</code></pre><p>这是完整的着色器代码</p><pre><code class="c">Shader &quot;Unlit/MyShader&quot;&#123;    Properties    &#123;        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Radius (&quot;Radius&quot;,float) = 0        _Ratio(&quot;Height/Width&quot;,float )= 1    &#125;    SubShader    &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot;&#125;        LOD 100        Blend SrcAlpha OneMinusSrcAlpha        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            // make fog work            #pragma multi_compile_fog            #include &quot;UnityCG.cginc&quot;            struct appdata            &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;            &#125;;            struct v2f            &#123;                float2 uv : TEXCOORD0;                UNITY_FOG_COORDS(1)                float4 vertex : SV_POSITION;            &#125;;            sampler2D _MainTex;            float4 _MainTex_ST;            float _Radius;            float _Ratio;            v2f vert (appdata v)            &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                o.uv = TRANSFORM_TEX(v.uv, _MainTex);                UNITY_TRANSFER_FOG(o,o.vertex);                return o;            &#125;            fixed4 frag (v2f i) : SV_Target            &#123;                  //坐标等价到左下角                float2 p = abs(step(0.5,i.uv) - i.uv);                //三个条件同时成立则乘0，否则乘1                //1.在左下角  ，2.长度超过半径                fixed4 col =  tex2D(_MainTex, i.uv) * (step(_Radius,p.x) ||step( _Radius  ,p.y*_Ratio) || step(length(float2(p.x-_Radius,p.y*_Ratio-_Radius)),_Radius));                UNITY_APPLY_FOG(i.fogCoord, col);                return col;            &#125;            ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊-毛玻璃</title>
      <link href="/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/"/>
      <url>/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../../Pic/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83.png" alt="效果"></p><pre><code class="cg">Shader &quot;UI/UiObscure&quot;&#123;    Properties    &#123;        _Radius(&quot;Radius&quot;, Range(1, 255)) = 1        _MainTex(&quot;Tint Color (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Interval(&quot;Blur Nuance&quot;,Range(0.1, 100)) = 1        [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)] _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        [HideInInspector] _Stencil (&quot;Stencil ID&quot;, Float) = 0        [HideInInspector][Enum(UnityEngine.Rendering.StencilOp)] _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        [HideInInspector] _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        [HideInInspector] _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        [HideInInspector] _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        // Outline properties are drawn via custom editor.        [HideInInspector] _OutlineWidth(&quot;Outline Width&quot;, Range(0,8)) = 3.0        [HideInInspector] _OutlineColor(&quot;Outline Color&quot;, Color) = (1,1,0,1)        [HideInInspector] _OutlineReferenceTexWidth(&quot;Reference Texture Width&quot;, Int) = 1024        [HideInInspector] _ThresholdEnd(&quot;Outline Threshold&quot;, Range(0,1)) = 0.25        [HideInInspector] _OutlineSmoothness(&quot;Outline Smoothness&quot;, Range(0,1)) = 1.0        [HideInInspector][MaterialToggle(_USE8NEIGHBOURHOOD_ON)] _Use8Neighbourhood(&quot;Sample 8 Neighbours&quot;, Float) = 1        [HideInInspector] _OutlineMipLevel(&quot;Outline Mip Level&quot;, Range(0,3)) = 0    &#125;     Category    &#123;        Tags&#123; &quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;         SubShader        &#123;                     Stencil            &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]            &#125;                        Cull Off            Lighting Off            ZWrite Off            ZTest [unity_GUIZTestMode]            Fog &#123; Mode Off &#125;            Blend One OneMinusSrcAlpha            ColorMask [_ColorMask]                    GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM                #pragma vertex vert                #pragma fragment frag                #pragma fragmentoption ARB_precision_hint_fastest                #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                    v2f o;                    o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                    float scale = -1.0;                    #else                    float scale = 1.0;                    #endif                    o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                    o.uvgrab.zw = o.vertex.zw;                    return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                float _Interval;                half4 frag(v2f i) : COLOR                &#123;                    half4 sum = half4(0,0,0,0);                                 #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                                 sum += GRABXYPIXEL(0.0, 0.0);                    int measurments = 1;                                 for (float range = _Interval; range &lt;= _Radius; range += _Interval)                    &#123;                        sum += GRABXYPIXEL(range, range);                        sum += GRABXYPIXEL(range, -range);                        sum += GRABXYPIXEL(-range, range);                        sum += GRABXYPIXEL(-range, -range);                        measurments += 4;                    &#125;                    return sum / measurments;                &#125;            ENDCG            &#125;        GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma fragmentoption ARB_precision_hint_fastest            #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                float scale = -1.0;                    #else                float scale = 1.0;                    #endif                o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                o.uvgrab.zw = o.vertex.zw;                return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                    half4 frag(v2f i) : COLOR                &#123;                            half4 sum = half4(0,0,0,0);                float radius = 1.41421356237 * _Radius;                                #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                            sum += GRABXYPIXEL(0.0, 0.0);                int measurments = 1;                            for (float range = 1.41421356237f; range &lt;= radius * 1.41; range += 1.41421356237f)                &#123;                sum += GRABXYPIXEL(range, 0);                sum += GRABXYPIXEL(-range, 0);                sum += GRABXYPIXEL(0, range);                sum += GRABXYPIXEL(0, -range);                measurments += 4;                &#125;                            return sum / measurments;                &#125;            ENDCG            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书写方式</title>
      <link href="/2023/05/15/README/"/>
      <url>/2023/05/15/README/</url>
      
        <content type="html"><![CDATA[<h2 id="sadasda"><a href="#sadasda" class="headerlink" title="sadasda"></a>sadasda</h2><h4 id="57d8a"><a href="#57d8a" class="headerlink" title="57d8a"></a>57d8a</h4><ul><li>哈哈哈</li><li>康康康<ul><li>777</li><li>888</li></ul></li><li>999</li></ul><pre><code class="csharp">public class A&#123;    public void DO()&#123;&#125;&#125;</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><img src="/../Pic/R-C.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
