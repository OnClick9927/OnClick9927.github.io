<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CoEvent</title>
      <link href="/2023/05/19/Doc/CoEvent/CoEvent-1/"/>
      <url>/2023/05/19/Doc/CoEvent/CoEvent-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CoEvent"><a href="#CoEvent" class="headerlink" title="CoEvent"></a>CoEvent</h1><p>CoEvent是一个能约束参数类型的，能约束调用类型的，参数和调用类型安全的轻量级本地消息系统，支持一切能支持Unsafe.As类似API的CSharp编程平台。</p><p>目前了解的支持平台有.NET CORE和Unity3D 2020.1 OR NEWER。</p><p>理论上版本更低的Unity3D也能实现(可能在后续版本提供支持)，不过没有提供原生的UnsafeUtility.As，可以自己实现一个替换上去。</p><p>CoEvent最近新增的单线程异步(Task-Like)，旨在完全消灭回调的使用，让您能像写同步方法一样去书写异步方法，而不需要设置无数个bool标记，也不需要设置无数个回调，极大的优化了回调书写体验，在异步方法能畅通无阻的访问Unity主线程能访问的一切资源。</p><h2 id="一、优势"><a href="#一、优势" class="headerlink" title="一、优势"></a>一、优势</h2><p>CoEvent 的优势主要在于“约束”  ，现在传统的消息系统一般有如下方式实现</p><ul><li>1.反射(Unity的SendMessage已经被无情抛弃了)</li><li>2.int，string，enum做消息标识(注册和取消要手动写一大串泛型参数，调用要手动写泛型参数，如果写错了…后果不堪设想)</li><li>3.接口化的，基类化的(部分类似的基于观察者模式写了接口，继承基类可以比较容易实现这种约束，但是继承接口的很难去做约束，不好判断消息类型，很多接口约束只能有唯一消息)</li></ul><p>给大家看看主流实现的方式怎么调用和实现的</p><pre><code class="csharp">//Unity原生SendMessage，通过反射，效率低，容易写错名字，写错时候字符串是没提示的，很难查错Monobehaviour.SendMessage(&quot;Ttt&quot;);//int，string，enum做标识的EventCenter.Add&lt;int,int&gt;(&quot;name&quot;,MyAction);//在注册时需要写泛型EventCenter.Send(&quot;name&quot;,10,20);  //调用时没有约束，我也可以传入错误的参数类型，当写多了就变成了灾难。//基类和接口继承的//基类不用说了，侵入性太强了//接口继承的，一般一个类只能有一个事件，不然很难判断类型的参数//当然也有写分析器的，那都是大牛，QAQ，本渣做不到</code></pre><p>而CoEvent是怎么实现的？<br>CoEvent采用了第二种方式，但是不同的是消息标识是接口，很巧妙的利用协变实现了约束.</p><p>CoEvent能根据泛型推断省略注册和取消时的泛型参数，也能限制发布事件时的参数类型。</p><p>也就是说，CoEvent是不会发生那种写错泛型参数的类型情况的，也不会发生Send注册，结果Call调用这种情况。</p><p>极大的降低了开发者的代码失误几率，减少了Debug的时间,提高了协作效率。</p><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p>CoEvent本着简单易用的原则实现了基于观察者模式的一个事件系统。能很轻松实现跨对象，跨模块之间的事件通信。</p><p>1.前期配置：</p><pre><code>如果你是在Unity3D 2020.1以上使用，无需配置任何内容。如果你是在.NetCore使用，需要在任意一个参与编译的文件里加上宏定义，#define NETCORE如果你在其他平台使用，可以在CoUnsafeAs.cs里去给出Unsafe.As的类似实现。无法实现？不支持该平台QAQ</code></pre><p>2.事件定义</p><pre><code class="csharp">//通用事件，可以Send可以Call，但是只能用一个！！！public interface MyEvent: IGenericEvent&lt;参数类型,参数类型...&gt;//可发送public interface MyEvent: ISendEvent&lt;...&gt;//可调用(最后一个泛型参数是返回值)public interface MyEvent: ICallEvent&lt;...&gt;</code></pre><p>3.注册和取消事件(MyAction也是被约束类型的)</p><pre><code class="csharp">this.Operator&lt;消息类型接口&gt;().Subcribe(MyAction);this.Operator&lt;消息类型接口&gt;().UnSubcribe(MyAction);</code></pre><p>4.调用和发送</p><pre><code class="csharp">this.Operator&lt;消息类型接口&gt;().Send(...参数们);var results = this.Operator&lt;消息类型接口&gt;().Call(...参数们);</code></pre><h2 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h2><pre><code class="csharp">using CoEvent;using UnityEngine;public interface IMyTest : ISendEvent&lt;int, int&gt; &#123; &#125;public class Test : MonoBehaviour&#123;    void Ttt(int t,int k)    &#123;        Debug.Log($&quot;&#123;t&#125;:&#123;k&#125;&quot;);    &#125;    void Start()    &#123;        this.Operator&lt;IMyTest&gt;().Subscribe(Ttt);        this.Operator&lt;IMyTest&gt;().UnSubscribe(Ttt);        this.Operator&lt;IMyTest&gt;().Send(10,100);    &#125;&#125;</code></pre><h2 id="四、单线程异步"><a href="#四、单线程异步" class="headerlink" title="四、单线程异步"></a>四、单线程异步</h2><p>CoEvent提供了一种极佳的方式来处理回调等异步逻辑</p><pre><code class="csharp">using CoEvent.Async;    //可等待的任务   public async CoTask mTest()    &#123;    //等待600帧        await Async.WaitForFrame(600);        Debug.Log(&quot;Hha&quot;);        //等待3秒        await Async.Delay(3);        Debug.Log(&quot;111&quot;);    &#125;</code></pre><p>使用方式非常的简单，都放在了Async类里，当然也支持取消，挂起等，只需要对CoTask调用拓展方法WithToken</p><pre><code class="csharp">mTest().WithToken(out var token);token.Yield();</code></pre><p>如果您需要进一步的拓展CoTask，只需要写一个方法,CoTask.Create拿到新的CoTask，然后在任务结束时调用它的SetResult即可，可以参考Async类的实现。<br>可以简单的与YooAsset等进行对接</p><h2 id="欢迎加入"><a href="#欢迎加入" class="headerlink" title="欢迎加入"></a>欢迎加入</h2><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305201805505.png" alt="GameDev游研社群聊二维码"></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> CoEvent </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CoEvent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-1</title>
      <link href="/2023/05/19/Doc/WooAsset/WooAsset-1/"/>
      <url>/2023/05/19/Doc/WooAsset/WooAsset-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>foreachGC问题验证</title>
      <link href="/2023/05/19/Unity/CSharp/Csharp%E7%9A%84foreachGCAlloc/"/>
      <url>/2023/05/19/Unity/CSharp/Csharp%E7%9A%84foreachGCAlloc/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Foreach究竟会不会产生GC？"><a href="#一、Foreach究竟会不会产生GC？" class="headerlink" title="一、Foreach究竟会不会产生GC？"></a>一、Foreach究竟会不会产生GC？</h1><p>很多读者在听一些群内大佬谈话过程中可能会听说<strong>foreach遍历集合会产生GC</strong>，笔者也是这么了解的，所以很多读者可能会和笔者一样在网上看到各种说法，将信将疑。<br>主要分为这几个立场：</p><blockquote><p><strong>1.foreach 会产生GC，在unity里别用，Mono的问题<br>2.foreach产生GC是被遍历的集合有问题，实现的不好，不是foreach的锅<br>3.foreach的GC问题已经修复了，大家可以毫不顾忌的使用</strong></p></blockquote><p>笔者在搜索了资料的基础上自己亲手实验，试图证明这些结论哪个是正确的，得到的结论是</p><blockquote><p>网上的其他回答太过远古，甚至存在莫名的歧视foreach<br>有时候会产生一点点GC，但无需否定，甚至在现在可以忽略不计</p></blockquote><p><strong><font color=red>如果不想看实验过程，可以直接翻到文末有结论！！！！</fontcolor></strong></p><h1 id="二、实验过程"><a href="#二、实验过程" class="headerlink" title="二、实验过程"></a>二、实验过程</h1><p>首先我们以最常用的<strong>Dictionary</strong>进行讨论，因为我们经常使用<strong>foreach便捷的遍历Dictionary</strong>，难以用for进行</p><h2 id="1-foreach遍历字典是否存在GC"><a href="#1-foreach遍历字典是否存在GC" class="headerlink" title="1. foreach遍历字典是否存在GC"></a>1. foreach遍历字典是否存在GC</h2><pre><code class="csharp">using System.Collections.Generic;using UnityEngine;using UnityEngine.Profiling;public class MyGCTest : MonoBehaviour&#123;    Dictionary&lt;int,int&gt; dic = new Dictionary&lt;int, int&gt;()    &#123;        &#123; 0, 0 &#125;,        &#123; 1, 1 &#125;    &#125;;    void Update()    &#123;        Profiler.BeginSample(&quot;ForeachGC&quot;);        foreach (var x in dic)&#123;&#125;        Profiler.EndSample();    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305192036507.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305192037774.png" alt="在这里插入图片描述"></p><p><strong>答案显然是存在的</strong>，<strong>但是笔者在不经意间发现，写在Update的foreach</strong>，居然<strong>仅仅在第一次调用时产生GC，以后的循环的foreach均不产生GC</strong>！！</p><h3 id="2-foreach遍历字典在什么时候产生GC-Alloc"><a href="#2-foreach遍历字典在什么时候产生GC-Alloc" class="headerlink" title="2. foreach遍历字典在什么时候产生GC Alloc"></a>2. foreach遍历字典在什么时候产生GC Alloc</h3><p>根据上一步，笔者产生了以下猜想</p><blockquote><p><strong>1.字典内增加一个元素，foreach是否会再次产生GC<br>2.如果我分别遍历多个字典，会不会产生双份的GC</strong><br>3.如果我遍历几个不同类型的字典呢？</p></blockquote><p>根据以下代码验证，笔者在两个文件中分别监测GC的产生</p><pre><code class="csharp">using System.Collections.Generic;using UnityEngine;using UnityEngine.Profiling;public class MyGCTest : MonoBehaviour&#123;    //先整两个不同的字典    Dictionary&lt;int, int&gt; dic = new Dictionary&lt;int, int&gt;()    &#123;        &#123; 0, 0 &#125;    &#125;;    Dictionary&lt;int, int&gt; dic2 = new Dictionary&lt;int, int&gt;()    &#123;        &#123; 0, 0 &#125;,        &#123; 100,100&#125;    &#125;;    void Update()    &#123;        Profiler.BeginSample(&quot;ForeachGC&quot;);        //先遍历一次第一个字典试试        foreach (var x in dic)&#123;&#125;        //新增一个元素再试试        if (!dic.ContainsKey(1)) dic.Add(1, 0);        foreach (var x in dic)&#123;&#125;        //遍历第二个字典        foreach (var x in dic2) &#123;&#125;        Profiler.EndSample();        //此时发现第一帧有0B 的GCAlloc    &#125;&#125;public class MyGCtest2 : MonoBehaviour&#123;    Dictionary&lt;int, int&gt; dic2 = new Dictionary&lt;int, int&gt;()    &#123;        &#123; 0, 0 &#125;,        &#123; 100,100&#125;    &#125;;    void Update()    &#123;        Profiler.BeginSample(&quot;ForeachGC3&quot;);        foreach (var x in dic2) &#123;&#125;        Profiler.EndSample();        //第一帧产生96B GCAlloc    &#125;&#125;</code></pre><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305192037743.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305192037024.png" alt="结果完全相同，这说明了foreach在同一个方法内，"><br>这样我们就能得出</p><blockquote><p><strong>1.无论遍历几个字典，遍历几次，元素是否改变，都只产生96B的GCAlloc</strong><br><strong>2.foreach遍历字典的GCAlloc 全局仅产生一次，与所在文件，方法，类都无关</strong></p></blockquote><p>但是我们接下来想试试不同类型的字典..</p><pre><code class="csharp">Dictionary&lt;int, int&gt; dic2 = new Dictionary&lt;int, int&gt;()    &#123;        &#123; 0, 0 &#125;,        &#123; 100,100&#125;    &#125;;    Dictionary&lt;int, float&gt; dic1 = new Dictionary&lt;int, float&gt;()    &#123;        &#123; 0, 0.2f &#125;,        &#123; 100,100.0f&#125;    &#125;;    void Update()    &#123;        Profiler.BeginSample(&quot;ForeachGC&quot;);        foreach(var x in dic2)        &#123;        &#125;        foreach (var x in dic1)        &#123;        &#125;        Profiler.EndSample();    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305192037423.png" alt="在这里插入图片描述"><br>GC突然变为192B ，是原来的二倍，显然每个类型的字典都会产生96B</p><blockquote><p><strong>1.无论遍历几个字典，遍历几次，元素是否改变，都只产生96B的GCAlloc</strong><br><strong>2.foreach遍历字典的GCAlloc 全局仅产生一次，与所在文件，方法，类都无关</strong><br>3. <strong>foreach遍历字典产生GC与字典类型有关</strong></p></blockquote><h3 id="3-foreach-遍历其他Collection呢？"><a href="#3-foreach-遍历其他Collection呢？" class="headerlink" title="3.foreach 遍历其他Collection呢？"></a>3.foreach 遍历其他Collection呢？</h3><pre><code class="csharp">    List&lt;int&gt; list = new List&lt;int&gt;() &#123; 0,1,0&#125;;    int[] arr= new int[3] &#123; 0,1,0&#125;;    void Update()    &#123;        Profiler.BeginSample(&quot;ForeachGC&quot;);        foreach(var x in list)        &#123;        &#125;        foreach(var x in arr) &#123; &#125;        Profiler.EndSample();    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305192037653.png" alt="在这里插入图片描述"></p><p>甚至第一次GC都没产生，接下来我们仔细发掘一下原理。</p><h1 id="三、foreach-为什么在遍历Dictionary时产生GC"><a href="#三、foreach-为什么在遍历Dictionary时产生GC" class="headerlink" title="三、foreach 为什么在遍历Dictionary时产生GC"></a>三、foreach 为什么在遍历Dictionary时产生GC</h1><p>foreach本质是对GetEnumerator(),MoveNext()等方法的简化，我们对IEnumerable等接口再熟悉不过了。</p><blockquote><p><strong>1.无论遍历几个字典，遍历几次，元素是否改变，都只产生96B的GCAlloc</strong><br><strong>2.foreach遍历字典的GCAlloc 全局仅产生一次，与所在文件，方法，类都无关</strong><br>3. <strong>foreach遍历字典产生GC与字典类型有关</strong></p></blockquote><p>产生这些结论，得出foreach的CG产出和字典类型相关，而与其他的因素无关的结论。我能猜测出GetEnumerator始终返回的是Enumerator的单例，每个字典类型都包含一个实例，所以形成每个字典类型都产生一定GC的现象。</p><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305192037701.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305192037173.png" alt="在这里插入图片描述"><br>我们详细展开分析，发现在GetEnumerator处产生96B，在MoveNext处产生96B<br>甚至笔者为了探究这一内容，写了第三个Dictionary，发现GetEnumerator处产生144B，在MoveNext处产生144B<br>笔者得到了以下结论</p><blockquote><p><strong>1.每个类型Dictionary&lt;T,K&gt;首次foreach均产生96B 的GCAlloc<br>2.每个96B的GCAlloc分别为 48B的GetEnumerator()和 48B的MoveNext()</strong><br><strong>3.Dictionary的迭代方式类似于单例，每个类型全局仅加载一次</strong></p></blockquote><h1 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h1><ol><li><strong><font color=red>foreach在遍历System.Collections.Generic内的集合时不会无理由产生不可接受的GC</strong><br> 事实上，遍历List和数组时不会创建Enumerator，即一直保持0GC</li><li><strong><font color=red>foreach在遍历字典时，仅对每个类型字典在首次调用时产生一次GC,以后同类型字典不会再产生GC，与其他因素无关。</strong><br>也就是说，你只需要对Dictionary&lt;int,int&gt;使用过foreach，以后再使用同类型的字典foreach就不会产生GC，无论是否为同一实例，元素是否变化，文件是否相同，方法和类是否相同。<br>3.<strong><font color=red>对字典Values&#x2F;Keys单独foreach将产生更多的GC，大概多24B,与上面提到的相近，其他一致。</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> foreach </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步与Task-Like</title>
      <link href="/2023/05/19/Unity/CSharp/%E5%BC%82%E6%AD%A5%E4%B8%8ETaskLike/"/>
      <url>/2023/05/19/Unity/CSharp/%E5%BC%82%E6%AD%A5%E4%B8%8ETaskLike/</url>
      
        <content type="html"><![CDATA[<h3 id="文末有反编译IL代码，文首有原理分析！！！"><a href="#文末有反编译IL代码，文首有原理分析！！！" class="headerlink" title="文末有反编译IL代码，文首有原理分析！！！"></a>文末有反编译IL代码，文首有原理分析！！！</h3><p><a href="https://github.com/yueh0607/AirFramework/tree/main/Framework/Core/Async">我的项目地址-github</a>这个地址有可能要求梯子，球球了，觉得好就点个star吧<br>如果上面地址进不去，就进这个<a href="https://gitee.com/imyueh/AirFramework/tree/main/Assets/Framework/Core/Async">”gitee地址“</a>这个更新可能不及时，但是作为参考没问题</p><h1 id="1-异步"><a href="#1-异步" class="headerlink" title="1.异步"></a>1.异步</h1><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202303241053728.png" alt="在这里插入图片描述"></p><pre><code class="csharp">//这个方法在开始时自动被调用void Start()&#123;    AAA();    //这个代表输出到控制台”666“    666.L();&#125;//每隔一秒将输出一个数字，同时不会阻塞主线程的行为public async void AAA()    &#123;        await Async.Delay(1);        1.L();        await Async.Delay(1);        2.L();        await Async.Delay(1);        3.L();        await Async.Delay(1);        4.L();    &#125;</code></pre><p>按照同步的逻辑分析，666应该输出在1234之后，但是在异步中不同，AAA方法不会停留，而是继续向下，可以理解为新开了一个线程执行AAA方法，但是是假的，实际上还是在主线程里。</p><h2 id="原理分析-结合后面一起看"><a href="#原理分析-结合后面一起看" class="headerlink" title="原理分析(结合后面一起看)"></a>原理分析(结合后面一起看)</h2><p>1.Start方法执行到AAA进入方法<br>2.调用AsyncTaskMethodBuilder.Create静态创建并返回Builder<br>3.进入Delay获取Delay返回的AsyncTask对象<br>4.await等待AsyncTask时调用AsyncTask.GetAwaiter返回AsyncTask(IAwiter)<br>5.调用OnCompleted方法，将continuation委托更新为await以后的代码<br>5.等待Dealy方法内的Timer对象完成回调AsyncTask.SetResult方法<br>6.调用SetResult后，执行continuation委托，执行await之后的代码<br>7.进入下一个await</p><p>以上大错特错，其实这个过程是在编译时生成了一个异步状态机。用代码生成的方式展开了这个异步的过程，而不是在调用来调用去。</p><p>总结：OnCompleted的continuation就是await之后，直到方法结束的代码，每次执行到await都会执行来更新到下一个段落，此前会检查IsCompleted，然后需要我们调用SetResult才能切换到下一个状态。</p><h1 id="2-自定义await支持"><a href="#2-自定义await支持" class="headerlink" title="2.自定义await支持"></a>2.自定义await支持</h1><p>首先毫无道理的讲，<strong>C#就要求我们定义的类满足这个要求才能像下面这么写</strong>，原因简单粗暴：编译器要调用这个方法，按照要求做就可以。</p><pre><code class="csharp">await new AsyncTask();</code></pre><p><font color=red>  <strong>要想使得类支持await关键字的唯一要求：</strong> <strong>包含GetAwaiter方法</strong></font>(也可以是拓展方法)<br>我们当然不允许项目内出现这样的无礼要求！！！用接口约束可等待的类，<font color=red>  <strong>只要实现了这个接口，就能被await关键字支持。</strong></font></p><pre><code class="csharp">    public interface IAwaitable&lt;out TAwaiter&gt; where TAwaiter : IAwaiter    &#123;        TAwaiter GetAwaiter();    &#125;    public interface IAwaitable&lt;out TAwaiter,out TResult&gt; where TAwaiter : IAwaiter&lt;TResult&gt;    &#123;        TAwaiter GetAwaiter();    &#125;</code></pre><p>我们可以看到GetAwaiter方法返回了一个IAwaiter，接下来我们尝试自定义Awaiter</p><h1 id="3-自定义Awaiter"><a href="#3-自定义Awaiter" class="headerlink" title="3.自定义Awaiter"></a>3.自定义Awaiter</h1><p><font color=red><strong>System.Runtime.CompilerServices</strong></font>命名空间下提供了这样两个接口，<font color=red><strong>编译器要求Awaiter必须实现其中一个接口</strong></font></p><pre><code class="csharp">    public interface INotifyCompletion    &#123;        void OnCompleted(Action continuation);    &#125;    public interface ICriticalNotifyCompletion : INotifyCompletion    &#123;        void UnsafeOnCompleted(Action continuation);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202303241053728.jpeg" alt="在这里插入图片描述"><br><strong>关于Awaiter的要求：</strong></p><ol><li><font color=red><strong>有bool IsCompleted { get; }</strong>   </font></li><li><font color=red><strong>有GetResult方法</strong></font></li></ol><p>关于IsCompleted，异步流程执行到await时，会检查IsCompleted，如果为true，则表明任务已经完成，await直接结束。</p><pre><code class="csharp">int value = await GetValueAsync();</code></pre><p>关于GetResult也很好理解，我们不陌生上面这样的语法，在await被结束时，会调用GetResult方法返回一个值。</p><pre><code class="csharp">    public interface IAwaiter : INotifyCompletion    &#123;        bool IsCompleted &#123; get; &#125;        void GetResult();    &#125;        public interface IAwaiter&lt;T&gt; : INotifyCompletion    &#123;        bool IsCompleted &#123; get; &#125;        T GetResult();    &#125;    public interface ICriticalAwaiter :ICriticalNotifyCompletion,IAwaiter    &#123;    &#125;    public interface ICriticalAwaiter&lt;T&gt;:ICriticalNotifyCompletion,IAwaiter&lt;T&gt;    &#123;    &#125;</code></pre><p>在上面我们定义了四个接口，都是与Awaiter相关的，CriticalAwaiter不同的是UnsafeOnCompleted方法，在异步执行的代码可能给程序产生负面影响(如异常)时，我们可以使用这个Awaiter接口。</p><h1 id="3-自定义异步任务接口"><a href="#3-自定义异步任务接口" class="headerlink" title="3. 自定义异步任务接口"></a>3. 自定义异步任务接口</h1><p>我们进一步拓展，给异步任务更多的功能，这些不是编译器的要求了，而是我们自己的需要。<br>当任务完成时，<strong>我们可以手动调用</strong>SetResult，在出现异常时调用SetException。</p><pre><code class="csharp"> public interface IAsyncTask : ICriticalAwaiter    &#123;           void SetResult();        void SetException(Exception exception);    &#125;    public interface IAsyncTask&lt;T&gt; : ICriticalAwaiter&lt;T&gt;     &#123;        //参数就是GetResult拿到的结果        void SetResult(T result);        void SetException(Exception exception);    &#125;</code></pre><h1 id="4-实现异步任务类"><a href="#4-实现异步任务类" class="headerlink" title="4.实现异步任务类"></a>4.实现异步任务类</h1><p><strong>千万记住要加上这个特性</strong>，只有这样才能指定AsyncTask作为返回值时进行AsyncTaskMethodBuilder自动创建，泛型时写<strong>[AsyncMethodBuilder(typeof(AsyncTaskMethodBuilder&lt;&gt;))]</strong></p><pre><code class="csharp">    //特性指定AsyncMethodBuilder    [AsyncMethodBuilder(typeof(AsyncTaskMethodBuilder))]    public partial class AsyncTask : PoolableObject&lt;AsyncTask&gt;, IAsyncTask    &#123;        public AsyncTask GetAwaiter() =&gt; this;        public Action continuation;        public Exception Exception &#123; get; private set; &#125;        public bool IsCompleted &#123; get; set; &#125;               public void OnCompleted(Action continuation)        &#123;            UnsafeOnCompleted(continuation);        &#125;        public void UnsafeOnCompleted(Action continuation)        &#123;            this.continuation = continuation;        &#125;        public void SetException(Exception exception)        &#123;            IsCompleted= true;            this.Exception = exception;        &#125;        //啥也不返回        public void GetResult()&#123; &#125;        public void SetResult()        &#123;            //执行await以后的代码            continuation?.Invoke();            //回收到Pool内            this.Dispose();        &#125;    &#125;</code></pre><h1 id="5-AsyncTaskMethodBuilder"><a href="#5-AsyncTaskMethodBuilder" class="headerlink" title="5.AsyncTaskMethodBuilder"></a>5.AsyncTaskMethodBuilder</h1><p>没错，这些又是编译器的无礼要求，已经快要成模板了</p><pre><code class="csharp"> public struct AsyncTaskMethodBuilder    &#123;        private AsyncTask task;        // 1. Static Create method 编译器调用静态创建方法来创建Builder        [DebuggerHidden]        public static AsyncTaskMethodBuilder Create() =&gt; new AsyncTaskMethodBuilder(AsyncTask.Create(fromPool:true));        //2.Construct Method 构造Builder时调用        public AsyncTaskMethodBuilder(AsyncTask task) =&gt; this.task = task;        // . TaskLike Task property.        [DebuggerHidden]        public AsyncTask Task =&gt; task;        // 3. Start 构造之后开启状态机        [DebuggerHidden]        public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine        &#123;            stateMachine.MoveNext();        &#125;        // 4. SetException 当出现异常时编译器调用，将异常绑定到任务        [DebuggerHidden]        public void SetException(Exception exception)        &#123;            task.SetException(exception);        &#125;        // 5. SetResult 当任务成功完成时编译器调用这个方法,将该任务标记为已成功完成        [DebuggerHidden]        public void SetResult()        &#123;            task.SetResult();        &#125;        // 6. AwaitOnCompleted  在SetResult之后编译器调用OnCompleted        [DebuggerHidden]        public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine        &#123;            awaiter.OnCompleted(stateMachine.MoveNext);        &#125;        // 7. AwaitUnsafeOnCompleted 同OnCompleted        [SecuritySafeCritical]        public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine        &#123;            awaiter.OnCompleted(stateMachine.MoveNext);        &#125;        // 9. SetStateMachine  将生成器与指定的状态机相关联        [DebuggerHidden]        public void SetStateMachine(IAsyncStateMachine stateMachine)        &#123;        &#125;    &#125;</code></pre><p>不用担心这个OnCompleted参数委托的GC问题，因为代码会在编译时被静态编译为一个状态机，实际上编译后的IL代码不是我们所见的这样。</p><h1 id="6-Delay方法"><a href="#6-Delay方法" class="headerlink" title="6.Delay方法"></a>6.Delay方法</h1><p>我写了一个例子来使用这个AsyncTask，由于全部从池内取出，并没有GC产出，而C#原生的Task类型显得十分臃肿，带有高昂的GC代价。</p><pre><code class="csharp"> public static AsyncTask Delay(float seconds)        &#123;            var task = Framework.Pool.Allocate&lt;AsyncTask&gt;();            var timer = Framework.Pool.Allocate&lt;TimerCall&gt;();            timer.OnCompleted += task.SetResult;            timer.OnCompleted += timer.Dispose;            timer.Start(TimeSpan.FromSeconds(seconds));            return task;        &#125;</code></pre><h1 id="C-3-0-反编译-System-Tasks-Task-的-IL-代码"><a href="#C-3-0-反编译-System-Tasks-Task-的-IL-代码" class="headerlink" title="C # 3.0 反编译 System.Tasks.Task 的 IL 代码"></a>C # 3.0 反编译 System.Tasks.Task 的 IL 代码</h1><p>被反编译的代码</p><pre><code class="csharp">        public async Task TaskTest()        &#123;            await Task.Run(() =&gt; &#123; &#125;);        &#125;</code></pre><p>反编译结果IL代码</p><pre><code class="csharp">    [CompilerGenerated]    private sealed class &lt;TaskTest&gt;d__1 : IAsyncStateMachine    &#123;        public int &lt;&gt;1__state;        public AsyncTaskMethodBuilder &lt;&gt;t__builder;        public ClassA &lt;&gt;4__this;        private TaskAwaiter &lt;&gt;u__1;        private void MoveNext()        &#123;            int num = &lt;&gt;1__state;            try            &#123;                TaskAwaiter awaiter;                if (num != 0)                &#123;                    awaiter = Task.Run(delegate                    &#123;                    &#125;).GetAwaiter();                    if (!awaiter.IsCompleted) //await修饰的状态未完成？把控制器交由该类                    &#123;                        num = (&lt;&gt;1__state = 0);                        &lt;&gt;u__1 = awaiter;                        &lt;TaskTest&gt;d__1 stateMachine = this;                        &lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);                        return;                    &#125;                &#125;                else                &#123;                    awaiter = &lt;&gt;u__1;                    &lt;&gt;u__1 = default(TaskAwaiter);                    num = (&lt;&gt;1__state = -1);                &#125;                awaiter.GetResult();            &#125;            catch (Exception exception)            &#123;                &lt;&gt;1__state = -2;                &lt;&gt;t__builder.SetException(exception);                return;            &#125;            &lt;&gt;1__state = -2;            &lt;&gt;t__builder.SetResult();        &#125;        void IAsyncStateMachine.MoveNext()        &#123;            //ILSpy generated this explicit interface implementation from .override directive in MoveNext            this.MoveNext();        &#125;        [DebuggerHidden]        private void SetStateMachine(IAsyncStateMachine stateMachine)        &#123;        &#125;        void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)        &#123;            //ILSpy generated this explicit interface implementation from .override directive in SetStateMachine            this.SetStateMachine(stateMachine);        &#125;    &#125;    [AsyncStateMachine(typeof(&lt;TaskTest&gt;d__1))]    [DebuggerStepThrough]    public Task TaskTest()    &#123;        &lt;TaskTest&gt;d__1 stateMachine = new &lt;TaskTest&gt;d__1();        stateMachine.&lt;&gt;4__this = this;        stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create(); //创那就状态机        stateMachine.&lt;&gt;1__state = -1; //初始状态-1        AsyncTaskMethodBuilder &lt;&gt;t__builder = stateMachine.&lt;&gt;t__builder;        &lt;&gt;t__builder.Start(ref stateMachine); //启动状态机        return stateMachine.&lt;&gt;t__builder.Task; //返回值    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> Coroutine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆角</title>
      <link href="/2023/05/16/Unity/Shader/%E5%9C%86%E8%A7%92/"/>
      <url>/2023/05/16/Unity/Shader/%E5%9C%86%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-效果与引言"><a href="#一、-效果与引言" class="headerlink" title="一、 效果与引言"></a>一、 效果与引言</h1><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728219.png" alt="在这里插入图片描述"><br>相信很多小伙伴都会遇到做<strong>圆角矩形</strong>的需求，网上的shader还不明白是怎么实现的，甚至还有一部分是错误的，本文讲从原理到代码讲解<strong>圆角矩形shader</strong>的实现</p><h1 id="二、-原理分析"><a href="#二、-原理分析" class="headerlink" title="二、 原理分析"></a>二、 原理分析</h1><p>想要实现一个圆角矩形，常见的是抽象成一个数学模型，如下图紫色区域，就是我们应该保留的区域，为了更准确的描述这个图形，我们在四个角创建四个相等的圆形。<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728401.png" alt="在这里插入图片描述"><br>因为控制每个像素的颜色主要是由<strong>片元着色器</strong>负责的，所以我们也通过<strong>Fragment Shader</strong>去实现这个效果，可以看到在这个函数里我们只能拿到 <strong>uv</strong>和vertex，所以我们<strong>根据uv坐标判定是否在上图的紫色区域，如果在则返回原本的颜色，如果不在返回完全透明的颜色。</strong><br><strong>(对每个像素都会执行一次frag函数获取真正渲染的颜色)</strong></p><pre><code class="c">struct v2f            &#123;                float2 uv : TEXCOORD0;                UNITY_FOG_COORDS(1)                float4 vertex : SV_POSITION;            &#125;;             fixed4 frag (v2f i) : SV_Target &#123;     //....省略 &#125;</code></pre><p>因为我们通过uv来判断是否是紫色区域，所以我们需要先了解uv坐标系<br>首先我们要了解<strong>UV坐标系</strong>，这并不是什么高深的数学概念，而是一个简单的道理。<br>首先，我们<strong>把水平方向定义为X轴，竖直方向为Y轴</strong>，<strong>把图片左下角定义为(0,0)，右上角定义为(1,1)，其他的坐标以此类推</strong></p><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728852.png" alt="在这里插入图片描述"></p><p>读者可能会产生疑惑，为什么xy两个轴长度不同，但是坐标却不相同？<br>笔者暂时只能这样描述：我们就如此定义一个坐标系，x轴和y轴单位长度不同</p><p>我们需要用户去调整四个<strong>圆形的半径 设为Radius</strong>，因为uv坐标系的xy单位长度不同，我们设<strong>Ratio &#x3D; Height&#x2F;Width</strong>，Ratio即为y轴单位长度与x轴单位长度之比。</p><blockquote><p>float Radius   圆形半径<br>float Ratio  Y单位长度&#x2F;X单位长度</p></blockquote><p>接下来我们在图上画四个圆形并作辅助线</p><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728534.png" alt="在这里插入图片描述"><br>通过观察，我们可以发现以下特征</p><blockquote><p>1.<strong>只有在红色区域才有可能被舍弃</strong><br>2.<strong>三个圆形R2，R3，R4对应红色区域的任意一个位置，都能在R1内找到等价位置</strong><br>3. <strong>UV坐标转正常坐标的公式为 f (x ,y)&#x3D; (uv.x  , uv.y * Ratio)</strong></p></blockquote><p>在UV坐标内，我们无法通过x^2^ + y^2^ 来计算长度，因为uv坐标的xy单位不同，所以我们通过上述的坐标转换公式来转化为相同的坐标系</p><p>我们需要按以下步骤进行处理</p><blockquote><p>1.<strong>将白色区域坐标在左下角找到等价uv坐标，position &#x3D; abs(step(0.5,uv) - uv)</strong><br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728432.png" alt="在这里插入图片描述"><br>2.<strong>判断等价uv是否在左下角可能舍弃区域，</strong>uv.x&lt;Raduis &amp;&amp; uv.y &lt;  Radius * Ratio**<br>如果不在，则返回原色，如果在则进入下一步**<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728553.png" alt="在这里插入图片描述"></p><ol start="3"><li><strong>求圆心距 distance &#x3D;   [f(uv.x,uv.y) - f(Radius,Radius)]的长度<br>如果大于半径则返回fixed(0,0,0,0)，否则返回原色</strong><br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191728084.png" alt="在这里插入图片描述"></li></ol></blockquote><h1 id="三、着色器代码"><a href="#三、着色器代码" class="headerlink" title="三、着色器代码"></a>三、着色器代码</h1><p>在shader内尽量不要使用if语句<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191729794.png" alt="在这里插入图片描述"><br>以上来着自Hking_Auditore 大大的Shader入门书，通常我们用step和lerp等来代替if<br>step函数的逻辑可以等价为</p><pre><code class="c">step (a, x)&#123;  if (a&gt;x)  return 0;  else return 1;&#125;</code></pre><p>接下来的代码虽然看着多，实际上我们只写了两行<br>这就是这两行</p><pre><code class="csharp"> float2 p = abs(step(0.5,i.uv) - i.uv); fixed4 col =  tex2D(_MainTex, i.uv) * (step(_Radius,p.x) ||step( _Radius  ,p.y*_Ratio) || step(length(float2(p.x-_Radius,p.y*_Ratio-_Radius)),_Radius));</code></pre><p>这是完整的着色器代码</p><pre><code class="c">Shader &quot;Unlit/MyShader&quot;&#123;    Properties    &#123;        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Radius (&quot;Radius&quot;,float) = 0        _Ratio(&quot;Height/Width&quot;,float )= 1    &#125;    SubShader    &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot;&#125;        LOD 100        Blend SrcAlpha OneMinusSrcAlpha        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            // make fog work            #pragma multi_compile_fog            #include &quot;UnityCG.cginc&quot;            struct appdata            &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;            &#125;;            struct v2f            &#123;                float2 uv : TEXCOORD0;                UNITY_FOG_COORDS(1)                float4 vertex : SV_POSITION;            &#125;;            sampler2D _MainTex;            float4 _MainTex_ST;            float _Radius;            float _Ratio;            v2f vert (appdata v)            &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                o.uv = TRANSFORM_TEX(v.uv, _MainTex);                UNITY_TRANSFER_FOG(o,o.vertex);                return o;            &#125;            fixed4 frag (v2f i) : SV_Target            &#123;                  //坐标等价到左下角                float2 p = abs(step(0.5,i.uv) - i.uv);                //三个条件同时成立则乘0，否则乘1                //1.在左下角  ，2.长度超过半径                fixed4 col =  tex2D(_MainTex, i.uv) * (step(_Radius,p.x) ||step( _Radius  ,p.y*_Ratio) || step(length(float2(p.x-_Radius,p.y*_Ratio-_Radius)),_Radius));                UNITY_APPLY_FOG(i.fogCoord, col);                return col;            &#125;            ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊-毛玻璃</title>
      <link href="/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/"/>
      <url>/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../../Pic/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83.png" alt="效果"></p><pre><code class="cg">Shader &quot;UI/UiObscure&quot;&#123;    Properties    &#123;        _Radius(&quot;Radius&quot;, Range(1, 255)) = 1        _MainTex(&quot;Tint Color (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Interval(&quot;Blur Nuance&quot;,Range(0.1, 100)) = 1        [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)] _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        [HideInInspector] _Stencil (&quot;Stencil ID&quot;, Float) = 0        [HideInInspector][Enum(UnityEngine.Rendering.StencilOp)] _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        [HideInInspector] _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        [HideInInspector] _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        [HideInInspector] _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        // Outline properties are drawn via custom editor.        [HideInInspector] _OutlineWidth(&quot;Outline Width&quot;, Range(0,8)) = 3.0        [HideInInspector] _OutlineColor(&quot;Outline Color&quot;, Color) = (1,1,0,1)        [HideInInspector] _OutlineReferenceTexWidth(&quot;Reference Texture Width&quot;, Int) = 1024        [HideInInspector] _ThresholdEnd(&quot;Outline Threshold&quot;, Range(0,1)) = 0.25        [HideInInspector] _OutlineSmoothness(&quot;Outline Smoothness&quot;, Range(0,1)) = 1.0        [HideInInspector][MaterialToggle(_USE8NEIGHBOURHOOD_ON)] _Use8Neighbourhood(&quot;Sample 8 Neighbours&quot;, Float) = 1        [HideInInspector] _OutlineMipLevel(&quot;Outline Mip Level&quot;, Range(0,3)) = 0    &#125;     Category    &#123;        Tags&#123; &quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;         SubShader        &#123;                     Stencil            &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]            &#125;                        Cull Off            Lighting Off            ZWrite Off            ZTest [unity_GUIZTestMode]            Fog &#123; Mode Off &#125;            Blend One OneMinusSrcAlpha            ColorMask [_ColorMask]                    GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM                #pragma vertex vert                #pragma fragment frag                #pragma fragmentoption ARB_precision_hint_fastest                #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                    v2f o;                    o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                    float scale = -1.0;                    #else                    float scale = 1.0;                    #endif                    o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                    o.uvgrab.zw = o.vertex.zw;                    return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                float _Interval;                half4 frag(v2f i) : COLOR                &#123;                    half4 sum = half4(0,0,0,0);                                 #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                                 sum += GRABXYPIXEL(0.0, 0.0);                    int measurments = 1;                                 for (float range = _Interval; range &lt;= _Radius; range += _Interval)                    &#123;                        sum += GRABXYPIXEL(range, range);                        sum += GRABXYPIXEL(range, -range);                        sum += GRABXYPIXEL(-range, range);                        sum += GRABXYPIXEL(-range, -range);                        measurments += 4;                    &#125;                    return sum / measurments;                &#125;            ENDCG            &#125;        GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma fragmentoption ARB_precision_hint_fastest            #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                float scale = -1.0;                    #else                float scale = 1.0;                    #endif                o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                o.uvgrab.zw = o.vertex.zw;                return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                    half4 frag(v2f i) : COLOR                &#123;                            half4 sum = half4(0,0,0,0);                float radius = 1.41421356237 * _Radius;                                #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                            sum += GRABXYPIXEL(0.0, 0.0);                int measurments = 1;                            for (float range = 1.41421356237f; range &lt;= radius * 1.41; range += 1.41421356237f)                &#123;                sum += GRABXYPIXEL(range, 0);                sum += GRABXYPIXEL(-range, 0);                sum += GRABXYPIXEL(0, range);                sum += GRABXYPIXEL(0, -range);                measurments += 4;                &#125;                            return sum / measurments;                &#125;            ENDCG            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书写方式</title>
      <link href="/2023/05/15/README/"/>
      <url>/2023/05/15/README/</url>
      
        <content type="html"><![CDATA[<h2 id="sadasda"><a href="#sadasda" class="headerlink" title="sadasda"></a>sadasda</h2><h4 id="57d8a"><a href="#57d8a" class="headerlink" title="57d8a"></a>57d8a</h4><ul><li>哈哈哈</li><li>康康康<ul><li>777</li><li>888</li></ul></li><li>999</li></ul><pre><code class="csharp">public class A&#123;    public void DO()&#123;&#125;&#125;</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><img src="/../Pic/R-C.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
