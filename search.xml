<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WooAsset-安装</title>
      <link href="/2023/06/27/Doc/WooAsset/1-WooAsset-%E5%AE%89%E8%A3%85/"/>
      <url>/2023/06/27/Doc/WooAsset/1-WooAsset-%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="方法一：通过UnityPackage安装"><a href="#方法一：通过UnityPackage安装" class="headerlink" title="方法一：通过UnityPackage安装"></a>方法一：通过UnityPackage安装</h1><ul><li>打开Unity Package Manager</li><li>点击左上角加号 选择 Add package from git URL</li><li>输入 <a href="https://github.com/OnClick9927/WooAsset.git#1.0.6">https://github.com/OnClick9927/WooAsset.git#1.0.6</a></li><li>点击Add后，稍等片刻即可完成安装</li><li>注意：具体版本号以tag为准</li></ul><h1 id="方法二：通过Git安装"><a href="#方法二：通过Git安装" class="headerlink" title="方法二：通过Git安装"></a>方法二：通过Git安装</h1><ul><li>git clone <a href="https://github.com/OnClick9927/WooAsset">https://github.com/OnClick9927/WooAsset</a></li><li>把 WooAsset文件夹拖入Unity工程即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-配置</title>
      <link href="/2023/06/27/Doc/WooAsset/2-WooAsset-%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/06/27/Doc/WooAsset/2-WooAsset-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次使用"><a href="#第一次使用" class="headerlink" title="第一次使用"></a>第一次使用</h1><ul><li>打开编辑器窗口，操作如下图</li><li>如果报错，关闭窗口再打开一次即可</li><li>如果成功了，会在Assets&#x2F;Editor目录下看到两个配置文件<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"><br><img src="/../../../Pic/Doc/WooAsset/configasset.png" alt="Alt text"></li></ul><h1 id="配置资源"><a href="#配置资源" class="headerlink" title="配置资源"></a>配置资源</h1><p><img src="/../../../Pic/Doc/WooAsset/buildcfgwin.png" alt="Alt text"></p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>BuildGroups</td><td>打包的资源组</td></tr><tr><td>ignoreFileExtend</td><td>不需要打包的文件后缀</td></tr><tr><td>Version</td><td>此次打包出去的版本</td></tr><tr><td>Bundle Size</td><td>打出来的bundle最大大小</td></tr><tr><td>ignore Type Tree change</td><td></td></tr><tr><td>Compress</td><td>资源压缩格式</td></tr><tr><td>Asset Build</td><td>自定义打包流程（可扩展）</td></tr><tr><td>Encrypt</td><td>文件加密方式（可扩展）</td></tr><tr><td>Output Path</td><td>输出路径</td></tr><tr><td>Build Target</td><td>当前打包的平台</td></tr><tr><td>History Path</td><td>历史文件所在文件夹，第一次打包时候把他删了，后续不要动里面的文件</td></tr></tbody></table><h2 id="资源组介绍"><a href="#资源组介绍" class="headerlink" title="资源组介绍"></a>资源组介绍</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>Build</td><td>该组是否需要打包 （给分布式打包使用）</td></tr><tr><td>Name</td><td>组的名字（不可重复，不为空）</td></tr><tr><td>Path</td><td>组对应的项目路径  （不可重复，不为空）</td></tr><tr><td>Description</td><td>对组加点描述</td></tr><tr><td>Tags</td><td>对组加一些标记</td></tr></tbody></table><ul><li>每个资源组均可以分开打包，更新，加载</li><li>保持好良好的资源组结构，方式生成过多冗余</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-构建与部署</title>
      <link href="/2023/06/27/Doc/WooAsset/3-WooAsset-%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/06/27/Doc/WooAsset/3-WooAsset-%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><ul><li>设置好需要打包的组</li><li>点击Tools&#x2F;WooAsset&#x2F;Build</li><li>稍等片刻即可完成打包，内容全都在输出目录下<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"></li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>CDN└─android    ├─v1.0（APP版本）    ├─v1.1（APP版本）    └─v2.0（APP版本）└─iphone    ├─v1.0（APP版本）    ├─v1.1（APP版本）    └─v2.0（APP版本）</code></pre><ul><li>也可以允许下面的目录结构</li><li>所有的版本文件都在一起</li></ul><pre><code>CDN└─android└─iphone</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-着色器变体与图集</title>
      <link href="/2023/06/27/Doc/WooAsset/4-WooAsset-%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E4%BD%93%E4%B8%8E%E5%9B%BE%E9%9B%86/"/>
      <url>/2023/06/27/Doc/WooAsset/4-WooAsset-%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E4%BD%93%E4%B8%8E%E5%9B%BE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><img src="/../../../Pic/Doc/WooAsset/svcandsa.png" alt="Alt text"></p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>shaderVariantDirectory</td><td>svc   输出的文件夹</td></tr><tr><td>atlasPaths</td><td>需要做图集的文件夹（给一个根路径即可）</td></tr><tr><td>packSetting</td><td>图集设置</td></tr><tr><td>textureSetting</td><td>图集设置</td></tr><tr><td>PlatformSetting</td><td>图集设置</td></tr></tbody></table><h1 id="收集着色器变体"><a href="#收集着色器变体" class="headerlink" title="收集着色器变体"></a>收集着色器变体</h1><ul><li>设置好shaderVariantDirectory</li><li>点击Tools&#x2F;WooAsset&#x2F;Help&#x2F;ShaderVariant</li><li>稍等片刻即可完成，内容全都在shaderVariantDirectory目录下<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"></li></ul><h1 id="生成图集"><a href="#生成图集" class="headerlink" title="生成图集"></a>生成图集</h1><ul><li>设置好图集相关设置</li><li>点击Tools&#x2F;WooAsset&#x2F;Help&#x2F;SpriteAtlas</li><li>稍等片刻即可完成<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-更新与初始化</title>
      <link href="/2023/06/27/Doc/WooAsset/5-WooAsset-%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%20copy/"/>
      <url>/2023/06/27/Doc/WooAsset/5-WooAsset-%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%20copy/</url>
      
        <content type="html"><![CDATA[<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><pre><code class="csharp">Assets.SetAssetsSetting(new LocalSetting());//拉取远端版本信息var op = await Assets.VersionCheck();//远端的所有版本数据，内容是buildGroupvar versions = op.versions;//远端和本地进行版本比较//可选参数 versionIndex 和远端的第几个版本比较，不传入就是最后一个版本//可选参数 tags 只比较包含标签的组，不传入就是所有组var compare = await op.Compare(op.versions.Count);//下载所有需要更新的资源for (int i = 0; i &lt; compare.add.Count; i++)    await Assets.DownLoadBundle(compare.add[i].name);for (int i = 0; i &lt; compare.change.Count; i++)    await Assets.DownLoadBundle(compare.change[i].name);</code></pre><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><pre><code class="csharp">Assets.SetAssetsSetting(new LocalSetting());//初始化//可选参数 version 初始化哪一个版本，不传就是本地版本，本地没有就是远端最新版本//可选参数 again 再一次初始化（使用场景，热更新界面也热更）//可选参数 tags 只初始化包含标签的组，不传入就是所有组await Assets.InitAsync();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-加载与卸载</title>
      <link href="/2023/06/27/Doc/WooAsset/6-WooAsset-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD/"/>
      <url>/2023/06/27/Doc/WooAsset/6-WooAsset-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">///正常加载var asset = await Assets.LoadAssetAsync(path);///获取要加载的资源var sp = asset.GetAsset&lt;Sprite&gt;();///加载场景var sceneAsset = await Assets.LoadSceneAssetAsync(path);await sceneAsset.LoadSceneAsync(LoadSceneMode.Additive);///加载Unity无法识别的资源var asset = await Assets.LoadAssetAsync(path);RawObject raw = asset.GetAsset&lt;RawObject&gt;();Debug.Log(raw.bytes.Length);///加载子资源var mainAsset = await Assets.LoadAssetAsync(path);var sp = mainAsset.GetSubAsset&lt;Sprite&gt;(&quot;a_1&quot;);///卸载资源Assets.Release(asset)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-个性化</title>
      <link href="/2023/06/27/Doc/WooAsset/7-WooAsset-%E4%B8%AA%E6%80%A7%E5%8C%96/"/>
      <url>/2023/06/27/Doc/WooAsset/7-WooAsset-%E4%B8%AA%E6%80%A7%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="打包个性化"><a href="#打包个性化" class="headerlink" title="打包个性化"></a>打包个性化</h2><pre><code class="csharp"> //个性化打包流程public interface IAssetBuild&#123;    //自定义版本规则    string GetVersion(string settingVersion, AssetTaskContext context);    //自定义 资源 Tag （可以按照tag加载一组资源）    IReadOnlyList&lt;string&gt; GetTags(EditorAssetData info);    // 自定义资源分组    void Create(AssetTagCollection tags,List&lt;EditorAssetData&gt; assets, Dictionary&lt;EditorAssetData, List&lt;EditorAssetData&gt;&gt; dpsDic, List&lt;BundleGroup&gt; result);    //自定义打包结束之后需要执行的任务    //比如输出一些Log、上传文件到服务器等    List&lt;AssetTask&gt; GetPipelineFinishTasks(AssetTaskContext context);    //更具一个路径返回资源类型    AssetType GetAssetType(string path);&#125;</code></pre><h2 id="加载个性化"><a href="#加载个性化" class="headerlink" title="加载个性化"></a>加载个性化</h2><pre><code class="csharp">///写一个 class 继承于 AssetsSettingpublic abstract class AssetsSetting&#123;  ///自定义Bundle下载器  public virtual BundleDownloader GetBundleDownloader(string url,string bundleName) &#123;&#125;  ///下载的路径  protected virtual string GetBaseUrl() &#123;&#125;  ///自定义 bundle 去哪里下载  public virtual string GetUrlByBundleName(string buildTarget, string bundleName)&#123;&#125;  ///自定义 版本文件 去哪里下载  public virtual string GetVersionUrl(string buildTarget)&#123;&#125;  /// 文件比对方式  public virtual FileCompareType GetFileCheckType() &#123;&#125;  /// 下载等待  public virtual int GetWebRequestTimeout() &#123;&#125;  ///资源加密方式  public virtual IAssetStreamEncrypt GetEncrypt() &#123;&#125;  ///是否自动卸载  public virtual bool GetAutoUnloadBundle() &#123;&#125;  /// 如果本地没有是否需要保存文件  public virtual bool GetSaveBundlesWhenPlaying()&#123;&#125;  /// 自定义的资源生命周期管理，bundle和asset均可以  public virtual IAssetLife GetAssetLife()&#123;&#125;&#125;</code></pre><h2 id="资源加密"><a href="#资源加密" class="headerlink" title="资源加密"></a>资源加密</h2><pre><code class="csharp">//个性化加密public interface IAssetStreamEncrypt&#123;    byte[] Encode(string bundleName, byte[] buffer);    byte[] Decode(string bundleName, byte[] buffer);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-运行时扩展功能</title>
      <link href="/2023/06/27/Doc/WooAsset/8-WooAsset-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/06/27/Doc/WooAsset/8-WooAsset-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="资源模糊搜索"><a href="#资源模糊搜索" class="headerlink" title="资源模糊搜索"></a>资源模糊搜索</h2><pre><code class="csharp">public class AssetsSearch    &#123;///以下是交集        public static IReadOnlyList&lt;string&gt; IntersectNameAndTag(string assetName, params string[] tags);        public static IReadOnlyList&lt;string&gt; IntersectTag(params string[] tags);        public static IReadOnlyList&lt;string&gt; IntersectTypeAndNameAndTag(AssetType type, string assetName, params string[] tags);        public static IReadOnlyList&lt;string&gt; IntersectTypeAndTag(AssetType type, params string[] tags);///以下是并集        public static IReadOnlyList&lt;string&gt; Union(params string[] nameOrTags);        public static IReadOnlyList&lt;string&gt; UnionTag(params string[] tags);        public static IReadOnlyList&lt;string&gt; UnionName(params string[] names);        public static IReadOnlyList&lt;string&gt; UnionNameAndTag(string assetName, params string[] tags);        public static IReadOnlyList&lt;string&gt; UnionTypeAndNameAndTag(AssetType type, string assetName, params string[] tags);        public static IReadOnlyList&lt;string&gt; UnionTypeAndTag(AssetType type, params string[] tags);        public static IReadOnlyList&lt;string&gt; AssetPathByType(AssetType type);    &#125;</code></pre><h2 id="资源组加载"><a href="#资源组加载" class="headerlink" title="资源组加载"></a>资源组加载</h2><pre><code class="csharp">//准备一组资源string[] groups ;var assets= await Assets.PrepareAssets(groups)///加载对应的资源方法一string path;var asset = assets.FindAsset(path)///加载对应的资源方法二var asset = Assets.LoadAssetAsync(path)///把整组资源全都卸载了assets.Release();///配合资源模糊搜索一起使用//使用场景，进入战斗场景之前把战斗需要的资源全加载</code></pre><h2 id="方便的资源卸载"><a href="#方便的资源卸载" class="headerlink" title="方便的资源卸载"></a>方便的资源卸载</h2><h3 id="基础方式"><a href="#基础方式" class="headerlink" title="基础方式"></a>基础方式</h3><ul><li>场景</li><li>一个ui界面上面有一个image</li><li>运行时候需要不停的替换image的sprite</li><li>界面关闭的时候需要把image的sprite卸载</li></ul><pre><code class="csharp">///所有的设置图片都走这个方法public static async void SetSprite(Image image, string path)&#123;    var asset = await Assets.LoadAssetAsync(path);    if (asset.isErr) return;    image.sprite = asset.GetAsset&lt;Sprite&gt;();    Assets.AddBridge(new GameObjectBridge(image.gameObject,asset));&#125;///在合适的时候调用一次即可（比如：切换场景时候）public static void ReleaseUselessBridges()&#123;    Assets.ReleaseUselessBridges();&#125;</code></pre><h3 id="更加方便的方式（有风险）"><a href="#更加方便的方式（有风险）" class="headerlink" title="更加方便的方式（有风险）"></a>更加方便的方式（有风险）</h3><pre><code class="csharp">public class LocalSetting : AssetsSetting&#123;    public override IAssetLife GetAssetLife()    &#123;      /// 参数是缓存的内存大小，超过这个数字会自动卸载最早的资源        return new LRULife(1024 * 50);    &#125;&#125;Assets.SetAssetsSetting(new LocalSetting());</code></pre><ul><li>可以实现 bundle 不自动卸载，到达一定大小在开始卸载</li><li>如果内存不足时候，最早被使用的资源会被优先卸载</li><li>内存设置的别太小，容易出现资源丢失</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-编辑器扩展功能</title>
      <link href="/2023/06/27/Doc/WooAsset/9-WooAsset-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/06/27/Doc/WooAsset/9-WooAsset-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟资源服务器"><a href="#模拟资源服务器" class="headerlink" title="模拟资源服务器"></a>模拟资源服务器</h2><p><img src="/../../../Pic/Doc/WooAsset/%E6%A8%A1%E6%8B%9F%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="Alt text"></p><ul><li><p>使用场景</p></li><li><p>省的每次都上传到远端</p></li><li><p>配合资源加载情况窗口一起观察资源加载情况</p></li><li><p>使用方法</p></li><li><p>设置好 Enable Server ，Server Directory ，Server Port</p></li><li><p>编辑器进入运行模式会自动开启资源服务器，console窗口有输出</p></li><li><p>注意</p></li><li><p>Server Directory ，Server Port 一般情况默认即可</p></li><li><p>资源服务器只会在运行状态且NormalMode状态下打开</p></li><li><p>如果资源服务器的配置不为空，在打包资源的时候会把输出文件拷贝过去</p></li></ul><h2 id="资源加载情况"><a href="#资源加载情况" class="headerlink" title="资源加载情况"></a>资源加载情况</h2><p><img src="/../../../Pic/Doc/WooAsset/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5.png" alt="Alt text"></p><ul><li>资源加载实践</li><li>当前有多少引用</li><li>资源的标签</li><li>资源所属的 bundle</li><li>支持快速搜索</li></ul><h2 id="收集资源预览"><a href="#收集资源预览" class="headerlink" title="收集资源预览"></a>收集资源预览</h2><p><img src="/../../../Pic/Doc/WooAsset/%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86%E6%83%85%E5%86%B5.png" alt="Alt text"></p><ul><li>如果不是打包，会收集所有的buildGroup</li><li>可以方便的看到究竟打包了什么内容</li><li>双击资源可以定位</li><li>支持快速搜索</li><li>可以查看资源依赖情况</li></ul><h2 id="构建-Bundle-预览"><a href="#构建-Bundle-预览" class="headerlink" title="构建 Bundle 预览"></a>构建 Bundle 预览</h2><p><img src="/../../../Pic/Doc/WooAsset/%E6%89%93%E5%8C%85%E9%A2%84%E8%A7%88.png" alt="Alt text"></p><ul><li>如果不是打包，会收集所有的buildGroup</li><li>可以预览所有的assetBundle</li><li>可以查看每一个资源的依赖</li><li>可以查看每一个bundle的依赖</li><li>双击资源可以定位</li><li>支持快速搜索</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片过渡</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E8%BF%87%E6%B8%A1/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E8%BF%87%E6%B8%A1/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;Hidden/UI/Default (UITransition)&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        [Header(Transition)]        _TransitionTex (&quot;Transition Texture (A)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _ParamTex (&quot;Parameter Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #define REVERSE 1            #define ADD 1            #pragma multi_compile __ UNITY_UI_ALPHACLIP            #pragma multi_compile __ FADE CUTOFF DISSOLVE            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #define UI_TRANSITION 1            #include &quot;UIEffect.cginc&quot;            #include &quot;UIEffectSprite.cginc&quot;            fixed4 frag(v2f IN) : SV_Target            &#123;                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd);                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                color = ApplyTransitionEffect(color, IN.eParam) * IN.color;                #if UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片溶解</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E6%BA%B6%E8%A7%A3/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E6%BA%B6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;Hidden/UI/Default (UIDissolve)&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        [Header(Dissolve)]        _TransitionTex (&quot;Transition Texture (A)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _ParamTex (&quot;Parameter Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #define DISSOLVE 1            #pragma multi_compile __ UNITY_UI_ALPHACLIP            #pragma multi_compile __ ADD SUBTRACT FILL            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #define UI_DISSOLVE 1            #include &quot;UIEffect.cginc&quot;            #include &quot;UIEffectSprite.cginc&quot;            fixed4 frag(v2f IN) : SV_Target            &#123;                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                // Dissolve                color = ApplyTransitionEffect(color, IN.eParam);                #ifdef UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片交叉移动</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E4%BA%A4%E5%8F%89%E7%A7%BB%E5%8A%A8/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E4%BA%A4%E5%8F%89%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;UIEffect/UV Cross&quot;&#123;    Properties    &#123;      [PerRendererData]  _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Vector(&quot;Count And Move&quot;,Vector)=(1,1,1,1)    _xOffset(&quot;xOffset&quot;,float)=10    //_yOffset(&quot;_yOffset&quot;,float)=10    _Rotate(&quot;Rotate&quot;,float)=10    _Scale(&quot;Scale&quot;,float)=1    &#125;    SubShader    &#123;        // No culling or depth        Cull Off ZWrite Off ZTest Always        Blend SrcAlpha OneMinusSrcAlpha        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;UnityCG.cginc&quot;            struct appdata            &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;float4 color:COLOR;            &#125;;            struct v2f            &#123;                float2 uv : TEXCOORD0;                float4 vertex : SV_POSITION;float4 color:COLOR;            &#125;;            v2f vert (appdata v)            &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                o.uv = v.uv;o.color=v.color;                return o;            &#125;            sampler2D _MainTex;            float4 _Vector;float _xOffset;//float _yOffset;float _Rotate;float _Scale;            fixed4 frag (v2f i) : SV_Target            &#123;                float2 count=_Vector.xy;i.uv=i.uv-0.5;                float2 uv=i.uv*count* ((sin(_Time.x*_Scale)+1)/2+1);                float2 finalUV = uv;float angle=_Rotate*_Time.x;                finalUV.x = uv.x * cos(angle) - uv.y * sin(angle);                finalUV.y = uv.x * sin(angle) + uv.y * cos(angle);                finalUV += float2(0.5f, 0.5f);                uv=finalUV;                uv.y+=_Time.x*_Vector.w;                uv.x+=_Time.x*_Vector.z*(((floor(uv.y)%2)-0.5)*2);                uv.x+=(floor(uv.y)%2)*_xOffset;                //uv.y+=(floor(uv.x)%2)*_yOffset;                fixed4 col = tex2D(_MainTex, uv);//return fixed4(1,1,1,1);                return col*i.color;            &#125;            ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片闪亮</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E9%97%AA%E4%BA%AE/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E9%97%AA%E4%BA%AE/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;Hidden/UI/Default (UIShiny)&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        _ParamTex (&quot;Parameter Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #pragma multi_compile __ UNITY_UI_ALPHACLIP            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #define UI_SHINY 1            #include &quot;UIEffect.cginc&quot;            #include &quot;UIEffectSprite.cginc&quot;            fixed4 frag(v2f IN) : SV_Target            &#123;                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                color = ApplyShinyEffect(color, IN.eParam);                #ifdef UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片置灰</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E7%BD%AE%E7%81%B0/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E7%BD%AE%E7%81%B0/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;UI/ImageGrey&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex(&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color(&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp(&quot;Stencil Comparison&quot;, Float) = 8        _Stencil(&quot;Stencil ID&quot;, Float) = 0        _StencilOp(&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask(&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask(&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask(&quot;Color Mask&quot;, Float) = 15        _Gray(&quot;Gray&quot;,Range(0,1)) = 0    &#125;        SubShader        &#123;            Tags            &#123;                &quot;Queue&quot; = &quot;Transparent&quot;                &quot;IgnoreProjector&quot; = &quot;True&quot;                &quot;RenderType&quot; = &quot;Transparent&quot;                &quot;PreviewType&quot; = &quot;Plane&quot;                &quot;CanUseSpriteAtlas&quot; = &quot;True&quot;            &#125;            Stencil            &#123;                Ref[_Stencil]                Comp[_StencilComp]                Pass[_StencilOp]                ReadMask[_StencilReadMask]                WriteMask[_StencilWriteMask]            &#125;            Cull back            Lighting Off            ZWrite Off            ZTest[unity_GUIZTestMode]            Blend SrcAlpha OneMinusSrcAlpha            ColorMask[_ColorMask]            Pass            &#123;                CGPROGRAM                #pragma vertex vert                #pragma fragment frag                #include &quot;UnityCG.cginc&quot;                #include &quot;UnityUI.cginc&quot;                #pragma multi_compile_local _ UNITY_UI_CLIP_RECT                struct appdata_t                &#123;                    float4 vertex   : POSITION;                    float4 color    : COLOR;                    float2 texcoord : TEXCOORD0;                &#125;;                struct v2f                &#123;                    float4 vertex   : SV_POSITION;                    fixed4 color : COLOR;                    half2 texcoord  : TEXCOORD0;                    float4 worldPosition : TEXCOORD1;                &#125;;                fixed4 _Color;                v2f vert(appdata_t IN)                &#123;                    v2f OUT;                    OUT.worldPosition = IN.vertex;                    OUT.vertex = UnityObjectToClipPos(IN.vertex);                    OUT.texcoord = IN.texcoord;                    #ifdef UNITY_HALF_TEXEL_OFFSET                        OUT.vertex.xy += (_ScreenParams.zw - 1.0) * float2(-1,1);                    #endif                    OUT.color = IN.color * _Color;                    return OUT;                &#125;                sampler2D _MainTex;                fixed _Gray;                float4 _ClipRect;                fixed4 frag(v2f IN) : SV_Target                &#123;                    half4 color = tex2D(_MainTex, IN.texcoord) * IN.color;                    clip(color.a - 0.01);                    if (_Gray &gt; 0) &#123;                        fixed gray = dot(color.rgb, fixed3(0.299, 0.587, 0.114));                        color.rgb = lerp(color.rgb,fixed3(gray, gray, gray),_Gray);                    &#125;                    #ifdef UNITY_UI_CLIP_RECT                        color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                    #endif                    return color;                &#125;                ENDCG            &#125;        &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过github 发布package</title>
      <link href="/2023/06/18/Unity/UPM/UPM/"/>
      <url>/2023/06/18/Unity/UPM/UPM/</url>
      
        <content type="html"><![CDATA[<h3 id="发布自己的包"><a href="#发布自己的包" class="headerlink" title="发布自己的包"></a>发布自己的包</h3><ul><li>1、创建一个正常的unity项目</li><li>2、在Assets 目录下 创建好内容（必须包含内容如下图）</li><li>3、把做好的内容推送到主分支</li><li>4、<code>git subtree split --prefix=Assets/xxx --branch upm</code></li><li>5、推送 upm 分支到github（<code>git push origin upm:upm</code>）</li><li>6、<code>git tag 1.0.0 upm</code></li><li>7、<code>git push origin upm --tags</code></li></ul><p>后续修改只需要重复执行3-7即可</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>打开unity package manager</li><li>点击 add package form git</li><li>填写 <a href="https://github.com/OnClick9927/NodeGraph.git#1.0.1">https://github.com/OnClick9927/NodeGraph.git#1.0.1</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>删除远程tag git push origin :refs&#x2F;tags&#x2F;标签名  </li><li>删除本地 tag git tag -d 标签名</li></ul><p><img src="/../../../Pic/Unity/UPM/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-接口及其他定义的说明</title>
      <link href="/2023/06/09/Doc/WooPool/WooPool-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/06/09/Doc/WooPool/WooPool-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="IObjectPool"><a href="#IObjectPool" class="headerlink" title="IObjectPool"></a>IObjectPool</h2><p>定义了对象池的<strong>对象数量</strong>、<strong>对象类型</strong>和<strong>回收方法</strong></p><pre><code class="csharp">public interface IObjectPool:IDisposable</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>获取当前对象池里对象的个数</td></tr><tr><td>type</td><td>获取当前对象池中对应对象的对象类型</td></tr></tbody></table><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Set(object,IPoolArgs)</td><td>将对象回收，也就是将对象放回到对象池中<br />回收成功时返回<code>true</code>，失败时返回<code>false</code></td></tr></tbody></table><h2 id="IPoolObject"><a href="#IPoolObject" class="headerlink" title="IPoolObject"></a>IPoolObject</h2><p>定义了对象池对象的生命周期的三个阶段</p><pre><code class="csharp">public interface IPoolObject : IDisposable</code></pre><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>OnAllocate()</td><td>在对象被创建时调用</td></tr><tr><td>OnGet()</td><td>在对象从对象池中被取出时调用</td></tr><tr><td>OnSet()</td><td>在对象被回收回对象池时调用</td></tr></tbody></table><h2 id="IPoolArgs"><a href="#IPoolArgs" class="headerlink" title="IPoolArgs"></a>IPoolArgs</h2><p>此接口用于抽象构造的参数</p><pre><code class="csharp">public interface IPoolArgs</code></pre><h2 id="PoolUnit"><a href="#PoolUnit" class="headerlink" title="PoolUnit"></a>PoolUnit</h2><p>定义对象池的销毁状态和销毁方法</p><pre><code class="csharp">public abstract class PoolUnit : IDisposable</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>disposed</td><td>当前对象池是否被销毁</td></tr></tbody></table><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>OnDispose()</td><td>在对象池被销毁时调用</td></tr><tr><td>Dispose()</td><td>销毁对象池</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-全局对象池</title>
      <link href="/2023/06/08/Doc/WooPool/WooPool-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/08/Doc/WooPool/WooPool-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>全局的对象池，不用考虑创建对象池，不用考虑对象的类型，即拿即用，用完归还。</p><ul><li>全局对象池操作使用PoolEx类</li><li><em><strong>注意回收时要自己初始化数据！！！</strong></em></li></ul><pre><code class="csharp">public static class PoolEx</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>GetGlbalPoolCount&lt;T&gt;()</td><td>public</td><td>从对象池中获取对应类型的数组对象</td></tr><tr><td>SetGlbalPool&lt;T&gt;(ObjectPool&lt;T&gt;)</td><td>public</td><td>将数组对象放回对象池</td></tr><tr><td>GlobalAllocate&lt;T&gt;(IPoolArgs)</td><td>public</td><td>全局分配对应类型的对象</td></tr><tr><td>GlobalAllocate(Type,IPoolArgs)</td><td>public</td><td>全局分配对应类型的对象</td></tr><tr><td>GlobalRecyle&lt;T&gt;(T,IPoolArgs)</td><td>public</td><td>全局回收</td></tr><tr><td>GlobalAllocateArray&lt;T&gt;(int)</td><td>public</td><td>获取对应类型和长度的数组对象</td></tr></tbody></table><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code class="csharp">//全局对象池示例void GlobalPoolExample() &#123;    //全局获取一个对象    var human = PoolEx.GlobalAllocate&lt;Human&gt;();    //全局回收一个对象    PoolEx.GlobalRecyle(human);    //从全局对象池中获取一个长度为10的数组对象    var arr = PoolEx.GlobalAllocateArray&lt;Human&gt;(10);    //Human类的定义在第一个示例    arr[0] = new Human(33, &quot;吉良吉影&quot;);    arr[0].Say();    //回收掉这个数组对象    PoolEx.GlobalRecyle(arr);    //重新从全局对象池中获取长度为10的数组对象    arr = PoolEx.GlobalAllocateArray&lt;Human&gt;(10);    arr[0].Say();    PoolEx.GlobalRecyle(arr);    //可以发现是和原先同样的对象    //因此回收的时候需要注意初始化数据！！！！&#125;//示例所需的类public class Human&#123;    public readonly int age;    public readonly string name;    public Human(int age, string name)    &#123;        this.age = age;        this.name = name;    &#125;    public Human()     &#123;        age= 0;        name = &quot;无名&quot;;    &#125;    public void Say()    &#123;        Console.WriteLine($&quot;我的名字叫&#123;name&#125;,&#123;age&#125;岁&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-基类对象池</title>
      <link href="/2023/06/07/Doc/WooPool/WooPool-%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/07/Doc/WooPool/WooPool-%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设置一个基类，可以从这个对象池中拿出继承这个基类的对象</p><pre><code class="csharp">public abstract class BaseTypePool&lt;T&gt; : PoolUnit</code></pre><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>基类对象池的本质是一个Key为 类型，Value为 对应类型对象池 的字典。获取对象时，根据类型找到对应的对象池，并从对应的对象池中获取对象。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>注：下面的<code>Object</code>类型是泛型类型，为了区分基类的泛型<code>T</code></p><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>SetPool&lt;Object&gt;(ObjectPool&lt;Object&gt;)</td><td>public</td><td>将对象池放入基类对象池中</td></tr><tr><td>SetPool(Type, IObjectPool)</td><td>public</td><td>将对应类型的对象池放入基类对象池中</td></tr><tr><td>GetPool&lt;Object&gt;()</td><td>public</td><td>根据类型获取对象池</td></tr><tr><td>GetPool(Type)</td><td>public</td><td>根据类型获取对象池</td></tr><tr><td>CreatePool(Type)</td><td>protected virtual</td><td>创建对象池</td></tr><tr><td>Get&lt;Object&gt;(IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的对象</td></tr><tr><td>Get(Type,IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的对象</td></tr><tr><td>Set&lt;Object&gt;(Object,IPoolArgs)</td><td>public</td><td>将对应类型的对象放回对象池</td></tr><tr><td>Set(Type,T,IPoolArgs)</td><td>public</td><td>将对应类型的对象放回对象池</td></tr><tr><td>GetPoolCount&lt;Object&gt;()</td><td>public</td><td>获取对应类型的对象池中对象的数量</td></tr><tr><td>GetPoolCount(Type)</td><td>public</td><td>获取对应类型的对象池中对象的数量</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁基类对象池</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//定义一个叫IObject的接口public interface IObject &#123; &#125;//创建两个实现IObject接口的类public class Obj_A : IObject &#123; &#125;public class Obj_B : IObject &#123; &#125;//以IObject为基类定义一个基类对象池public class MyBaseTypePool : BaseTypePool&lt;IObject&gt; &#123; &#125;//定义一个存放Obj_A对象的对象池public class ObjectPoolA : ObjectPool&lt;Obj_A&gt;&#123;    protected override Obj_A CreateNew(IPoolArgs arg)    &#123;        return new Obj_A();    &#125;&#125;//基类对象池使用示例方法void BaseTypePoolExample()&#123;    //创建基类对象池    MyBaseTypePool pool = new MyBaseTypePool();    //从基类对象池中获取Obj_A类型的对象    IObject _obj = pool.Get&lt;Obj_A&gt;();    //将对象放回    pool.Set(_obj);    //从基类对象池中获取Obj_B类型的对象    _obj = pool.Get(typeof(Obj_B));    //将对象放回    pool.Set(_obj);    //从基类对象池中获取Obj_A类型的对象池    ObjectPool&lt;Obj_A&gt; objPoolA = pool.GetPool&lt;Obj_A&gt;();    //也可使用如下方法    //ObjectPool&lt;Obj_A&gt; objPoolA = (ObjectPool&lt;Obj_A&gt;)pool.GetPool(typeof(Obj_A));    //创建一个Obj_A的对象池，替换基类对象池中的对应对象池    pool.SetPool(new ObjectPoolA());&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-数组对象池</title>
      <link href="/2023/06/06/Doc/WooPool/WooPool-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/06/Doc/WooPool/WooPool-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>能拿出数组对象的对象池</p><pre><code class="csharp">public class ArrayPool&lt;T&gt; : ObjectPool&lt;T[]&gt;</code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>参数ArrayPoolArg用于传入数组长度</p><pre><code class="csharp">public struct ArrayPoolArg : IPoolArgs</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>数组长度</td></tr></tbody></table><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="csharp">public ArrayPoolArg(int length)</code></pre><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>int</td><td>用于参数构造时传入数组长度</td></tr></tbody></table><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>Get(IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的数组对象</td></tr><tr><td>Set(T[],IPoolArgs)</td><td>public</td><td>将数组对象放回对象池</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁基类对象池</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">void ArrayPoolExample()&#123;    //创建数组对象池，示例使用存放int值的数组    var pool = new ArrayPool&lt;int&gt;();    //从数组对象池中拿出一个长度为2的数组    var objA = pool.Get(new ArrayPoolArg(2));    Console.WriteLine(&quot;取出的数组长度为&quot;+objA.Length);    //将数组中的第一个元素设置成1    objA[0] = 1;    //将数组回收，再拿出一个长度为2的数组    pool.Set(objA);    objA = pool.Get(new ArrayPoolArg(2));    //打印第一个元素    Console.WriteLine(&quot;数组的第一个元素的值为：&quot;+ objA[0]);    //因此需要注意放回数组时 根据自己需求判断是否需要重置一下数组&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-Activator构建对象池</title>
      <link href="/2023/06/05/Doc/WooPool/WooPool-Activator%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/05/Doc/WooPool/WooPool-Activator%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用Activator自动构建对象的对象池，支持传入对象创建时所需的参数</p><pre><code class="csharp">public class ActivatorCreatePool&lt;T&gt; : ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">public ActivatorCreatePool(params object[] args)</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>args</code></td><td>object[]</td><td>用于对象构造时所需的参数</td></tr></tbody></table><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>获取当前对象池里对象的个数（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>type</td><td>获取当前对象池中对应对象的对象类型（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>disposed</td><td>当前对象池是否被销毁（继承自 PoolUnit）</td></tr></tbody></table><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Get()</td><td>从对象池中获取对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Set(T)</td><td>将对象回收到对象池中（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Clear()</td><td>清空对象池中的所有对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Clear(int)</td><td>清除对象池里一定数量的对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Dispose()</td><td>销毁对象池（继承自 PoolUnit）</td></tr></tbody></table><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code class="csharp">/// &lt;summary&gt;/// 示例将会用到的示例类型，构造函数不含参数/// &lt;/summary&gt;public class Bottle &#123; &#125;/// &lt;summary&gt;/// 示例将会用到的示例类型，构造函数包含age和name两个参数/// &lt;/summary&gt;public class Human&#123;    public readonly int age;    public readonly string name;    public Human(int age, string name)    &#123;        this.age = age;        this.name = name;    &#125;    public void Say()    &#123;        Console.WriteLine($&quot;我的名字叫&#123;name&#125;,&#123;age&#125;岁&quot;);    &#125;&#125;/// &lt;summary&gt;/// ActivatorPool的使用示例/// &lt;/summary&gt;private void ActivatorPoolExample()&#123;    //创建一个存放Bottle的对象池    ActivatorCreatePool&lt;Bottle&gt; pool = new ActivatorCreatePool&lt;Bottle&gt;();        //从对象池中获取一个对象    var bottle = pool.Get();        //用对象池的Set方法将对象放回对象池    pool.Set(bottle);        //创建一个能够根据参数创建对象的对象池    //此处以Human类为例，传入age和name    ActivatorCreatePool&lt;Human&gt; humanPool = new ActivatorCreatePool&lt;Human&gt;(33, &quot;吉良吉影&quot;);    var human = humanPool.Get();    //调用对象的Say方法    human.Say();    //输出内容为 我的名字叫吉良吉影,33岁&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-委托对象池</title>
      <link href="/2023/06/04/Doc/WooPool/WooPool-%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/04/Doc/WooPool/WooPool-%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用委托创建对象的对象池，用于在CreateNew()中调用,方便外部动态修改创建对象的方法</p><pre><code class="csharp">public abstract class DelegatePool&lt;T&gt; : ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">public DelegatePool(Func&lt;T&gt; create)</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>create</td><td>Func&lt;T&gt;</td><td>创建对象的委托</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//用于示例的类型public class Obj_A &#123; &#125;//定义一个存放Obj_A对象的委托对象池public class DelegatePoolA : DelegatePool&lt;Obj_A&gt;&#123;    public DelegatePoolA(Func&lt;Obj_A&gt; create) : base(create)    &#123;    &#125;&#125;//创建Obj_A对象的方法Obj_A CreateObject()&#123;    Console.WriteLine(&quot;我创建了一个对象，哈哈哈哈哈哈！&quot;);    return new Obj_A();&#125;void DelegatePoolExample()&#123;    //创建委托对象池    var pool = new DelegatePoolA(CreateObject);    //获取一个对象，内部创建新对象时会调用方法    var objA = pool.Get();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-有容量的对象池</title>
      <link href="/2023/06/03/Doc/WooPool/WooPool-%E6%9C%89%E5%AE%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/03/Doc/WooPool/WooPool-%E6%9C%89%E5%AE%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>限制容量大小的对象池</p><pre><code class="csharp">public abstract class CapacityPool&lt;T&gt;: ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">protected CapacityPool(int capacity) : base() &#123; this._capacity = capacity; &#125;</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>capacity</td><td>int</td><td>对象池的最大容量</td></tr></tbody></table><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>capacity</td><td>对象池的最大容量，创建后可重新修改</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//用于示例的类型public class Obj_A &#123; &#125;//定义一个存放Obj_A对象的对象池public class CapacityPoolA : CapacityPool&lt;Obj_A&gt;&#123;    public CapacityPoolA(int capacity) : base(capacity)    &#123;    &#125;    protected override Obj_A CreateNew(IPoolArgs arg)    &#123;        return new Obj_A();    &#125;&#125;//限制大小对象池的示例void CapacityPoolExample()&#123;    //创建对象池，设置大小为1    var pool = new CapacityPoolA(1);    //放入一个对象，不会报错    Console.WriteLine(&quot;回收第一个对象，结果为：&quot; + pool.Set(new Obj_A()));    //再放入一个对象，会发现存放失败    Console.WriteLine(&quot;回收第二个对象，结果为：&quot; + pool.Set(new Obj_A()));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-基本定义</title>
      <link href="/2023/06/02/Doc/WooPool/WooPool-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/06/02/Doc/WooPool/WooPool-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对象池的基本定义，包括基本属性、基本方法、生命周期</p><pre><code class="csharp">public abstract class ObjectPool&lt;T&gt; : PoolUnit, IDisposable, IObjectPool</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>public</td><td>获取当前对象池里对象的个数</td></tr><tr><td>type</td><td>public</td><td>获取当前对象池中对应对象的对象类型</td></tr><tr><td>pool</td><td>protected</td><td>对象池的数据容器，默认是队列</td></tr><tr><td>para</td><td>protected</td><td>锁</td></tr></tbody></table><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>Get(IPoolArgs)</td><td>public virtual</td><td>从对象池中获取对象</td></tr><tr><td>Set(object,IPoolArgs)</td><td>public</td><td>将对象回收到对象池中，回收成功时返回true，失败时返回false</td></tr><tr><td>Set(T,IPoolArgs)</td><td>public virtual</td><td>将对象回收到对象池中，回收成功时返回true，失败时返回false</td></tr><tr><td>RealSet(T,IPoolArgs)</td><td>protected</td><td>对象回收的实际方法，上面两个只是用于调用的</td></tr><tr><td>Clear(IPoolArgs)</td><td>public</td><td>清空对象池中的所有对象</td></tr><tr><td>Clear(int,IPoolArgs)</td><td>public</td><td>清除对象池里一定数量的对象</td></tr><tr><td>CreateNew(IPoolArgs )</td><td>protected abstract</td><td>创建对象的方法，需要子类实现</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁对象池（继承自 PoolUnit）</td></tr></tbody></table><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>需要在对应周期增加操作时可以重写对应的方法</p><table><thead><tr><th>生命周期名</th><th>说明</th></tr></thead><tbody><tr><td>OnCreate(T, IPoolArgs)</td><td>对象池创建对象时调用</td></tr><tr><td>OnGet(T, IPoolArgs)</td><td>对象池中的对象被获取时调用</td></tr><tr><td>OnSet(T, IPoolArgs)</td><td>对象被回收时调用，返回false时表示不能回收</td></tr><tr><td>OnClear(T, IPoolArgs)</td><td>对象池中的对象被清除时调用</td></tr><tr><td>OnDispose()</td><td>对象池被销毁时调用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-简介</title>
      <link href="/2023/06/01/Doc/WooPool/WooPool-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/06/01/Doc/WooPool/WooPool-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h4 id="为什么要使用对象池？"><a href="#为什么要使用对象池？" class="headerlink" title="为什么要使用对象池？"></a>为什么要使用对象池？</h4><p>对象在生成和销毁时都是需要一定开销的，如果某个类型频繁地生成对象和销毁对象，会导致开销过大，影响性能。</p><p>举个例子：</p><ol><li><p>我们厨房里的碗架（对象池），容纳着很多个碗（对象）。</p></li><li><p>我们在盛饭的时候，从碗架里拿出一个碗（从对象池中拿出一个对象）。</p></li><li><p>在吃完饭之后，洗碗（对象的初始化）、放回碗架（将对象回收，放回到对象池中）。</p></li></ol><p>上述例子中，如果不使用对象池，也就意味着碗是一次性的，也就是吃完就把碗摔了，然后要用的时候再花钱买个新的碗，这样的做法很明显是特别烧钱（浪费资源）的。</p><h4 id="WooPool特点"><a href="#WooPool特点" class="headerlink" title="WooPool特点"></a>WooPool特点</h4><ul><li><p>支持传入参数构建对象</p></li><li><p>支持对象池创建对象时调用委托</p></li><li><p>支持限定对象池大小</p></li><li><p>支持从基类对象池中取出子类</p></li><li><p>支持数组对象池</p></li><li><p>支持操作非常简单的全局对象池</p></li><li><p>支持多个生命周期</p></li><li><p>支持自己扩展对象池</p></li></ul><h3 id="感谢使用WooPool！"><a href="#感谢使用WooPool！" class="headerlink" title="感谢使用WooPool！"></a>感谢使用WooPool！</h3><h3 id="欢迎加入QQ交流群782290296，各路大佬给你解惑！"><a href="#欢迎加入QQ交流群782290296，各路大佬给你解惑！" class="headerlink" title="欢迎加入QQ交流群782290296，各路大佬给你解惑！"></a>欢迎加入QQ交流群<a href="https://jq.qq.com/?_wv=1027&k=sbKbmsTY">782290296</a>，各路大佬给你解惑！</h3>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat 安装教程</title>
      <link href="/2023/05/23/DB/Navicat/"/>
      <url>/2023/05/23/DB/Navicat/</url>
      
        <content type="html"><![CDATA[<h2 id="Navicat-安装教程-下载"><a href="#Navicat-安装教程-下载" class="headerlink" title="Navicat 安装教程 下载"></a>Navicat 安装教程 <a href="https://wwqq.lanzouf.com/iszHt0x1hikf">下载</a></h2><p>1、正常安装（装完不要打开）<br>2、断网<br>3、右键NavicatCracker.exe以管理员身份运行。<br>4、选择刚刚的安装目录，点击Patch<br>5、点击是<br>6、打开注册软件.点击Generate生成注册码.再点击copy.<br>7、打开Navicat16,点击注册<br>8、粘贴刚刚生成的注册码,点击激活.<br>9、点击手动激活<br>10、复制下图中生成的请求码<br>11、将 Navicat 给的请求码复制到注册机 Request Code 中<br>12、点击 Generate Activation Code进行激活.复制激活码.<br>13、然后粘贴激活码.点击激活即可.</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> DB </tag>
            
            <tag> Navicat 安装教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-简介</title>
      <link href="/2023/05/22/Doc/WooTween/WooTween-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/05/22/Doc/WooTween/WooTween-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="内容组成"><a href="#内容组成" class="headerlink" title="内容组成"></a>内容组成</h2><p>  0、对象池           默默无闻的螺丝钉<br>  1、驱动器           好司机<br>  2、转换器           翻译官<br>  3、TweenValue      单程车<br>  4、Tween           花样百出的乘客<br>  5、Component       好保姆</p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
            <tag> 简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-简介</title>
      <link href="/2023/05/19/Doc/WooAsset/0-WooAsset-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/05/19/Doc/WooAsset/0-WooAsset-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a><a href="https://github.com/OnClick9927/WooAsset">地址</a></h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>WooAsset可以满足以下任何需求：</p><ul><li>我想发布一个不包含任何游戏资源的安装包，然后玩家边玩边下载。</li><li>我想发布一个可以保证前期体验的安装包，然后玩家自己选择下载关卡内容。</li><li>我想发布一个保证300MB以下内容的安装包，然后进入游戏之前把剩余内容下载完毕。</li><li>我想发布一个偏单机的游戏安装包，在网络畅通的时候，支持正常更新。在没有网络的时候，支持游玩老版本。</li><li>我想发布一个MOD游戏安装包，玩家可以把自己制作的MOD内容上传到服务器，其它玩家可以下载游玩。</li><li>我们在制作一个超大体量的项目，有上百GB的资源内容，每次构建都花费大量时间，是否可以分工程构建？</li></ul><h2 id="系统特点"><a href="#系统特点" class="headerlink" title="系统特点"></a>系统特点</h2><ul><li>Editor、Runtime均支持同步、异步、委托、携程</li><li>支持各个模式切换（无需修改代码）</li><li>支持自定义资源加密</li><li>支持分布式构建(支持mod)</li><li>支持 shader 变体收集</li><li>支持 构建 spriteAtlas</li><li>支持打包&#x2F;加载Unity无法识别的文件</li><li>支持打包流程自定义（自定义分包、版本规划、结束流程、自定义标签）</li><li>包含本地资源服务器</li><li>支持快速版本切换，回退</li><li>支持资源模糊搜索</li><li>支持自定义下载器</li><li>支持子资源加载</li><li>支持资源懒卸载&#x2F;内存大小控制</li><li>支持WebGL</li><li>支持加载Resources文件夹内容</li></ul><h2 id="支持的模式"><a href="#支持的模式" class="headerlink" title="支持的模式"></a>支持的模式</h2><p>各个模式切换无需修改代码</p><ul><li>0 编辑器模拟加载         (纯粹编辑器模拟)</li><li>1 纯粹的C#空包，   （注意：本地不会有任何ab）</li><li>2 发布 正常流程包       （比模式1 多一个版本检查）</li><li>3 发布 游戏前期的体验包  (把资源拷贝到stream)</li><li>4 边玩边下载</li><li>5 先准备一部分，后续靠下载</li></ul><h3 id="模式区别"><a href="#模式区别" class="headerlink" title="模式区别"></a>模式区别</h3><table><tr><th></th><th>模式/流程</th><th>编辑器模拟</th><th>纯C#空包</th><th>正常流程</th><th>前期的体验</th><th>边玩边下载</th><th>先准备一部分</th></tr><tr ><td rowspan="5">打包</td></tr><tr><th>选择FastMode        </th><th>✔</th><th> </th><th> </th><th> </th><th> </th><th> </th></tr><tr><th>打包资源            </th><th>  </th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th></tr><tr><th>拷贝资源到stream     </th><th>  </th><th> </th><th> </th><th>✔</th><th> </th><th>按tag拷贝</th></tr><tr><th>上传资源到服务器     </th><th>  </th><th>✔</th><th>✔</th><th> </th><th>✔</th><th>✔</th></tr><tr ><td rowspan="7">加载</td></tr><tr><th>设置AssetsSetting   </th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th></tr><tr><th>拷贝资源到沙盒路径   </th><th> </th><th> </th><th> </th><th>✔</th><th> </th><th>✔</th></tr><tr><th>版本检查            </th><th> </th><th> </th><th>✔</th><th> </th><th>可选</th><th>可选</th></tr><tr><th>下载变化资源        </th><th> </th><th> </th><th>✔</th><th> </th><th> </th><th>可选</th></tr><tr><th>初始化              </th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th></tr><tr><th>正常加载            </th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th></tr></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊-毛玻璃</title>
      <link href="/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/"/>
      <url>/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../../Pic/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83.png" alt="效果"></p><pre><code class="cg">Shader &quot;UI/UiObscure&quot;&#123;    Properties    &#123;        _Radius(&quot;Radius&quot;, Range(1, 255)) = 1        _MainTex(&quot;Tint Color (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Interval(&quot;Blur Nuance&quot;,Range(0.1, 100)) = 1        [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)] _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        [HideInInspector] _Stencil (&quot;Stencil ID&quot;, Float) = 0        [HideInInspector][Enum(UnityEngine.Rendering.StencilOp)] _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        [HideInInspector] _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        [HideInInspector] _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        [HideInInspector] _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        // Outline properties are drawn via custom editor.        [HideInInspector] _OutlineWidth(&quot;Outline Width&quot;, Range(0,8)) = 3.0        [HideInInspector] _OutlineColor(&quot;Outline Color&quot;, Color) = (1,1,0,1)        [HideInInspector] _OutlineReferenceTexWidth(&quot;Reference Texture Width&quot;, Int) = 1024        [HideInInspector] _ThresholdEnd(&quot;Outline Threshold&quot;, Range(0,1)) = 0.25        [HideInInspector] _OutlineSmoothness(&quot;Outline Smoothness&quot;, Range(0,1)) = 1.0        [HideInInspector][MaterialToggle(_USE8NEIGHBOURHOOD_ON)] _Use8Neighbourhood(&quot;Sample 8 Neighbours&quot;, Float) = 1        [HideInInspector] _OutlineMipLevel(&quot;Outline Mip Level&quot;, Range(0,3)) = 0    &#125;     Category    &#123;        Tags&#123; &quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;         SubShader        &#123;                     Stencil            &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]            &#125;                        Cull Off            Lighting Off            ZWrite Off            ZTest [unity_GUIZTestMode]            Fog &#123; Mode Off &#125;            Blend One OneMinusSrcAlpha            ColorMask [_ColorMask]                    GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM                #pragma vertex vert                #pragma fragment frag                #pragma fragmentoption ARB_precision_hint_fastest                #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                    v2f o;                    o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                    float scale = -1.0;                    #else                    float scale = 1.0;                    #endif                    o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                    o.uvgrab.zw = o.vertex.zw;                    return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                float _Interval;                half4 frag(v2f i) : COLOR                &#123;                    half4 sum = half4(0,0,0,0);                                 #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                                 sum += GRABXYPIXEL(0.0, 0.0);                    int measurments = 1;                                 for (float range = _Interval; range &lt;= _Radius; range += _Interval)                    &#123;                        sum += GRABXYPIXEL(range, range);                        sum += GRABXYPIXEL(range, -range);                        sum += GRABXYPIXEL(-range, range);                        sum += GRABXYPIXEL(-range, -range);                        measurments += 4;                    &#125;                    return sum / measurments;                &#125;            ENDCG            &#125;        GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma fragmentoption ARB_precision_hint_fastest            #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                float scale = -1.0;                    #else                float scale = 1.0;                    #endif                o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                o.uvgrab.zw = o.vertex.zw;                return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                    half4 frag(v2f i) : COLOR                &#123;                            half4 sum = half4(0,0,0,0);                float radius = 1.41421356237 * _Radius;                                #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                            sum += GRABXYPIXEL(0.0, 0.0);                int measurments = 1;                            for (float range = 1.41421356237f; range &lt;= radius * 1.41; range += 1.41421356237f)                &#123;                sum += GRABXYPIXEL(range, 0);                sum += GRABXYPIXEL(-range, 0);                sum += GRABXYPIXEL(0, range);                sum += GRABXYPIXEL(0, -range);                measurments += 4;                &#125;                            return sum / measurments;                &#125;            ENDCG            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书写方式</title>
      <link href="/2023/05/15/README/"/>
      <url>/2023/05/15/README/</url>
      
        <content type="html"><![CDATA[<h2 id="sadasda"><a href="#sadasda" class="headerlink" title="sadasda"></a>sadasda</h2><h4 id="57d8a"><a href="#57d8a" class="headerlink" title="57d8a"></a>57d8a</h4><ul><li>哈哈哈</li><li>康康康<ul><li>777</li><li>888</li></ul></li><li>999</li></ul><pre><code class="csharp">public class A&#123;    public void DO()&#123;&#125;&#125;</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><img src="/../Pic/R-C.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
