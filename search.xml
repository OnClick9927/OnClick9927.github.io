<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1-WooLocalization-简介</title>
      <link href="/2024/10/26/Doc/WooLocalization/1-WooLocalization-%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/10/26/Doc/WooLocalization/1-WooLocalization-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a><a href="https://github.com/OnClick9927/WooLocalization.git">地址</a></h1><h1 id="upm-添加地址"><a href="#upm-添加地址" class="headerlink" title="upm 添加地址"></a>upm 添加地址</h1><p><a href="https://github.com/OnClick9927/WooLocalization.git#upm">https://github.com/OnClick9927/WooLocalization.git#upm</a></p><h1 id="WooLocalization介绍"><a href="#WooLocalization介绍" class="headerlink" title="WooLocalization介绍"></a>WooLocalization介绍</h1><p>在这个全球化的时代，游戏和应用程序的多语言支持变得至关重要。我们的Unity本地化插件旨在帮助开发者轻松实现项目的国际化，无需深入了解复杂的本地化流程。通过我们的工具，你可以快速地将你的游戏或应用翻译成多种语言，触及全球用户。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul><li>支持 文本&#x2F;图片&#x2F;特效&#x2F;预制体&#x2F;继承自UnityEngine.Object 本地化</li><li>提供本地化组件（支持挖孔的文本，支持多种属性变化）</li><li>支持一键翻译</li><li>支持无限多语言类型</li><li>支持扩展自定义本地化</li><li>支持导入导出自定义本地化文件</li><li>支持编辑器增加&#x2F;检查&#x2F;删除&#x2F;修改 本地化 Key&#x2F;语言</li><li>支持编辑器下预览语言切换</li></ul><h1 id="为什么选择我们："><a href="#为什么选择我们：" class="headerlink" title="为什么选择我们："></a>为什么选择我们：</h1><ul><li>节省时间： 简化本地化流程，减少开发时间。</li><li>提高效率： 动态加载和一键翻译功能提高开发效率。</li><li>扩大市场： 多语言支持帮助你的产品触及更广泛的用户群体。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooLocalization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooLocalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-WooLocalization-Localization Data文件使用</title>
      <link href="/2024/10/26/Doc/WooLocalization/2-WooLocalization-Localization%20Data%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/26/Doc/WooLocalization/2-WooLocalization-Localization%20Data%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="WooLocalization-Localization-Data-是什么"><a href="#WooLocalization-Localization-Data-是什么" class="headerlink" title="WooLocalization-Localization Data 是什么"></a>WooLocalization-Localization Data 是什么</h1><p>在Unity中存储多语言数据，通常涉及到创建和管理多语言映射表，这些表用于建立不同资源之间的对应关系，确保一个key对应多个语言的资源。<br>以下是对这一过程的详细描述</p><h1 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h1><p>右键Project窗口 - Creat - Localization Data</p><h1 id="界面功能介绍"><a href="#界面功能介绍" class="headerlink" title="界面功能介绍"></a>界面功能介绍</h1><ul><li><p>Clear Data</p><ul><li>一键清除所有数据</li></ul></li><li><p>Read From Asset</p><ul><li>从Assets文件夹中读取数据</li></ul></li><li><p>Read From CSV &#x2F; Write to CSV </p><ul><li>从本地路径中读写CSV文件</li></ul></li><li><p>LanType </p><ul><li>添加所需要的语言</li></ul></li><li><p>Key</p><ul><li>用于在代码中引用对应文本的标识符</li></ul></li><li><p>VAL </p><ul><li>用于在所需语言中显示的实际文本</li></ul></li><li><p>右键data文件 可以删除所选 删除语言类型 一键翻译（下一篇会详细讲解）</p></li></ul><p><img src="/../../../Pic/Doc/WooLocalization/LocalizationData%E6%96%87%E4%BB%B6.png"></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooLocalization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooLocalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-WooLocalization-Localization Window</title>
      <link href="/2024/10/26/Doc/WooLocalization/3-WooLocalization-Localization%20Window/"/>
      <url>/2024/10/26/Doc/WooLocalization/3-WooLocalization-Localization%20Window/</url>
      
        <content type="html"><![CDATA[<h1 id="WooLocalization-Localization-Window"><a href="#WooLocalization-Localization-Window" class="headerlink" title="WooLocalization-Localization Window"></a>WooLocalization-Localization Window</h1><p>Localization的功能界面 </p><h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h1><ul><li>1.正则表达式相关内容</li><li>2.有道翻译-文本翻译 点击跳转有道界面注册登录 并申请应用获取id sercet 输入Appid 和AppSecret </li><li>3.设置Localization Data文件  设置语言映射 </li><li>4.添加TMP扩展脚本</li></ul><p><img src="/../../../Pic/Doc/WooLocalization/LocalizationWindow.png"></p><h1 id="使用有道翻译"><a href="#使用有道翻译" class="headerlink" title="使用有道翻译"></a>使用有道翻译</h1><ul><li>点击Register跳转注册 点击Code&amp;Language跳转Api接入界面 </li><li>填入Appid和AppSecret</li><li>选择Data文件右键 点击Translate 中指定语言全部翻译</li></ul><p><img src="/../../../Pic/Doc/WooLocalization/%E6%9C%89%E9%81%93api%E6%8E%A5%E5%85%A5.png"></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooLocalization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooLocalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-WooLocalization-Component</title>
      <link href="/2024/10/26/Doc/WooLocalization/4-WooLocalization-Component/"/>
      <url>/2024/10/26/Doc/WooLocalization/4-WooLocalization-Component/</url>
      
        <content type="html"><![CDATA[<h1 id="Text-x2F-TMP-组件"><a href="#Text-x2F-TMP-组件" class="headerlink" title="Text&#x2F;TMP 组件"></a>Text&#x2F;TMP 组件</h1><ul><li>Context 设置文件</li><li>Text  <ul><li>mode  <ul><li>1.Normal：无操作 </li><li>2.New Key：输入Key和Value后点击Execute可以更新 </li><li>3.Replace Value：重新修改当前key的值</li></ul></li><li>FormatArgs 添加占位符的内容</li><li>Preview 当前语言的Key与Value</li></ul></li><li>Font<ul><li>设置不同语言的字体</li></ul></li><li>FontSize <ul><li>设置不同语言的字体大小</li></ul></li><li>Color <ul><li>设置不同语言的文字颜色</li></ul></li><li>Material<ul><li>设置不同语言的材质球<br><img src="/../../../Pic/Doc/WooLocalization/Component-Text.png"></li></ul></li></ul><h1 id="Image-组件"><a href="#Image-组件" class="headerlink" title="Image 组件"></a>Image 组件</h1><ul><li>Context 设置文件</li><li>Sprite<ul><li>设置不同语言的sprite</li></ul></li><li>Color <ul><li>设置不同语言的文字颜色</li></ul></li><li>Material<ul><li>设置不同语言的材质球<br><img src="/../../../Pic/Doc/WooLocalization/Component-Image.png"></li></ul></li></ul><h1 id="Prefab-组件"><a href="#Prefab-组件" class="headerlink" title="Prefab 组件"></a>Prefab 组件</h1><ul><li>Context 设置文件</li><li>Prefab<ul><li>设置不同语言要加载的预制体</li></ul></li></ul><p><img src="/../../../Pic/Doc/WooLocalization/Component-Prefab.png"></p><h1 id="Localization-Assets-String-x2F-Game-Object-x2F-Sprite"><a href="#Localization-Assets-String-x2F-Game-Object-x2F-Sprite" class="headerlink" title="Localization Assets_String&#x2F;Game Object&#x2F;Sprite"></a>Localization Assets_String&#x2F;Game Object&#x2F;Sprite</h1><p>我们在开发的时候本地化不只处理文字内容，还会处理物体、音频、图片等其他内容<br>这个组件的作用就是相当于一个配置表，通过代码可以获取到具体的Value<br><img src="/../../../Pic/Doc/WooLocalization/Component-Assets.png"></p><pre><code class="csharp">public  LocalizationAssets_String asset;Debug.Log(asset.GetObject(&quot;key&quot;));</code></pre><ul><li>其他两个组件同理</li></ul><h1 id="如何扩展需要的组件"><a href="#如何扩展需要的组件" class="headerlink" title="如何扩展需要的组件"></a>如何扩展需要的组件</h1><pre><code class="csharp">//第一种集合 以Texture类型为例，要实现两个脚本 一个是editor脚本一个是texture类型脚本using UnityEditor;using UnityEngine;namespace WooLocalization&#123;        [CustomEditor(typeof(LocalizationAssets_Texture))]        class LocalizationAssets_TextureEditor: LocalizationAssetsEditor&lt;LocalizationAssets_Texture, Texture&gt;        &#123;        &#125;&#125;namespace WooLocalization&#123;        [UnityEngine.DisallowMultipleComponent]        public class LocalizationAssets_Texture: LocalizationAssets&lt;Texture&gt;        &#123;        &#125;&#125;</code></pre><p><img src="/../../../Pic/Doc/WooLocalization/Texture%E7%BB%84%E4%BB%B6.png"></p><pre><code class="csharp">//第二种属性 以Material类型为例，要实现两个脚本 一个是editor脚本一个是Material类型脚本using System.Collections.Generic;using UnityEngine;using WooLocalization;[UnityEditor.CustomEditor(typeof(Test))]public class TestEditor : WooLocalization.LocalizationBehaviorEditor&lt;Test&gt;&#123;&#125;public class Test : WooLocalization.LocalizationBehavior&#123;    protected override List&lt;ILocalizationActor&gt; GetActors()    &#123;            return new List&lt;ILocalizationActor&gt;() &#123;_material &#125;;    &#125;    public ObjectActor&lt;Material&gt; _material = new ObjectActor&lt;Material&gt;(true);&#125;</code></pre><p><img src="/../../../Pic/Doc/WooLocalization/Mat%E5%B1%9E%E6%80%A7.png"></p><h1 id="如何不使用组件也能使用本地化功能"><a href="#如何不使用组件也能使用本地化功能" class="headerlink" title="如何不使用组件也能使用本地化功能"></a>如何不使用组件也能使用本地化功能</h1><pre><code class="csharp">//调用静态类获取信息text.text=Localization.GetLocalization(&quot;Key&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooLocalization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooLocalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-WooLocalization-初始化</title>
      <link href="/2024/10/26/Doc/WooLocalization/5-WooLocalization-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2024/10/26/Doc/WooLocalization/5-WooLocalization-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>本地化初始化时必须加的几句代码 否则会报错</li></ul><pre><code class="csharp">//脚本需要先继承ILocalizationPrefRecorder接口//然后实现这两个方法public LocalizationPref Read()&#123;  return null;&#125;public void Write(LocalizationPref pref)&#123;&#125;//此代码写在初始化方法里//是为了平台适配Localization.SetRecorder(this);//是为了有起手语言Localization.SetDefaultLocalizationType(type);//是为了有数据Localization.SetContext(data);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooLocalization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooLocalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-WooLocalization-Demo</title>
      <link href="/2024/10/26/Doc/WooLocalization/6-WooLocalization-Demo/"/>
      <url>/2024/10/26/Doc/WooLocalization/6-WooLocalization-Demo/</url>
      
        <content type="html"><![CDATA[<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><ul><li>右上角点击切换中英文查看效果<p>  <div style="width:720px; height:512px;border:none;text-align:center">      <iframe allowtransparency="yes" frameborder="0" width="110%" height="110%" src="/Webs/WooLocalization_Webgl/index.html"/>  </div></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooLocalization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooLocalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2024/09/23/Tools/Git/"/>
      <url>/2024/09/23/Tools/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="删除本地远程TAG"><a href="#删除本地远程TAG" class="headerlink" title="删除本地远程TAG"></a>删除本地远程TAG</h2><pre><code class="shell">1、git tag -d $(git tag -l)      //删除本地tag2、git fetch                 //拉取远程tag3、git push origin --delete $(git tag -l)        //删除远程tag4、git tag -d $(git tag -l)      //删除本地tag</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> GIT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-例子2  WebGL</title>
      <link href="/2024/09/06/Doc/WooAsset/12-WooAsset-%E4%BE%8B%E5%AD%90WebGL%202/"/>
      <url>/2024/09/06/Doc/WooAsset/12-WooAsset-%E4%BE%8B%E5%AD%90WebGL%202/</url>
      
        <content type="html"><![CDATA[<p><a href="/Webs/Bubble1Up/index.html">原链接</a></p><p>    <div style="width:405px; height:720px;border:none;text-align:center">        <iframe allowtransparency="yes" frameborder="0" width="100%" height="100%" src="/Webs/Bubble1Up/index.html"/>    </div></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-例子3  WebGL</title>
      <link href="/2024/09/06/Doc/WooAsset/13-WooAsset-%E4%BE%8B%E5%AD%90WebGL%203/"/>
      <url>/2024/09/06/Doc/WooAsset/13-WooAsset-%E4%BE%8B%E5%AD%90WebGL%203/</url>
      
        <content type="html"><![CDATA[<p><a href="/Webs/ShaderGame/index.html">原链接</a></p><p>    <div style="width:500px; height:900px;border:none;text-align:center">        <iframe allowtransparency="yes" frameborder="0" width="100%" height="100%" src="/Webs/ShaderGame/index.html"/>    </div></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-SBP</title>
      <link href="/2024/09/06/Doc/WooAsset/11-WooAsset-SBP/"/>
      <url>/2024/09/06/Doc/WooAsset/11-WooAsset-SBP/</url>
      
        <content type="html"><![CDATA[<h1 id="如果要使用-Scriptable-Build-Pipeline"><a href="#如果要使用-Scriptable-Build-Pipeline" class="headerlink" title="如果要使用  Scriptable Build Pipeline"></a>如果要使用  Scriptable Build Pipeline</h1><ul><li><a href="https://docs.unity3d.com/Packages/com.unity.scriptablebuildpipeline@1.20/manual/GettingStarted.html">官方的文档</a></li><li>使用unity package manager 安装  Scriptable Build Pipeline包</li><li>把下面的代码贴到项目内的某个Editor文件夹下</li><li>把Option页签 build 下的 build pipeline 选择为 SBPPipeline</li></ul><pre><code class="csharp">    public class SBPPipeline : IBuildPipeLine    &#123;        UnityEngine.Build.Pipeline.CompatibilityAssetBundleManifest _main;        public bool BuildAssetBundles(string outputPath, AssetBundleBuild[] builds, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform)        &#123;            try            &#123;                _main = CompatibilityBuildPipeline.BuildAssetBundles(outputPath, builds, assetBundleOptions, targetPlatform);                var bundles = _main.GetAllAssetBundles();                foreach (var bundle in bundles)                &#123;                    var hash = _main.GetAssetBundleHash(bundle).ToString();                    name2Hash[bundle] = hash;                &#125;                return true;            &#125;            catch (System.Exception)            &#123;                return false;                throw;            &#125;        &#125;        Dictionary&lt;string, string&gt; name2Hash = new Dictionary&lt;string, string&gt;();        public List&lt;string&gt; GetAllAssetBundles(BundleNameType nameType)        &#123;            var bundles = _main.GetAllAssetBundles();            switch (nameType)            &#123;                case BundleNameType.Name: return bundles.ToList();                case BundleNameType.NameWithHash:                case BundleNameType.Hash:                    return bundles.Select(name =&gt; $&quot;&#123;name&#125;_&#123;name2Hash[name]&#125;&quot;).ToList();                default:                    return null;            &#125;        &#125;        public List&lt;string&gt; GetAllDependencies(string assetBundleName, BundleNameType nameType)        &#123;            switch (nameType)            &#123;                case BundleNameType.Name:                    return _main.GetAllDependencies(assetBundleName).ToList();                case BundleNameType.NameWithHash:                case BundleNameType.Hash:                    &#123;                        assetBundleName = assetBundleName.Split(&quot;_&quot;)[0];                        return _main.GetAllDependencies(assetBundleName).Select(name =&gt; $&quot;&#123;name&#125;_&#123;name2Hash[name]&#125;&quot;).ToList();                    &#125;                default:                    return null;            &#125;        &#125;        public BuildAssetBundleOptions GetBundleOption(AssetTaskParams param, out string err)        &#123;            err = string.Empty;            BuildAssetBundleOptions opt = BuildAssetBundleOptions.None;            //opt |= BuildAssetBundleOptions.StrictMode;            opt |= BuildAssetBundleOptions.DisableLoadAssetByFileName;            opt |= BuildAssetBundleOptions.DisableLoadAssetByFileNameWithExtension;            if (param.typeTreeOption == TypeTreeOption.DisableWriteTypeTree)                opt |= BuildAssetBundleOptions.DisableWriteTypeTree;            if (param.typeTreeOption == TypeTreeOption.IgnoreTypeTreeChanges)            &#123;                //opt |= BuildAssetBundleOptions.IgnoreTypeTreeChanges;                err = &quot;SBP Not Support IgnoreTypeTreeChanges&quot;;            &#125;            if (param.buildMode == BuildMode.ForceRebuild)                opt |= BuildAssetBundleOptions.ForceRebuildAssetBundle;            opt |= BuildAssetBundleOptions.DisableLoadAssetByFileName;            opt |= BuildAssetBundleOptions.DisableLoadAssetByFileNameWithExtension;            if (param.compress == CompressType.LZ4)                opt |= BuildAssetBundleOptions.ChunkBasedCompression;            if (param.compress == CompressType.Uncompressed)                opt |= BuildAssetBundleOptions.UncompressedAssetBundle;            if (param.Pipeline == TaskPipelineType.DryBuild)            &#123;                //opt = BuildAssetBundleOptions.DryRunBuild;                err = &quot;SBP Not Support DryBuild&quot;;            &#125;            if (param.bundleNameType == BundleNameType.NameWithHash || param.bundleNameType == BundleNameType.Hash)                opt |= BuildAssetBundleOptions.AppendHashToAssetBundleName;            return opt;        &#125;        public uint GetBundleCrc(string directory, string bundleName, BundleNameType nameType)        &#123;            switch (nameType)            &#123;                case BundleNameType.Name:                    return _main.GetAssetBundleCrc(bundleName);                case BundleNameType.NameWithHash:                case BundleNameType.Hash:                    &#123;                        bundleName = bundleName.Split(&quot;_&quot;)[0];                        return _main.GetAssetBundleCrc(bundleName);                    &#125;                default:                    return 0;            &#125;        &#125;        public string GetBundleHash(string directory, string bundleName, BundleNameType nameType)        &#123;            switch (nameType)            &#123;                case BundleNameType.Name:                    return _main.GetAssetBundleHash(bundleName).ToString();                case BundleNameType.NameWithHash:                case BundleNameType.Hash:                    &#123;                        bundleName = bundleName.Split(&quot;_&quot;)[0];                        return _main.GetAssetBundleHash(bundleName).ToString();                    &#125;                default:                    return string.Empty;            &#125;        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-例子WebGL</title>
      <link href="/2024/08/06/Doc/WooAsset/10-WooAsset-%E4%BE%8B%E5%AD%90WebGL/"/>
      <url>/2024/08/06/Doc/WooAsset/10-WooAsset-%E4%BE%8B%E5%AD%90WebGL/</url>
      
        <content type="html"><![CDATA[<p>键盘  ：WASD   上下左右滑动</p><p>    <div style="width:100%; height:350px;border:none;text-align:center">        <iframe allowtransparency="yes" frameborder="0" width="100%" height="100%" src="/Webs/WooAsset_WEBGL/index.html"/>    </div></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Could not produce class with ID</title>
      <link href="/2024/06/18/Unity/Could%20not%20produce%20class%20with%20ID/"/>
      <url>/2024/06/18/Unity/Could%20not%20produce%20class%20with%20ID/</url>
      
        <content type="html"><![CDATA[<p>创建 Assets目录下 link.xml</p><pre><code class="xml">&lt;linker&gt;    &lt;assembly fullname=&quot;IFramework&quot; preserve=&quot;all&quot;/&gt;    &lt;assembly fullname=&quot;UnityEngine&quot;&gt;        &lt;type fullname=&quot;UnityEngine.BoxCollider&quot; preserve=&quot;all&quot;/&gt;        &lt;type fullname=&quot;UnityEngine.SkinnedMeshRenderer&quot; preserve=&quot;all&quot;/&gt;        &lt;type fullname=&quot;UnityEngine.ParticleSystemRenderer&quot; preserve=&quot;all&quot;/&gt;        &lt;type fullname=&quot;UnityEngine.ParticleSystem&quot; preserve=&quot;all&quot;/&gt;        &lt;type fullname=&quot;UnityEngine.AudioListener&quot; preserve=&quot;all&quot;/&gt;    &lt;/assembly&gt;&lt;/linker&gt;</code></pre><p><a href="https://docs.unity3d.com/Manual/ClassIDReference.html">查id的   网页</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ui事件（长按等）</title>
      <link href="/2024/04/16/Unity/UGUI/ui%E4%BA%8B%E4%BB%B6%EF%BC%88%E9%95%BF%E6%8C%89%E7%AD%89%EF%BC%89/"/>
      <url>/2024/04/16/Unity/UGUI/ui%E4%BA%8B%E4%BB%B6%EF%BC%88%E9%95%BF%E6%8C%89%E7%AD%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">    public class UGUIEventListener : MonoBehaviour,IPointerClickHandler,IPointerDownHandler,IPointerEnterHandler,IPointerExitHandler,IPointerUpHandler,ISelectHandler,IUpdateSelectedHandler,IDeselectHandler,IBeginDragHandler,IDragHandler,IEndDragHandler,IDropHandler,IScrollHandler,IMoveHandler    &#123;        public class UIEvent&lt;T&gt; where T : BaseEventData        &#123;            public UIEvent() &#123; &#125;            public void AddListener(UIEventHandle&lt;T&gt; handle)            &#123;                m_UIEventHandle += handle;            &#125;            public void RemoveListener(UIEventHandle&lt;T&gt; handle)            &#123;                m_UIEventHandle -= handle;            &#125;            public void RemoveAllListeners()            &#123;                m_UIEventHandle -= m_UIEventHandle;                m_UIEventHandle = null;            &#125;            public void Invoke(GameObject go, T eventData)            &#123;                m_UIEventHandle?.Invoke(go, eventData);            &#125;            private event UIEventHandle&lt;T&gt; m_UIEventHandle = null;        &#125;        public delegate void UIEventHandle&lt;T&gt;(GameObject go, T eventData) where T : BaseEventData;        public static UGUIEventListener Get(GameObject go)        &#123;            UGUIEventListener listener = go.GetComponent&lt;UGUIEventListener&gt;();            if (listener == null)            &#123;                listener = go.AddComponent&lt;UGUIEventListener&gt;();            &#125;            return listener;        &#125;        public void RemoveAllListeners()        &#123;            onClick.RemoveAllListeners();            onDoubleClick.RemoveAllListeners();            onPointDown.RemoveAllListeners();            onPointup.RemoveAllListeners();            onEnter.RemoveAllListeners();            onExit.RemoveAllListeners();            onSelect.RemoveAllListeners();            onUpdateSelect.RemoveAllListeners();            onDeselect.RemoveAllListeners();            onDrag.RemoveAllListeners();            onEndDrag.RemoveAllListeners();            onDrop.RemoveAllListeners();            onScroll.RemoveAllListeners();            onMove.RemoveAllListeners();        &#125;        public UIEvent&lt;PointerEventData&gt; onClick = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onPointDown = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onEnter = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onExit = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;BaseEventData&gt; onSelect = new UIEvent&lt;BaseEventData&gt;();        public UIEvent&lt;BaseEventData&gt; onUpdateSelect = new UIEvent&lt;BaseEventData&gt;();        public UIEvent&lt;BaseEventData&gt; onDeselect = new UIEvent&lt;BaseEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onBeginDrag = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onDrag = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onEndDrag = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onDrop = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onScroll = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;AxisEventData&gt; onMove = new UIEvent&lt;AxisEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onDoubleClick = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onPress = new UIEvent&lt;PointerEventData&gt;();        public UIEvent&lt;PointerEventData&gt; onPointup = new UIEvent&lt;PointerEventData&gt;();        public void OnPointerEnter(PointerEventData eventData) &#123; onEnter.Invoke(gameObject, eventData); &#125;        public void OnPointerExit(PointerEventData eventData) &#123; onExit.Invoke(gameObject, eventData); &#125;        public void OnSelect(BaseEventData eventData) &#123; onSelect.Invoke(gameObject, eventData); &#125;        public void OnUpdateSelected(BaseEventData eventData) &#123; onUpdateSelect.Invoke(gameObject, eventData); &#125;        public void OnDeselect(BaseEventData eventData) &#123; onDeselect.Invoke(gameObject, eventData); &#125;        public void OnBeginDrag(PointerEventData eventData) &#123; onBeginDrag.Invoke(gameObject, eventData); &#125;        public void OnDrag(PointerEventData eventData) &#123; onDrag.Invoke(gameObject, eventData); &#125;        public void OnEndDrag(PointerEventData eventData) &#123; onEndDrag.Invoke(gameObject, eventData); &#125;        public void OnDrop(PointerEventData eventData) &#123; onDrop.Invoke(gameObject, eventData); &#125;        public void OnScroll(PointerEventData eventData) &#123; onScroll.Invoke(gameObject, eventData); &#125;        public void OnMove(AxisEventData eventData) &#123; onMove.Invoke(gameObject, eventData); &#125;        public float doubleClickGap = 0.2f;        public float pressGap = 0.5f;        private float lastPointdownTime = 0f;        private bool isPointDown = false;        public bool isPress &#123; get &#123; return _isPress; &#125; &#125;        private int clickCount = 0;        private PointerEventData m_OnUpEventData = null;        private bool _isPress;        private void Update()        &#123;            if (isPointDown)            &#123;                if (Time.unscaledTime - lastPointdownTime &gt;= pressGap)                &#123;                    _isPress = true;                    lastPointdownTime = Time.unscaledTime;                    onPress.Invoke(gameObject, null);                &#125;            &#125;            if (clickCount &gt; 0)            &#123;                if (Time.unscaledTime - lastPointdownTime &gt;= doubleClickGap)                &#123;                    if (clickCount &lt; 2)                    &#123;                        onClick.Invoke(gameObject, m_OnUpEventData);                        m_OnUpEventData = null;                    &#125;                    clickCount = 0;                &#125;                if (clickCount &gt;= 2)                &#123;                    onDoubleClick.Invoke(gameObject, m_OnUpEventData);                    m_OnUpEventData = null;                    clickCount = 0;                &#125;            &#125;        &#125;        public void OnPointerClick(PointerEventData eventData)        &#123;        &#125;        public void OnPointerDown(PointerEventData eventData)        &#123;            isPointDown = true;            _isPress = false;            lastPointdownTime = Time.unscaledTime;            onPointDown?.Invoke(gameObject, eventData);        &#125;        public void OnPointerUp(PointerEventData eventData)        &#123;            onPointup?.Invoke(gameObject, eventData);            isPointDown = false;            m_OnUpEventData = eventData;            if (!_isPress)            &#123;                clickCount++;            &#125;        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红点</title>
      <link href="/2024/04/16/Unity/%E7%BA%A2%E7%82%B9/"/>
      <url>/2024/04/16/Unity/%E7%BA%A2%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">class RedPoint&#123;    public string parent_key;    public string key;    private RedTree tree;    public Dictionary&lt;string, RedPoint&gt; children = new Dictionary&lt;string, RedPoint&gt;();    private int count;    private bool hasValue = false;    public RedPoint(string key, string parent_key, RedTree tree)    &#123;        this.parent_key = parent_key;        this.key = key;        this.tree = tree;    &#125;    public int GetCount()    &#123;        return hasValue ? count : 0;    &#125;    public void AddChild(RedPoint p)    &#123;        var p_key = p.key;        if (children.ContainsKey(p_key))            return;        children.Add(p_key, p);    &#125;    public bool SetCount(int count)    &#123;        if (hasValue &amp;&amp; count == this.count) return false;        this.count = count;        hasValue = true;        this.tree.FreshDot(key, count);        return true;    &#125;&#125;public abstract class RedDot : IDisposable&#123;    public string path;    private RedTree tree;    public void SetPath(string path)    &#123;        this.SetPath(path, GGame.Instance.modules.redTree);  // 一开始 要new 一个红点树过来    &#125;    public void SetPath(string path, RedTree tree)    &#123;        this.path = path;        this.tree = tree;        tree.AddDot(this);        this.FreshView(this.GetCount());    &#125;    public int GetCount() =&gt; tree.GetCount(this.path);    public abstract void FreshView(int count);    public void Dispose()    &#123;        tree.RemoveDot(this);        FreshView(0);    &#125;&#125;public class RedActiveDot : RedDot&#123;    private GameObject gameObject;    public RedActiveDot(string path, GameObject gameObject) //传入一个红点的配置路径 然后把红点对象传进去    &#123;        this.gameObject = gameObject;   //对象赋值        this.SetPath(path);             //把这个路径传入 父类RedDot 的SetPath 函数    &#125;    public override void FreshView(int count)    &#123;        UnityEngine.Debug.Log($&quot;&#123;this.path&#125;  &#123;count&#125;&quot;);        this.gameObject.SetActive(count &gt; 0);    &#125;&#125;public partial class RedTree&#123;    private Dictionary&lt;string, List&lt;RedDot&gt;&gt; red_dot_map = new Dictionary&lt;string, List&lt;RedDot&gt;&gt;();    private Dictionary&lt;string, RedPoint&gt; key_map = new Dictionary&lt;string, RedPoint&gt;();    public void AddDot(RedDot dot)    &#123;        var path = dot.path;        if (!red_dot_map.ContainsKey(path))            red_dot_map.Add(path, new List&lt;RedDot&gt;());        red_dot_map[path].Add(dot);    &#125;    public void RemoveDot(RedDot dot)    &#123;        var path = dot.path;        if (!red_dot_map.ContainsKey(path))            return;        if (!red_dot_map[path].Contains(dot)) return;        red_dot_map[path].Remove(dot);    &#125;    private void FreshDot(string path, int count)    &#123;        if (!red_dot_map.ContainsKey(path))            return;        foreach (var item in red_dot_map[path])        &#123;            item.FreshView(count);        &#125;    &#125;    private RedPoint Find(string key)    &#123;        if (key_map.ContainsKey(key))            return key_map[key];        return null;    &#125;    private RedPoint AddPoint(string parentKey, string key)    &#123;        var _new = Find(key);        if (_new == null)        &#123;            _new = new RedPoint(key, parentKey, this);            key_map.Add(key, _new);        &#125;        return _new;    &#125;    private void FreshParent(string key)    &#123;        if (string.IsNullOrEmpty(key)) return;        var point = Find(key);        int sum = 0;        foreach (var item in point.children.Values)        &#123;            sum += item.GetCount();        &#125;        if (point.SetCount(sum))        &#123;            FreshParent(point.parent_key);        &#125;    &#125;    public void SetCount(string key, int count)    &#123;        var point = Find(key);        if (point == null || point.children.Count &gt; 0) return;        if (point.SetCount(count))        &#123;            FreshParent(point.parent_key);        &#125;    &#125;    public int GetCount(string key)    &#123;        var point = Find(key);        return point == null ? 0 : point.GetCount();    &#125;    public void ReadPath(string key, char separator)    &#123;        var columns = key.Split(separator);        RedPoint last = null;        for (int j = 0; j &lt; columns.Length; j++)        &#123;            var _pkey = string.Join(separator.ToString(), columns, 0, j);            var _key = string.Join(separator.ToString(), columns, 0, j + 1);            var point = AddPoint(_pkey, _key);            if (last != null)                last.AddChild(point);            last = point;        &#125;    &#125;    public void ClearPath(string key)    &#123;        var point = Find(key);        if (point == null) return;        key_map.Remove(key);        foreach (var item in point.children.Keys)        &#123;            ClearPath(item);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新手引导遮罩</title>
      <link href="/2024/04/16/Unity/UGUI/%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E9%81%AE%E7%BD%A9/"/>
      <url>/2024/04/16/Unity/UGUI/%E6%96%B0%E6%89%8B%E5%BC%95%E5%AF%BC%E9%81%AE%E7%BD%A9/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;Hidden/GuideMask&quot;&#123;    Properties    &#123;        _Rect(&quot;Rect&quot;,vector)=(0,0,0,0)        _BackgroundColor(&quot;_BackgroundColor&quot;,Color)=(0,0,0,0.3)        _FrontColor(&quot;_FrontColor&quot;,Color)=(0,0,0,0.2)        _Radian(&quot;_Radian&quot;,Range(0,1))=0.5    &#125;    SubShader    &#123;        Cull Off ZWrite Off ZTest Always        Pass        &#123;            Tags&#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;            Blend SrcAlpha OneMinusSrcAlpha            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;UnityCG.cginc&quot;            struct appdata            &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;            &#125;;            struct v2f            &#123;                float2 uv : TEXCOORD0;                float4 vertex : SV_POSITION;            &#125;;            v2f vert (appdata v)            &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                o.uv = v.uv;                return o;            &#125;            float4 _Rect;            fixed4 _BackgroundColor;            fixed4 _FrontColor;            float _Radian;            fixed InCircle(float2 center,float radius,float2 uv)            &#123;                return step(radius,distance(center,uv));            &#125;            float Fit(float2 pos)            &#123;                pos=pos*_ScreenParams.xy;                float2 halfSize= _Rect.zw/2;                float halfWidth=halfSize.x;                float halfHeight=halfSize.y;                float _min= min(halfWidth,halfHeight);                float radius = _min*_Radian;                float2 horizontalsize=halfSize-float2(radius,0);                float2 verticalsize=halfSize-float2(0,radius);                fixed2 h=step(_Rect.xy-horizontalsize,pos)*step(pos,_Rect.xy+horizontalsize);                fixed2 v=step(_Rect.xy-verticalsize,pos)*step(pos,_Rect.xy+verticalsize);                float _r=max(h.x*h.y,v.x*v.y);                float2 center=_Rect.xy;                float witdhBigger=step(halfHeight,halfWidth);                float heightBigger=1-witdhBigger;                float _add=_min*(1-_Radian);                float gap= max(halfWidth,halfHeight)-_min;                float2 lu=center+float2(-gap*witdhBigger,gap*heightBigger)+float2(-_add,_add);                float2 ld=center+float2(-gap*witdhBigger,-gap*heightBigger)+float2(-_add,-_add);                float2 ru=center+float2(gap*witdhBigger,gap*heightBigger)+float2(_add,_add);                float2 rd=center+float2(gap*witdhBigger,-gap*heightBigger)+float2(_add,-_add);                float _c= InCircle(lu,radius,pos)*InCircle(ru,radius,pos)*InCircle(ld,radius,pos)*InCircle(rd,radius,pos);                return max(_r,1-_c);            &#125;            fixed4 frag (v2f i) : SV_Target            &#123;                return lerp(_BackgroundColor,_FrontColor,Fit(i.uv));            &#125;            ENDCG        &#125;    &#125;&#125;</code></pre><pre><code class="csharp">    public class GuideMask : Graphic, ICanvasRaycastFilter    &#123;        [SerializeField] private Vector2 _center;        [SerializeField] private Vector2 _size;        [SerializeField] private Vector2 _margin=Vector2.one*10;        [SerializeField] private float _radian = 0.2f;        [SerializeField] private bool _raycastInRect;        [SerializeField] private bool _raycastPass;        public Vector2 center        &#123;            get &#123; return _center; &#125;        &#125;        public Vector2 size        &#123;            get &#123; return _size; &#125;        &#125;        public Rect rect &#123; get &#123; return new Rect() &#123; size = size, center = center, &#125;; &#125; &#125;        public bool raycastInRect &#123; get &#123; return _raycastInRect; &#125; set &#123; _raycastInRect = value; &#125; &#125;        public bool raycastPass &#123; get &#123; return _raycastPass; &#125; set &#123; _raycastPass = value; &#125; &#125;        public Vector2 margin &#123; get &#123; return _margin; &#125; set &#123; _margin = value; &#125; &#125;        public float radian &#123; get &#123; return _radian; &#125; &#125;        public Color background        &#123;            get            &#123;                if (material == null) return Color.white;                return material.GetColor(&quot;_BackgroundColor&quot;);            &#125;            set            &#123;                if (material == null) return;                material.SetColor(&quot;_BackgroundColor&quot;, value);            &#125;        &#125;        public override Color color        &#123;            get            &#123;                if (material == null) return Color.white;                return material.GetColor(&quot;_FrontColor&quot;);            &#125;            set            &#123;                if (material == null) return;                material.SetColor(&quot;_FrontColor&quot;, value);            &#125;        &#125;        public void SetRect(Rect rect)        &#123;            this._center = rect.center;            this._size = rect.size;            if (material == null) return;            material.SetVector(&quot;_Rect&quot;, new Vector4(center.x, center.y, size.x, size.y));        &#125;        public void SetRadian(float radian)        &#123;            this._radian = radian;            if (material == null) return;            material.SetFloat(&quot;_Radian&quot;, radian);        &#125;        public Rect GetFocusRect(RectTransform trans,Vector2 offset)        &#123;            Bounds bounds = RectTransformUtility.CalculateRelativeRectTransformBounds(trans);            Vector2 size = bounds.extents * 2;            Canvas canvas = trans.GetComponentInParent&lt;Canvas&gt;();            Vector2 center = Vector2.zero;            switch (canvas.renderMode)            &#123;                case RenderMode.ScreenSpaceOverlay:                    center = RectTransformUtility.WorldToScreenPoint(null, trans.position);                    break;                case RenderMode.ScreenSpaceCamera:                case RenderMode.WorldSpace:                    center = RectTransformUtility.WorldToScreenPoint(canvas.worldCamera, trans.position);                    break;                default:                    break;            &#125;            return new Rect(center - (Vector2)bounds.extents + offset - margin/2, size+ margin);        &#125;        public Rect GetFocusRect(Transform trans, Vector2 size, Camera camera)        &#123;            if (camera == null)                camera = Camera.main;            Vector2 center = camera.WorldToScreenPoint(trans.position);            return new Rect() &#123; size = size +margin, center = center - margin / 2, &#125;;        &#125;        public void Focus(RectTransform trans, Vector2 offset)        &#123;            SetRect(GetFocusRect(trans,offset));        &#125;        public void Focus(Transform trans, Vector2 size, Camera camera)        &#123;            SetRect(GetFocusRect(trans, size, camera));        &#125;        private bool Contains(Rect rect, Vector2 point)        &#123;            return rect.Contains(point);        &#125;        protected override void Awake()        &#123;            SetRect(this.rect);            SetRadian(this._radian);        &#125;        public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera)        &#123;            if (!raycastPass) return true;            if (raycastInRect) return !Contains(rect, sp);            return false;        &#125;    &#125;</code></pre><pre><code class="csharp">    [CustomEditor(typeof(GuideMask))]    class GuideMaskEditor : Editor    &#123;        GuideMask gm &#123; get &#123; return target as GuideMask; &#125; &#125;        public override void OnInspectorGUI()        &#123;            EditorGUI.BeginChangeCheck();            gm.material= EditorGUILayout.ObjectField(&quot;Material&quot;, gm.material, typeof(Material), false) as Material;            gm.color = EditorGUILayout.ColorField(&quot;Color&quot;, gm.color);            gm.background = EditorGUILayout.ColorField(&quot;Background Color&quot;, gm.background);            gm.raycastTarget = EditorGUILayout.Toggle(&quot;Raycast Target&quot;, gm.raycastTarget);            gm.raycastInRect = EditorGUILayout.Toggle(&quot;Raycast In Rect&quot;, gm.raycastInRect);            gm.raycastPass = EditorGUILayout.Toggle(&quot;Raycast Pass&quot;, gm.raycastPass);            var center = EditorGUILayout.Vector2Field(&quot;Center&quot;, gm.center);            var size = EditorGUILayout.Vector2Field(&quot;Size&quot;, gm.size);            gm.margin = EditorGUILayout.Vector2Field(&quot;Margin&quot;, gm.margin);            var radian= EditorGUILayout.Slider(&quot;Radian&quot;, gm.radian, 0, 1);            if (EditorGUI.EndChangeCheck())            &#123;                gm.SetRadian(radian);                gm.SetRect(new Rect() &#123; size = size, center = center, &#125;);                               serializedObject.ApplyModifiedProperties();            &#125;        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-WooSerialization-案例</title>
      <link href="/2023/08/11/Doc/WooSerialization/1-WooSerialization-%E6%A1%88%E4%BE%8B/"/>
      <url>/2023/08/11/Doc/WooSerialization/1-WooSerialization-%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h2><ul><li><p>支持struct 、class、array、list、dictionary外加部分集合转换成string</p><pre><code class="csharp">HuMan hu = new HuMan() &#123; age = 6, Name = &quot;abc&quot;, sex = &quot;sex&quot;, heigth = 16, width = 20 &#125;;Dictionary&lt;int, HuMan&gt; hus = new Dictionary&lt;int, HuMan&gt;() &#123;&#123; 1, hu &#125;,&#123; 2, hu &#125; &#125;;//对象转换成字符串var str = StringConvert.ConvertToString(hus); //字符串转换成对象Dictionary&lt;int, HuMan&gt; hus2;bool success=StringConvert.TryConvert(str, out hus2);</code></pre></li></ul><h2 id="数据表格（csv）的读写"><a href="#数据表格（csv）的读写" class="headerlink" title="数据表格（csv）的读写"></a>数据表格（csv）的读写</h2><ul><li>将数据写入csv文件或者从csv文件还原数据</li><li>特点<ul><li>支持表头的重命名、表头忽略、按索引读写等</li><li>支持自定义分离符</li></ul></li></ul><pre><code class="csharp">//结构体定义struct HuMan&#123;    public int age;    [DataColumnName(&quot;The Sex&quot;)]    public string sex;    public string Name;    [DataReadColumnIndex(0)]    public int heigth;    [DataIgnore]    [NonSerialized]    public int width;&#125;string path = &quot;Mans.csv&quot;;//创建一个列表List&lt;HuMan&gt; cs = new List&lt;HuMan&gt;()&#123;    new HuMan()&#123; age=1,sex=&quot;m&quot;,Name=&quot;xm&quot;,heigth=0&#125;,    new HuMan()&#123; age=2,sex=&quot;m1&quot;,Name=&quot;xm1&quot;,heigth=0&#125;,    new HuMan()&#123; age=3,sex=&quot;m2&quot;,Name=&quot;xm2&quot;,heigth=0&#125;,&#125;;//写入CSVvar w = DataTableTool.CreateWriter(new System.IO.StreamWriter(path, false),    new DataRow(),    new DataExplainer()); //在这里可以设置分离符w.Write(cs);w.Dispose();//读取CSVvar r =    DataTableTool.CreateReader(new System.IO.StreamReader(path, System.Text.Encoding.UTF8),    new DataRow(),    new DataExplainer()); //分离符要与写入时一致var cc = r.Get&lt;HuMan&gt;();r.Dispose();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooSerialization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooSerialization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-IFramework-Unity-模块</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/10-IFramework-Unity-%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/10-IFramework-Unity-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-IFramework-Unity-简介</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/1-IFramework-Unity-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/1-IFramework-Unity-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a><a href="https://github.com/OnClick9927/IFramework-Unity">地址</a></h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://starchart.cc/OnClick9927/IFramework-Unity"><img src="https://starchart.cc/OnClick9927/IFramework-Unity.svg?variant=adaptive" alt="Stargazers over time"></a></p><pre><code class="csharp">while(true)    Console.Write(&quot;Thanks For EveryOne Who Used It Once !&quot;)</code></pre><p>QQ Group ：782290296 </p><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>支持</p><ul><li><p>Core</p><ul><li>通用单例</li><li>优先级队列</li><li>标准化模块</li><li>主线程等待</li><li>通用消息系统</li><li>C# Async 扩展</li><li>可序列化字典</li><li>通用本地数据缓存 </li><li>Log</li><li>编辑器工具  序列化&#x2F;拖拽&#x2F;窗口&#x2F;模板代码&#x2F;项目设置&#x2F;GUI</li></ul></li><li><p>UI</p><ul><li>自定义加载 同步&#x2F;异步，可等待</li><li>内部处理 ui 多次点击的问题</li><li>提供全局遮罩</li><li>提供 Item 池</li><li>自定义层级</li><li>配套代码生成</li><li>支持多样化扩展（预定义了 MVC模式）</li><li>极简生命周期（OnLoad、OnShow、OnHide、OnClose）</li><li>UI整体变化接口（用于顶部资源栏、全屏UI、触发各种事件等）</li></ul></li><li><p>RedPoint</p><ul><li>支持窗口查看每个节点的数量与绑定情况</li><li>支持自定义绑定</li></ul></li><li><p>Record</p><ul><li>支持自定义命令</li><li>支持命令克隆</li><li>支持命令组</li></ul></li><li><p>Audio（简易音效系统）</p><ul><li>支持无限多通道</li><li>支持循环&#x2F;差异化音量&#x2F;通道内覆盖</li></ul></li><li><p>HotFix (基于XLUA、不想更新了😀)</p><ul><li>模板代码</li><li>lua 工具（ class、async、try、handler、using、EventSystem、ObservableObject、_G锁）</li><li>UI模块的 Lua扩展 （MVC）</li><li>热重载</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-IFramework-Unity-安装与设置</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/2-IFramework-Unity-%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/2-IFramework-Unity-%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>upm 添加包地址 <a href="https://gitee.com/OnClick9927/IFramework-Unity.git#src">https://gitee.com/OnClick9927/IFramework-Unity.git#src</a></li><li>upm 添加包地址 <a href="https://github.com/OnClick9927/IFramework-Unity.git#src">https://github.com/OnClick9927/IFramework-Unity.git#src</a></li></ul><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><ul><li>打开面板 ctrl+shift+i</li><li>参数</li></ul><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>UserName</td><td>用户名字（unity账户名字）</td></tr><tr><td>Version</td><td>工程的版本</td></tr><tr><td>NameSpace</td><td>工程命名空间</td></tr><tr><td>Project Path</td><td>项目内容所在文件夹</td></tr><tr><td>Build</td><td>构建工程目录</td></tr><tr><td>Dock EditorWindow</td><td>打开的窗口是否依附</td></tr><tr><td>Enable</td><td>log 总开关</td></tr><tr><td>Log Enable</td><td>开启log</td></tr><tr><td>Warning Enable</td><td>开启Warning</td></tr><tr><td>Error Enable</td><td>开启Error</td></tr></tbody></table><p><img src="/../../../Pic/Doc/IFramework-Unity/set.png" alt="Alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-IFramework-Unity-UI模块</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/3-IFramework-Unity-UI%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/3-IFramework-Unity-UI%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="预制体制作代码生成"><a href="#预制体制作代码生成" class="headerlink" title="预制体制作代码生成"></a>预制体制作代码生成</h1><ul><li>打开面板 ctrl+shift+i</li><li>做好预制体，挂上脚本UIPanel，拽到resources目录</li><li>拽如脚本生成路径</li><li>选择好刚刚的预制体，放到GameObject</li><li>标记好需要生成的组件</li><li>点击 Gen</li><li>生成代码 如 ui-5</li><li>设置好ui层级 并点击save to file</li><li>点击生成 UI 名字 如 ui-7<br><img src="/../../../Pic/Doc/IFramework-Unity/UI/UI-.png" alt="ui-1"><br><img src="/../../../Pic/Doc/IFramework-Unity/UI/UI-2.png" alt="ui-2"><br><img src="/../../../Pic/Doc/IFramework-Unity/UI/UI-3.png" alt="ui-3"><br><img src="/../../../Pic/Doc/IFramework-Unity/UI/UI-4.png" alt="ui-4"><br><img src="/../../../Pic/Doc/IFramework-Unity/UI/UI-5.png" alt="ui-5"><br><img src="/../../../Pic/Doc/IFramework-Unity/UI/UI-6.png" alt="ui-6"><br><img src="/../../../Pic/Doc/IFramework-Unity/UI/UI-7.png" alt="ui-7"></li></ul><h1 id="运行时代码"><a href="#运行时代码" class="headerlink" title="运行时代码"></a>运行时代码</h1><h2 id="加载出来界面"><a href="#加载出来界面" class="headerlink" title="加载出来界面"></a>加载出来界面</h2><pre><code class="csharp">public class MyUIAsset : UIAsset&#123;    PanelPathCollect collect;    public MyUIAsset(PanelPathCollect collect)    &#123;        this.collect = collect;    &#125;    ///界面层级获取    public override UILayer GetPanelLayer(string path)    &#123;        return collect.datas.Find(x =&gt; x.path == path).layer;    &#125;    public override int GetPanelLayerOrder(string path)    &#123;        return collect.datas.Find(x =&gt; x.path == path).order;    &#125;        //如何加载出来界面    public override UIPanel LoadPanel(string name)    &#123;        return Resources.Load&lt;UIPanel&gt;(name);    &#125;///下面是异步    public override bool LoadItemAsync(string path, LoadItemAsyncOperation op)    &#123;        return false;    &#125;    public override bool LoadPanelAsync(string name, LoadPanelAsyncOperation op)    &#123;        return false;    &#125;&#125;///加载代码public TextAsset text;///创建模块UIModule ui = Launcher.modules.GetModule&lt;UIModule&gt;();///设置UI资源ui.SetAsset(new MyUIAsset(JsonUtility.FromJson&lt;PanelPathCollect&gt;(text.text)));///设置UI书写模式MvcGroups mvc = new MvcGroups(new Dictionary&lt;string, Type&gt;()&#123;    &#123; PanelNames.MyPanel, typeof(MyPanelView) &#125;,&#125;);ui.SetGroups(mvc);///创建画布ui.CreateCanvas();///打开界面ui.Show(PanelNames.MyPanel);</code></pre><h2 id="界面方法书写"><a href="#界面方法书写" class="headerlink" title="界面方法书写"></a>界面方法书写</h2><pre><code class="csharp">public partial class MyPanelView&#123;  ///界面加载出来绑定按钮  protected override void OnLoad()  &#123;    this.BindButton(this.Mybtn, () =&gt;    &#123;      UnityEngine.Debug.Log(&quot;Click&quot;);    &#125;);  &#125;  protected override void OnShow()  &#123;  &#125;  protected override void OnHide()  &#123;  &#125;  protected override void OnClose()  &#123;  &#125;&#125;</code></pre><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p><img src="/../../../Pic/Doc/IFramework-Unity/UI/UI-8.png" alt="ui-8"></p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-IFramework-Unity-Lua模块</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/4-IFramework-Unity-Lua%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/4-IFramework-Unity-Lua%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="csharp">public class AssetsLoader : IXLuaLoader&#123;    public static string projectScriptsPath    &#123;        get &#123; return Application.dataPath.CombinePath(&quot;Project/Lua&quot;); &#125;    &#125;    public byte[] load(ref string path)    &#123;        if (path.EndsWith(&quot;.lua&quot;))            path = path.Replace(&quot;.lua&quot;, &quot;&quot;);        path = path.Replace(&quot;.&quot;, &quot;/&quot;);        string filepath = $&quot;&#123;path&#125;.lua&quot;;        var textAsset = Resources.Load&lt;TextAsset&gt;(filepath);        if (textAsset != null)            return textAsset.bytes;        filepath = projectScriptsPath.CombinePath(filepath + &quot;.txt&quot;).ToAssetsPath();#if UNITY_EDITOR        var handle = UnityEditor.AssetDatabase.LoadAssetAtPath&lt;TextAsset&gt;(filepath);        return handle.bytes;#endif        return null;    &#125;&#125;public class LuaGame : Game&#123;    public class UnityModules    &#123;        public XLuaModule Lua &#123; get &#123; return Launcher.modules.GetModule&lt;XLuaModule&gt;(); &#125; &#125;    &#125;    public UnityModules unityModules = new UnityModules();    public override void Init()    &#123;    &#125;    public override void Startup()    &#123;           /// 创建模块，设置lua 文件加载器        unityModules.Lua.AddLoader(new AssetsLoader());        ///开始Lua 模块        new XluaMain(unityModules.Lua);    &#125;&#125;</code></pre><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><ul><li>XluaMain 会依次调用<ul><li>FixCsharp.lua</li><li>GlobalDefine.lua</li><li>GameLogic.lua</li></ul></li><li>其他：请参阅Xlua<br><img src="/../../../Pic/Doc/IFramework-Unity/Lua.png" alt="Alt text"></li></ul><h2 id="其他部分"><a href="#其他部分" class="headerlink" title="其他部分"></a>其他部分</h2><h3 id="Lua-提供的方法"><a href="#Lua-提供的方法" class="headerlink" title="Lua 提供的方法"></a>Lua 提供的方法</h3><ul><li>class  （lua class）</li><li>handler （方法句柄）</li><li>try （仿造C# 的try）</li><li>async&#x2F; await&#x2F;luaTask （lua 内的多线程实现）</li><li>StaticUsing  （类似 C# 的static using ，参照 UI生成的代码）</li><li>EventSystem （消息事件）</li><li>Json （纯lua 的jason 序列化）</li><li>Log  (框架输出)</li></ul><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><ul><li>UI 与 C# 部分保持高度雷同， 不同点在于<ul><li>lua 生成出来的 组件会统一放在 Controls 内</li><li>设置代码的组需要是lua内的 LuaGroups_MVC ui.SetGroups(mvc);</li></ul></li></ul><pre><code class="lua">-- 设置代码组local UI = Game.modules.UpdateUIlocal map =&#123;    &#123; Name = PanelNames.UpdatePanel, ViewType = require(&quot;Update.UpdatePanelView&quot;) &#125;,&#125;local groups = LuaGroups_MVC()UI:SetGroups(groups:SetMap(map))</code></pre><pre><code class="lua">--*********************************************************************************--Author:         Wulala--Version:        1.0--UnityVersion:   2020.3.3f1c1--Date:           2023-07-24--*********************************************************************************---ViewUseFlaglocal Button = StaticUsing(&quot;UnityEngine.UI.Button&quot;)---ViewUseFlag---@class MyPanelView : UIView_MVClocal MyPanelView = class(&quot;MyPanelView&quot;,UIView_MVC)function MyPanelView:OnLoad()    self.Controls = &#123;        ---@type UnityEngine.UI.Button        Mybtn = self:GetComponent(&quot;Mybtn&quot;, typeof(Button)),    &#125;endfunction MyPanelView:OnShow()endfunction MyPanelView:OnHide()endfunction MyPanelView:OnClose()    self.Controls = nilendreturn MyPanelView</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-IFramework-Unity-单例</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/6-IFramework-Unity-%E5%8D%95%E4%BE%8B/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/6-IFramework-Unity-%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">public class Test : IFramework.Singleton.Singleton&lt;Test&gt;&#123;    internal void Dosth()    &#123;           &#125;&#125;//场景内单例物体路径[IFramework.Singleton.MonoSingletonPath(&quot;xx/xx&quot;)]public class TestMono : IFramework.Singleton.MonoSingleton&lt;TestMono&gt;&#123;    void Use()    &#123;        Test.instance.Dosth();        TestMono.instance.Dosth();    &#125;    private void Dosth()    &#123;            &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-IFramework-Unity-红点</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/5-IFramework-Unity-%E7%BA%A2%E7%82%B9/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/5-IFramework-Unity-%E7%BA%A2%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">    //自定义绑定，显示节点对应的数字  private class Dot : RedDot    &#123;        public Text text;        public Dot(string path, Text text)        &#123;            this.text = text;            SetPath(path);        &#125;        public override void FreshView(int count)        &#123;            text.text = count.ToString();        &#125;    &#125;  public class redPointGame : Game&#123;    public Toggle add;    public List&lt;Button&gt; btns = new List&lt;Button&gt;();    public List&lt;string&gt; keys = new List&lt;string&gt;() &#123;    &quot;11&quot;,    &quot;11/22&quot;,    &quot;11/33&quot;,    &#125;;    public override void Init()    &#123;      //读入红点路径        for (int i = 0; i &lt; keys.Count; i++)               RedTree.ReadPath(keys[i]);  //对按钮挨个绑定        for (int i = 0; i &lt; btns.Count; i++)        &#123;            var index = i;            var btnsNode = btns[i];            var key = keys[index];            var text = btnsNode.GetComponentInChildren&lt;Text&gt;();            new Dot(key, text);//自定义显示数字的绑定            //控制显示隐藏的绑定            //当数字小于0会隐藏            new RedActiveDot(key, text.gameObject);                      btnsNode.onClick.AddListener(() =&gt;            &#123;                //按钮点击对红点数据修改            //注意只有叶子节点修改会起效                RedTree.SetCount(key, RedTree.GetCount(key) + (add.isOn ? 1 : -1));            &#125;);        &#125;    &#125;    public override void Startup()    &#123;    &#125;    private void OnGUI()    &#123;      //红点编辑器窗口        if (GUILayout.Button(&quot;open WIndow&quot;, new GUIStyle(&quot;button&quot;) &#123; fontSize = 40 &#125;, GUILayout.Height(300), GUILayout.Width(300)))        &#123;            IFramework.EditorTools.EditorWindowTool.Create(&quot;RedPoint&quot;);        &#125;    &#125;&#125;</code></pre><p><img src="/../../../Pic/Doc/IFramework-Unity/Red/win.png" alt="Alt text"></p><ul><li>path 红点路径</li><li>count 当前数量</li><li>dot  有几个绑定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-IFramework-Unity-事件</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/7-IFramework-Unity-%E4%BA%8B%E4%BB%B6/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/7-IFramework-Unity-%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-IFramework-Unity-优先级队列</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/9-IFramework-Unity-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/9-IFramework-Unity-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-IFramework-Unity-Prefs</title>
      <link href="/2023/07/24/Doc/IFramework-Unity/8-IFramework-Unity-Prefs/"/>
      <url>/2023/07/24/Doc/IFramework-Unity/8-IFramework-Unity-Prefs/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework-Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework-Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-IFramework-模块-模块与环境</title>
      <link href="/2023/07/24/Doc/IFramework/10-IFramework-%E6%A8%A1%E5%9D%97-%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%8E%AF%E5%A2%83/"/>
      <url>/2023/07/24/Doc/IFramework/10-IFramework-%E6%A8%A1%E5%9D%97-%E6%A8%A1%E5%9D%97%E4%B8%8E%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>从文档  记录模块 到 自定义模块 ，我们获取任意一个模块的代码都是如下</li><li>为什么这么做：<ul><li>写例子方便，环境是对模块的包装</li><li>少写一些重复代码</li></ul></li><li>为什么要总结：<ul><li>模块可以拿出来单独使用</li></ul></li></ul><pre><code class="csharp">//获取模块容器IModules moduleContainer= Framework.GetEnv(EnvironmentType.Ev0).modules;//创建模块实例moduleContainer.CreateModule&lt;MyModule&gt;();</code></pre><h1 id="单独使用模块"><a href="#单独使用模块" class="headerlink" title="单独使用模块"></a>单独使用模块</h1><ul><li>自定义一个脚本用于存储模块实例</li><li>提供外部可以访问的获取模块方法</li><li>下面是 自定义模块 的写法</li></ul><pre><code class="csharp">Modules modules = new Modules();modules.GetModule&lt;MyModule&gt;();</code></pre><h1 id="环境包含内容"><a href="#环境包含内容" class="headerlink" title="环境包含内容"></a>环境包含内容</h1><ul><li>对模块实例的持有</li><li>一个计时器</li><li>生命周期绑定</li><li>生命周期等待（处理多线程）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-IFramework-简介</title>
      <link href="/2023/07/24/Doc/IFramework/1-IFramework-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/24/Doc/IFramework/1-IFramework-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a><a href="https://github.com/OnClick9927/IFramework">地址</a></h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>IFramework（任何C#环境均可）包含以下内容：</p><ul><li>Log （框架的log）</li><li>Singleton （通用C#单例）</li><li>PriorityQueue （优先级队列）</li><li>Modules （模块合集）</li><li>Environment （环境，包含模块合集与计时）</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><code>git clone -b src https://github.com/OnClick9927/IFramework</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-IFramework-单例</title>
      <link href="/2023/07/24/Doc/IFramework/2-IFramework-%E5%8D%95%E4%BE%8B/"/>
      <url>/2023/07/24/Doc/IFramework/2-IFramework-%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><p>快速创建单例类，使其全局唯一</p><p>使用方式：继承<code>SingletonPropertyClass</code>&lt;<code>T</code>&gt;</p><p>特点：</p><ul><li>在第一次调用时会调用构造函数和初始化函数</li><li>使用静态方法，<strong>不允许</strong>外部访问<code>instance</code></li></ul><p>使用示例:</p><pre><code class="csharp">//继承SingletonPropertyClasspublic class MySingletonClass : SingletonPropertyClass&lt;MySingletonClass&gt;&#123;    private int a;    private string b;    private MySingletonClass()    &#123;        //构造函数        a = 1;        b = &quot;this is a string&quot;;    &#125;    protected override void OnSingletonInit()    &#123;        //初始化    &#125;    public static void DO()    &#123;        //注意：使用【静态方法】访问实例化对象instance,instance 【不能】 在外部访问        System.Console.WriteLine($&quot;int:&#123;instance.a&#125; string :&#123;instance.b&#125;&quot;);    &#125;    protected override void OnDispose()    &#123;    &#125;&#125;//方法调用MySingletonClass.DO();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-IFramework-优先级队列</title>
      <link href="/2023/07/24/Doc/IFramework/3-IFramework-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
      <url>/2023/07/24/Doc/IFramework/3-IFramework-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><blockquote><p>A:请不要插队<br><br>B:我有VIP<br><br>A:前面全是SVIP在等</p></blockquote><p>根据优先级自动排序的队列，消息模块就用到了这个队列来根据紧急程度排序</p><h2 id="1、快速优先级队列"><a href="#1、快速优先级队列" class="headerlink" title="1、快速优先级队列"></a>1、快速优先级队列</h2><p>特点:</p><ul><li>优先级值低的排在队列前面</li><li>相同优先级的节点元素的排序是<strong>随机的</strong></li></ul><p>使用示例:</p><pre><code class="csharp">//节点public class FastNode : FastPriorityQueueNode&#123;    public int value;&#125;//创建优先级队列FastPriorityQueue&lt;FastNode&gt; nodes = new FastPriorityQueue&lt;FastNode&gt;(10);//节点元素入队for (int i = 10; i &gt; 0; i--)&#123;    nodes.Enqueue(new FastNode() &#123; value = i &#125;, 10 - i);&#125;//节点元素出队while (nodes.count != 0)&#123;    Log.L($&quot;出队元素的值为：&#123;nodes.Dequeue().value&#125;&quot;);&#125;</code></pre><h2 id="2、泛型优先级队列"><a href="#2、泛型优先级队列" class="headerlink" title="2、泛型优先级队列"></a>2、泛型优先级队列</h2><p>特点:</p><ul><li>优先级值使用可以对比值大小的泛型</li><li>优先级值低的排在队列前面</li><li>相同优先级的节点元素的排序是<strong>先进先出的</strong></li></ul><p>使用示例:</p><pre><code class="csharp">//节点public class GenericNode : GenericPriorityQueueNode&lt;char&gt;&#123;    public int value;&#125;//创建队列，这里以char为例GenericPriorityQueue&lt;GenericNode, char&gt; nodes = new GenericPriorityQueue&lt;GenericNode, char&gt;(10);//节点元素入队for (int i = 10; i &gt; 0; i--)&#123;    nodes.Enqueue(new GenericNode() &#123; value = i &#125;, Convert.ToChar(64 + i));&#125;//节点元素出队while (nodes.count != 0)&#123;    Log.L($&quot;出队元素的值为：&#123;nodes.Dequeue().value&#125;&quot;);&#125;</code></pre><h2 id="3、稳定优先级队列"><a href="#3、稳定优先级队列" class="headerlink" title="3、稳定优先级队列"></a>3、稳定优先级队列</h2><p>特点:</p><ul><li>优先级值低的排在队列前面</li><li>相同优先级的节点元素的排序是<strong>先进先出的</strong></li></ul><p>和快速优先级队列的区别就只在于出现相同优先级的判断……</p><h2 id="4、简单优先级队列"><a href="#4、简单优先级队列" class="headerlink" title="4、简单优先级队列"></a>4、简单优先级队列</h2><p>特点:</p><ul><li>队列没有大小限制</li><li>支持添加空节点元素和重复的节点元素</li><li>优先级值低的排在队列前面</li><li>相同优先级的节点元素的排序是<strong>先进先出的</strong></li></ul><p>使用示例：</p><pre><code class="csharp">//创建队列SimplePriorityQueue&lt;string&gt; nodes = new SimplePriorityQueue&lt;string&gt;();//节点元素入队for (int i = 1; i &lt;= 10; i++)&#123;    nodes.Enqueue($&quot;&#123;i&#125;&quot;, i);&#125;//空节点元素和重复节点元素入队string item = &quot;重复值&quot;;nodes.Enqueue(null, 1);nodes.Enqueue(null, 3);nodes.Enqueue(item, 4);nodes.Enqueue(item, 5);//节点元素出队while (nodes.count != 0)&#123;    Log.L($&quot;出队元素的值为：&#123;nodes.Dequeue()&#125;&quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-IFramework-模块-记录模块</title>
      <link href="/2023/07/24/Doc/IFramework/4-IFramework-%E6%A8%A1%E5%9D%97-%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework/4-IFramework-%E6%A8%A1%E5%9D%97-%E8%AE%B0%E5%BD%95%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="记录模块"><a href="#记录模块" class="headerlink" title="记录模块"></a>记录模块</h1><p>拿小本本记下一举一动</p><p>模块特点:</p><ul><li>撤销与反撤销</li><li>支持以Command或Action作为操作</li><li>支持将多个操作合并成一个组调用</li></ul><p>使用示例:</p><pre><code class="csharp">//获取模块IOperationRecorderModule recorderModule=Framework.GetEnv(EnvironmentType.Ev0).modules.Recoder;static int value = 0;//增加数值Commandstruct AddValueCommand : ICommand&#123;    public void Excute()    &#123;        value++;    &#125;&#125;//减少数值Commandstruct SubValueCommand : ICommand&#123;    public void Excute()    &#123;        value--;    &#125;&#125;//注册Action操作和其回退操作var actionState = recorderModule.AllocateAction().SetCommand(() =&gt; &#123; value += 16; &#125;, () =&gt; &#123; value -= 16; &#125;);actionState.SetName(&quot;增加了16&quot;);actionState.Subscribe();//State可以多次调用//但是请【不要】在注册之后修改State，否则会对前面的操作有影响actionState.Subscribe();actionState.Subscribe();//注册Command操作和其回退操作var commandState = recorderModule.AllocateCommand().SetCommand(new AddValueCommand(), new SubValueCommand());commandState.SetName(&quot;增加了1&quot;);commandState.Subscribe();//注册Action一组操作和其回退操作var actionGroupState =     recorderModule.AllocateActionGroup()    .SetGroupCommand(() =&gt; &#123; value += 1; &#125;, () =&gt; &#123; value -= 1; &#125;)    .SetGroupCommand(() =&gt; &#123; value += 2; &#125;, () =&gt; &#123; value -= 2; &#125;)actionGroupState.SetName(&quot;增加了3&quot;);actionGroupState.Subscribe();Log.L(value);//撤销操作 返回值为是否撤销成功bool bo = recorderModule.Undo();Log.L(value);//反撤销操作 返回值为是否反撤销成功bool bo = recorderModule.Redo();Log.L(value);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-IFramework-模块-消息模块</title>
      <link href="/2023/07/24/Doc/IFramework/5-IFramework-%E6%A8%A1%E5%9D%97-%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework/5-IFramework-%E6%A8%A1%E5%9D%97-%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><blockquote><p>A:回复T即可退订<br><br>B:T<br><br>A:回复T即可退订<br><br>B:T即可<br><br>A:退订成功</p></blockquote><p>消息是软件开发中减少模块耦合的有效方式</p><p>模块特点:</p><ul><li>支持流量控制</li><li>支持子类型匹配(根据子类型监听父类型)</li><li>支持异步等待</li><li>支持消息优先级</li></ul><p>使用示例:</p><pre><code class="csharp">//需要监听的类public interface IPub &#123; &#125;public class Pub : IPub &#123; &#125;//自定义监听器类 public class Listener : IMessageListener&#123;    public Listener()    &#123;        //构造函数，在这里可以直接写对某个类型的监听    &#125;    //实现接口里的消息回调方法    public void Listen(IMessage message)    &#123;        Log.L($&quot;收到类型为&#123;message.subject&#125;的消息，消息值为&#123;message.code&#125;&quot;);    &#125;&#125;//获取消息模块messageModule = Framework.GetEnv(EnvironmentType.Ev0).modules.Message;//匹配子类型开关messageModule.fitSubType = true;//每帧处理的消息量messageModule.processesPerFrame = 1;//实例化一个消息监听器Listener listenner = new Listener(); //根据IPub监听messageModule.Subscribe&lt;IPub&gt;(listenner);//发送一条重要程度为Important的消息，消息值为100messageModule.Publish&lt;Pub&gt;(null,MessageUrgencyType.Important).SetCode(100);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-IFramework-模块-协程模块</title>
      <link href="/2023/07/24/Doc/IFramework/6-IFramework-%E6%A8%A1%E5%9D%97-%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework/6-IFramework-%E6%A8%A1%E5%9D%97-%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>更好地利用线程资源</p><p>模块特点:</p><ul><li>支持多种等待时间延迟执行</li><li>支持多种等待判断</li><li>支持快速结束某个协程</li><li>支持异步等待</li></ul><p>使用示例:</p><pre><code class="csharp">//tip:环境的Update需要定时执行//获取协程模块coroutineModule = Framework.GetEnv(EnvironmentType.Ev0).modules.Coroutine;//开启协程WaitExamplecoroutineModule.StartCoroutine(WaitExample());IEnumerator WaitExample()&#123;    Log.L(&quot;协程WaitExample开始&quot;);    yield return new WaitForFrame();    Log.L(&quot;一帧过去了&quot;);    yield return new WaitForFrames(20);    Log.L(&quot;20帧过去了&quot;);    yield return new WaitForHours(0.0004);    Log.L(&quot;0.0004小时过去了&quot;);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-IFramework-模块-计时器模块</title>
      <link href="/2023/07/24/Doc/IFramework/8-IFramework-%E6%A8%A1%E5%9D%97-%E8%AE%A1%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework/8-IFramework-%E6%A8%A1%E5%9D%97-%E8%AE%A1%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="计时器模块"><a href="#计时器模块" class="headerlink" title="计时器模块"></a>计时器模块</h1>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-IFramework-模块-依赖注入模块</title>
      <link href="/2023/07/24/Doc/IFramework/7-IFramework-%E6%A8%A1%E5%9D%97-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework/7-IFramework-%E6%A8%A1%E5%9D%97-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>放什么拿什么</p><p>特点:</p><ul><li>支持直接注入和反射注入</li><li>支持根据name注入同类型的多个实例</li></ul><p>直接注入使用示例:</p><pre><code class="csharp">public interface ICommonInjectObject&#123;    void ToDo();&#125;public class CommonObject : ICommonInjectObject&#123;    public void ToDo()    &#123;        //Do sth    &#125;&#125;//获取容器container = Framework.GetEnv(EnvironmentType.Ev0).container;//往容器中注册实例container.SubscribeInstance&lt;ICommonInjectObject&gt;(new CommonObject());//获取实例var _commonObject = container.GetValue&lt;ICommonInjectObject&gt;();//通过name区分来注册多个同类型实例container.SubscribeInstance&lt;ICommonInjectObject&gt;(new CommonObject(), &quot;Instance1&quot;);//根据name获取指定类型的实例_commonObject = container.GetValue&lt;ICommonInjectObject&gt;(&quot;Instance1&quot;);//使用容器的Clear方法清除当前所有注入的实例container.Clear();</code></pre><hr><p><em><strong>反射注入强调性能之处慎用</strong></em></p><p>反射注入使用示例:</p><pre><code class="csharp">public interface IReflectInjectObject&#123;    void ToDo();&#125;public class ReflectObject : IReflectInjectObject&#123;    public void ToDo()    &#123;        //Do sth    &#125;&#125;//使用Inject这个Attribute标记需要反射注入的变量[Inject]public IReflectInjectObject _reflectObject;//Attribute增加name属性[Inject(&quot;Instance1&quot;)]public IReflectInjectObject _reflectMultiObject1; //以IReflectInjectObject的名义注入ReflectObject类型container.Subscribe&lt;IReflectInjectObject, ReflectObject&gt;();container.Subscribe&lt;IReflectInjectObject, ReflectObject&gt;(&quot;Instance1&quot;);//为当前类的含有[Inject]这个Attribute的对应类型的变量注入数据container.Inject(this);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-IFramework-模块-自定义模块</title>
      <link href="/2023/07/24/Doc/IFramework/9-IFramework-%E6%A8%A1%E5%9D%97-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/07/24/Doc/IFramework/9-IFramework-%E6%A8%A1%E5%9D%97-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h1><p>自己造轮子</p><p>特点:</p><ul><li>自己定义一个符合框架生命周期的模块</li></ul><p>使用示例:</p><pre><code class="csharp">//继承UpdateModule创建一个自定义模块private class MyModule : IFramework.Modules.UpdateModule&#123;    protected override void Awake()    &#123;        Log.L(&quot;Awake&quot;);    &#125;    protected override void OnEnable()    &#123;        Log.L(&quot;OnEnable&quot;);    &#125;    protected override void OnUpdate()    &#123;        Log.L(&quot;OnUpdate&quot;);    &#125;    protected override void OnDisable()    &#123;        Log.L(&quot;OnDisable&quot;);    &#125;    public void Do()    &#123;        //Do sth    &#125;    protected override void OnDispose()    &#123;        Log.L(&quot;OnDispose&quot;);    &#125;&#125;//获取模块容器IModules moduleContainer= Framework.GetEnv(EnvironmentType.Ev0).modules;//创建模块实例moduleContainer.CreateModule&lt;MyModule&gt;();//获取模块实例//也可以使用GetModule在没有实例的时候自动创建实例var module = moduleContainer.FindModule&lt;MyModule&gt;();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> IFramework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IFramework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI-适配</title>
      <link href="/2023/07/14/Unity/UGUI/UGUI-%E9%80%82%E9%85%8D/"/>
      <url>/2023/07/14/Unity/UGUI/UGUI-%E9%80%82%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="分辨率适配"><a href="#分辨率适配" class="headerlink" title="分辨率适配"></a>分辨率适配</h1><pre><code class="csharp">/// CanvasScaler 设置为Scale with Screen Sizepublic void FitScreen(CanvasScaler scaler)&#123;    var width = (float) Screen.width;    var height = (float) Screen.height;    var percent = width / height;    var min = 0.48f; //1125*2346    var max = 0.75f; //768*1024    var length = max - min;    percent = (percent - min) / length;    scaler.matchWidthOrHeight = percent;&#125;</code></pre><h1 id="刘海屏"><a href="#刘海屏" class="headerlink" title="刘海屏"></a>刘海屏</h1><p>做一个空物体，如下图布局，挂脚本，要是配的放这个空物体下边<br><img src="/../../../Pic/Unity/UGUI/Ugui%E5%88%98%E6%B5%B7%E5%B1%8F%E9%80%82%E9%85%8D.png" alt="Alt text"></p><pre><code class="csharp">[RequireComponent(typeof(RectTransform))]public class UINotch : MonoBehaviour&#123;    private RectTransform rectTransform;    private void Awake()    &#123;        rectTransform = GetComponent&lt;RectTransform&gt;();    &#125;    private void Start()    &#123;        NotchUISafeAreaSize(rectTransform);    &#125;    public static void NotchUISafeAreaSize(RectTransform transform)    &#123;        Rect safeArea = Screen.safeArea;        //下边        &#123;            float offset = safeArea.yMin;            float ratio = offset / Screen.height;            offset = transform.rect.height * ratio;            transform.offsetMin = new Vector2(transform.offsetMin.x, offset);        &#125;        //上边        &#123;            float offset = Screen.height - safeArea.yMax;            float ratio = offset / Screen.height;            offset = transform.rect.height * ratio;            transform.offsetMax = new Vector2(transform.offsetMax.x, -offset);        &#125;        //左边        &#123;            float offset = safeArea.xMin;            float ratio = offset / Screen.width;            offset = transform.rect.width * ratio;            transform.offsetMin = new Vector2(offset, transform.offsetMin.y);        &#125;        //右边        &#123;            float offset = Screen.width - safeArea.xMax;            float ratio = offset / Screen.width;            offset = transform.rect.width * ratio;            transform.offsetMax = new Vector2(-offset, transform.offsetMax.y);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI优化-动态图集</title>
      <link href="/2023/07/10/Unity/UGUI/%E4%BC%98%E5%8C%96/UGUI%E4%BC%98%E5%8C%96-%E5%8A%A8%E6%80%81%E5%9B%BE%E9%9B%86/"/>
      <url>/2023/07/10/Unity/UGUI/%E4%BC%98%E5%8C%96/UGUI%E4%BC%98%E5%8C%96-%E5%8A%A8%E6%80%81%E5%9B%BE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="主意"><a href="#主意" class="headerlink" title="主意"></a>主意</h1><p>Graphics.CopyTexture 貌似只能图片格式是RGBA32</p><p>不能这个格式就读写像素</p><pre><code class="csharp">    public RawImage raw;    class Content    &#123;        public Rect rect;        private Page root;        List&lt;Page&gt; work = new List&lt;Page&gt;();        List&lt;Page&gt; empty = new List&lt;Page&gt;();        public Content(Rect rect)        &#123;            this.rect = rect;            work = new List&lt;Page&gt;() &#123;                new Page()                &#123;                    rect=rect,                &#125;            &#125;;            root = work[0];        &#125;        private List&lt;Page&gt; success = new List&lt;Page&gt;();        private void Split(Rect rect, Vector2 size, Vector2 smallest)        &#123;            float x = rect.width - size.x;            float y = rect.height - size.y;            var page1 = new Page();            var page2 = new Page();            if (x &lt; smallest.x &amp;&amp; y &gt; smallest.y)            &#123;                page1.rect = new Rect(rect.x + size.x, rect.y, x, size.y);                page2.rect = new Rect(rect.x, rect.y + size.y, rect.width, y);            &#125;            else            &#123;                page1.rect = new Rect(rect.x + size.x, rect.y, x, rect.height);                page2.rect = new Rect(rect.x, rect.y + size.y, size.x, y);            &#125;            empty.Add(page1);            empty.Add(page2);        &#125;        public Page RealAdd(Page page, Vector2 size, Vector2 smallest)        &#123;            work.Remove(page);            Page page0 = new Page()            &#123;                rect = new Rect(page.rect.position, size)            &#125;;            work.Add(page0);            Split(page.rect, size, smallest);            return page0;        &#125;        public static bool Try(Page page, Vector2 size)        &#123;            if (page.rect.size.x &lt; size.x || page.rect.height &lt; size.y)                return false;            return true;        &#125;        public Page Add(Vector2 size, Vector2 smallest)        &#123;            if (rect.size.x &lt; size.x || rect.height &lt; size.y)                return null;            if (root != null)            &#123;                if (Try(root, size))                &#123;                    Page p = RealAdd(root, size, smallest);                    root = null;                    return p;                &#125;                return null;            &#125;            else            &#123;                for (int i = 0; i &lt; empty.Count; i++)                &#123;                    Page page = empty[i];                    if (Try(page, size))                    &#123;                        success.Add(page);                    &#125;                &#125;                if (success.Count &gt; 0)                &#123;                    success.Sort((a, b) =&gt; &#123; return a.rect.size.x * a.rect.size.y &lt; b.rect.size.x * b.rect.size.y ? -1 : 1; &#125;);                    Page p = RealAdd(success[0], size, smallest);                    success.Clear();                    return p;                &#125;                return null;            &#125;        &#125;    &#125;    class Page    &#123;        public Rect rect;    &#125;    public void GG(Image[] images)    &#123;        var dic = images.ToDictionary(x =&gt; x.sprite);        var sprites = images.ToList().ConvertAll(x =&gt; x.sprite).ToList();        int size = 2048;        Content c = new Content(new Rect(Vector2.zero, Vector2.one * size));        sprites.Sort((a, b) =&gt; &#123; return a.rect.width * a.rect.height &lt; b.rect.width * b.rect.height ? 1 : -1; &#125;);        var last = sprites.Last();        Vector2 smallest = new Vector2(last.rect.width, last.rect.height);        Texture2D tx = new Texture2D(size, size, TextureFormat.RGBA32, false);        raw.texture = tx;        foreach (Sprite item in sprites)        &#123;            Page p = c.Add(new Vector2(item.rect.width, item.rect.height), smallest);            if (p == null) continue;            Graphics.CopyTexture(item.texture, 0, 0,                (int)item.rect.x, (int)item.rect.y, (int)item.rect.width, (int)item.rect.height,                tx, 0, 0, (int)p.rect.x, (int)p.rect.y);            //tx.SetPixels((int)p.rect.x, (int)p.rect.y, (int)item.rect.width, (int)item.rect.height,            //    item.texture.GetPixels());            //tx.Apply();            Rect r = new Rect(item.rect.position + p.rect.position, item.rect.size);            dic[item].sprite = Sprite.Create(tx, r, Vector2.zero);        &#125;    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UGUI合批-优化</title>
      <link href="/2023/07/07/Unity/UGUI/%E4%BC%98%E5%8C%96/UGUI%E5%90%88%E6%89%B9-%E4%BC%98%E5%8C%96/"/>
      <url>/2023/07/07/Unity/UGUI/%E4%BC%98%E5%8C%96/UGUI%E5%90%88%E6%89%B9-%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="触发合批计算（rebuild）"><a href="#触发合批计算（rebuild）" class="headerlink" title="触发合批计算（rebuild）"></a>触发合批计算（rebuild）</h1><ul><li>动态创建UI</li><li>UI材质变化</li><li>UI 网格（Mesh）变化</li><li>UI 位置变化</li><li>UI 颜色变化</li></ul><h1 id="合批规则"><a href="#合批规则" class="headerlink" title="合批规则"></a>合批规则</h1><pre><code>// materialIdimage.material.GetInstanceID()// textureIdimage.mainTexture.GetInstanceID()</code></pre><p>基本条件：材质球(Shader)和贴图要完全相同。</p><ul><li>1、是把所有Canvas给找出来</li><li>2、除掉不必渲染的Canvas(透明度为0，长宽为0，在* RectMask2D控件下，且在RectMask2D的区域外)</li><li>3、计算Canvas下各UI控件的深度值Depth(Image的属* 性里面也有个depth，两者不是同一个东西)</li><li>4、按照Depth值从小到大排序</li><li>5、Depth排完之后，Depth相同的元素再按material * ID从小到大排序</li><li>6、material ID排完之后，material ID相同的元素再* 按texture ID从小到大排序</li><li>7、textrure ID排完之后，textrure ID相同的元素最* 后再按在Hierarchy深度遍历的顺序排序</li><li>8、得到 VisiableList</li><li>9、遍历 VisiableList，只要前后的元素的材质球和贴图相同，就可以合批</li></ul><h2 id="Depth的计算规则"><a href="#Depth的计算规则" class="headerlink" title="Depth的计算规则"></a>Depth的计算规则</h2><ul><li>0、按照 hierarchy 的顺序，深度遍历所有UI元素</li><li>1、选中一个UI元素(CurrentUI)</li><li>2、不渲染，Depth &#x3D; -1</li><li>3、渲染（相交：mesh 相交）<ul><li>3.1、CurrentUI 与前面没有相交，则Depth &#x3D; 0</li><li>3.2、CurrentUI 前面只有一个(LowerUI)与其相交<ul><li>3.2.1、CurrentUI与LowerUI可以合批 CurrentUI.Depth &#x3D; LowerUI.Depth</li><li>3.2.2、CurrentUI与LowerUI不可以合批 CurrentUI.Depth &#x3D; LowerUI.Depth + 1</li></ul></li><li>3.3、CurrentUI与前面有 N个UI相交<ul><li>3.3.1、 重复3.2.1计算出 N 个Depth值</li><li>3.3.2、 CurrentUI.Depth &#x3D; Max(N个Depth值)</li></ul></li></ul></li></ul><h1 id="合批的优化"><a href="#合批的优化" class="headerlink" title="合批的优化"></a>合批的优化</h1><ul><li>减少计算难度<ul><li>减小 Hierarchy 深度&#x2F;复杂度：深度遍历，计算次数</li></ul></li><li>减少计算次数<ul><li>动静分离</li><li>避免频繁删除&#x2F;增加UI对象，UI层次结构变化会引起Canvas的更新(rebuild)</li><li>Text如果可以用图片代替就用图片代替</li><li>Text避免或者降低赋值的操作</li><li>显示隐藏</li><li>对于单个UI可以设置GetComponent&lt; CanvasRenderer &gt;().cull来控制</li><li>而多个UI可以通过父物体挂上CanvasGroup，修改Alpha值来控制</li></ul></li><li>尽可能不打断合批</li><li>使用图集</li><li>尽量不要使用Mask（其内部使用了模板缓冲，至少会造成增加2个Draw Call）</li><li>动态图集，一个界面的可以放一起</li><li>保证UI顺序结构合理</li><li>减少 UI 不同图集或材质的倾轧</li></ul><h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><ul><li>Raycast</li><li>减少填充率<ul><li>不需要绘制的图片（只接受点击）</li><li>Image的 fillcenter 属性</li></ul></li><li>避免使用LayOut</li><li>避免使用outLine和shadow，用TextMesh Pro代替</li><li>避免使用BestFit</li><li>RichText会造成三角面增加</li><li>Screen Space 和 World Space 中的Camera必须要指定</li></ul>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-WooBind-例子</title>
      <link href="/2023/07/05/Doc/WooBind/1-WooBind-%E6%A1%88%E4%BE%8B/"/>
      <url>/2023/07/05/Doc/WooBind/1-WooBind-%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="单向绑定（数据监听）"><a href="#单向绑定（数据监听）" class="headerlink" title="单向绑定（数据监听）"></a>单向绑定（数据监听）</h2><ul><li>特点：<ul><li>监听单个值的变化</li></ul></li><li>单向绑定使用示例:</li></ul><pre><code class="csharp">//监听的类需要继承ObservableObjectclass Observable_A : ObservableObject&#123;    private int _value;    public int value    &#123;        get        &#123;            return GetProperty(ref _value);        &#125;        set        &#123;            SetProperty(ref _value, value);        &#125;    &#125;&#125;//创建一个监听器ObservableObjectHandler binder = new ObservableObjectHandler();//创建监听的实例Observable_A observedA = new Observable_A();//监听valuebinder.BindProperty(    (value) =&gt;    &#123;        observedA.value = value;        Log.L($&quot;值被改变，新值为&#123;value&#125;&quot;);    &#125;,    () =&gt;    &#123;        return observedA.value;    &#125;);observedA.value = 1;observedA.value = 2;//观察控制台的输出</code></pre><h2 id="多向绑定（数据同步变化）"><a href="#多向绑定（数据同步变化）" class="headerlink" title="多向绑定（数据同步变化）"></a>多向绑定（数据同步变化）</h2><ul><li>特点：<ul><li>多个绑定，值同步变化</li></ul></li><li>多向绑定使用示例:</li></ul><pre><code class="csharp">  //监听的类需要继承BindableObjectclass Binder_A : BindableObject&#123;    private int _value;    public int value &#123; get &#123; return GetProperty(ref _value); &#125; set &#123; SetProperty(ref _value, value); &#125; &#125;&#125;class Binder_B : BindableObject&#123;    private int _value;    public int value &#123; get &#123; return GetProperty(ref _value); &#125; set &#123; SetProperty(ref _value, value); &#125; &#125;&#125;class Binder_C : BindableObject&#123;    private int _value;    public int value &#123; get &#123; return GetProperty(ref _value); &#125; set &#123; SetProperty(ref _value, value); &#125; &#125;&#125;//创建监听器BindableObjectHandler binder = new BindableObjectHandler();//创建实例Binder_A a = new Binder_A();Binder_B b = new Binder_B();Binder_C c = new Binder_C();//绑定binder.BindProperty((value) =&gt; &#123; a.value = value; &#125;, () =&gt; &#123; return a.value; &#125;);binder.BindProperty((value) =&gt; &#123; b.value = value; &#125;, () =&gt; &#123; return b.value; &#125;);binder.BindProperty((value) =&gt; &#123; c.value = value; &#125;, () =&gt; &#123; return c.value; &#125;);Log.L($&quot;a的value值为&#123;a.value&#125;\tb的value值为&#123;b.value&#125;\tc的value值为&#123;c.value&#125;\n&quot;);a.value = 1;Log.L($&quot;a的value值为&#123;a.value&#125;\tb的value值为&#123;b.value&#125;\tc的value值为&#123;c.value&#125;\n&quot;);c.value = 2;Log.L($&quot;a的value值为&#123;a.value&#125;\tb的value值为&#123;b.value&#125;\tc的value值为&#123;c.value&#125;\n&quot;);  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooBind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooBind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-WooBind-案例</title>
      <link href="/2023/07/05/Doc/WooBind/2-WooBind-%E6%96%87%E6%A1%A3/"/>
      <url>/2023/07/05/Doc/WooBind/2-WooBind-%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="ObservableObject"><a href="#ObservableObject" class="headerlink" title="ObservableObject"></a>ObservableObject</h1><h2 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h2><ul><li>Subscribe函数用于注册数值变化的监听函数。当属性发生变化时，会触发已注册的监听函数。具体使用方式如下：</li></ul><pre><code class="csharp">public void Subscribe(string propertyName, Action listener)</code></pre><ul><li>propertyName：要监听的属性名称。</li><li>listener：监听函数，当属性变化时被调用。</li></ul><pre><code class="csharp">Subscribe(&quot;Name&quot;, () =&gt;&#123;    Console.WriteLine(&quot;属性Name发生了变化！&quot;);&#125;);</code></pre><h2 id="UnSubscribe"><a href="#UnSubscribe" class="headerlink" title="UnSubscribe"></a>UnSubscribe</h2><ul><li>UnSubscribe函数用于取消注册数值变化的监听函数。如果之前通过Subscribe函数注册了一个或多个监听函数，但后来不再需要监听，则可以通过UnSubscribe函数进行取消注册。具体使用方式如下：</li></ul><pre><code class="csharp">public void UnSubscribe(string propertyName, Action listener)</code></pre><ul><li>propertyName：要取消监听的属性名称。</li><li>listener：要取消的监听函数。</li></ul><pre><code class="csharp">UnSubscribe(&quot;Name&quot;, () =&gt;&#123;    Console.WriteLine(&quot;属性Name发生了变化！&quot;);&#125;);</code></pre><h2 id="GetProperty"><a href="#GetProperty" class="headerlink" title="GetProperty"></a>GetProperty</h2><pre><code class="csharp">protected T GetProperty&lt;T&gt;(ref T property, [CallerMemberName]string propertyName = &quot;&quot;)</code></pre><ul><li><p>T：属性值的类型。</p></li><li><p>property：表示要获取的属性的变量的引用。</p></li><li><p>propertyName：表示属性的名称，默认值为调用该方法的成员的名称（通过[CallerMemberName]属性实现）。</p></li><li><p>GetProperty函数用于获取属性的值。它接收一个属性变量的引用以及可选的属性名称。如果使用可选的属性名称参数，则可以在调用时指定属性的名称，例如GetProperty(ref myVariable, “MyProperty”)；如果不提供属性名称参数，则默认使用调用该方法的成员的名称作为属性的名称。该函数会返回属性的当前值。</p></li></ul><h2 id="SetProperty"><a href="#SetProperty" class="headerlink" title="SetProperty"></a>SetProperty</h2><h2 id="GetProperty-1"><a href="#GetProperty-1" class="headerlink" title="GetProperty"></a>GetProperty</h2><pre><code class="csharp">protected void SetProperty&lt;T&gt;(ref T property, T value, [CallerMemberName]string propertyName = &quot;&quot;)</code></pre><ul><li>T：属性值的类型。</li><li>property：表示要设置的属性的变量的引用。</li><li>value：表示要设置的属性的新值。</li><li>propertyName：表示属性的名称，默认值为调用该方法的成员的名称（通过[CallerMemberName]属性实现）。</li><li>SetProperty函数用于设置属性的值。它接收一个属性变量的引用、新的属性值以及可选的属性名称。如果使用可选的属性名称参数，则可以在调用时指定属性的名称，例如SetProperty(ref myVariable, newValue, “MyProperty”)；如果不提供属性名称参数，则默认使用调用该方法的成员的名称作为属性的名称。该函数会更新属性的值，并在值发生变化时发布属性更改通知。</li></ul><h1 id="ObservableObjectHandler"><a href="#ObservableObjectHandler" class="headerlink" title="ObservableObjectHandler"></a>ObservableObjectHandler</h1><h2 id="Subscribe-1"><a href="#Subscribe-1" class="headerlink" title="Subscribe"></a>Subscribe</h2><pre><code class="csharp">internal ObservableObjectHandler Subscribe(ObservableObject _object, string propertyName)</code></pre><ul><li><p>ObservableObjectHandler：方法的返回类型为 ObservableObjectHandler，表示该方法将返回一个可观察对象处理器的实例。这个处理器可以用来管理和控制属性变化的监听。</p></li><li><p>_object：ObservableObject 类型的参数 _object 是要订阅的可观察对象实例。你可以将你感兴趣的可观察对象传递给该参数。</p></li><li><p>propertyName：string 类型的参数 propertyName 是要订阅的属性名称。你可以指定你希望监听的特定属性的名称。</p></li></ul><pre><code class="csharp">  public ObservableObjectHandler Subscribe(ObservableObject _object, string propertyName, Action listener)</code></pre><ul><li>listener：Action 类型的参数 listener 是一个回调函数，表示在属性变化时要执行的操作。你可以将你希望在属性变化时执行的逻辑封装在这个回调函数中，例如更新 UI、执行其他方法等。</li></ul><h2 id="UnSubscribe-1"><a href="#UnSubscribe-1" class="headerlink" title="UnSubscribe()"></a>UnSubscribe()</h2><pre><code class="csharp"> public void UnSubscribe()</code></pre><ul><li>取消所有监听</li></ul><pre><code class="csharp">public void UnSubscribe(ObservableObject _object, string propertyName)</code></pre><ul><li>取消符合条件的监听</li></ul><h1 id="BindableObject"><a href="#BindableObject" class="headerlink" title="BindableObject"></a>BindableObject</h1><h2 id="Subscribe-2"><a href="#Subscribe-2" class="headerlink" title="Subscribe"></a>Subscribe</h2><pre><code class="csharp">public void Subscribe(string propertyName, Action&lt;string, object&gt; listener)</code></pre><ul><li><p>注册监听器，订阅属性变化事件。</p></li><li><p>propertyName：要监听的属性名称。</p></li><li><p>listener：当属性变化时要执行的回调方法。</p></li></ul><h2 id="UnSubscribe-2"><a href="#UnSubscribe-2" class="headerlink" title="UnSubscribe"></a>UnSubscribe</h2><pre><code class="csharp">public void UnSubscribe(string propertyName, Action&lt;string, object&gt; listener)</code></pre><ul><li><p>移除监听器，取消订阅属性变化事件。</p></li><li><p>propertyName：要取消监听的属性名称。</p></li><li><p>listener：要移除的监听器回调方法。</p></li></ul><h1 id="Subscribe-3"><a href="#Subscribe-3" class="headerlink" title="Subscribe"></a>Subscribe</h1><pre><code class="csharp">internal BindableObjectHandler Subscribe(BindableObject _object, Type propertyType, string propertyName)</code></pre><ul><li>用于订阅对象的属性变化。</li><li>_object：需要订阅属性变化的对象。</li><li>propertyType：属性的数据类型，用于指定要订阅的属性的类型。</li><li>propertyName：要订阅的属性名称。</li></ul><h1 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h1><pre><code class="csharp">public T GetValue&lt;T&gt;(string name)public object GetValue(Type type,string name)</code></pre><ul><li>用于获取指定名称的属性值</li></ul><h1 id="PublishProperty"><a href="#PublishProperty" class="headerlink" title="PublishProperty"></a>PublishProperty</h1><pre><code class="csharp">   public BindableObjectHandler PublishProperty(Type type,object value, string propertyName)   public BindableObjectHandler PublishProperty&lt;T&gt;(T value, string propertyName)</code></pre><ul><li>用于发布属性的变化，通知所有订阅了该属性的监听者。</li></ul><h1 id="UnBind"><a href="#UnBind" class="headerlink" title="UnBind"></a>UnBind</h1><pre><code class="csharp">public void UnBind()public void UnBind(BindableObject _object)public void UnBind(string propertyName)public void UnBind(BindableObject _object, string propertyName)public void UnBind(BindableObject _object, Type type, string propertyName)</code></pre><ul><li>解绑全部绑定的属性。</li><li>按照对象解绑属性。</li><li>按照属性名称解绑属性。</li><li>按照对象和属性名称解绑属性。</li><li>按照对象、属性类型和属性名称解绑属性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooBind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooBind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-WooBind-简介</title>
      <link href="/2023/07/05/Doc/WooBind/0-WooBind-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/05/Doc/WooBind/0-WooBind-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>是一款用于数据绑定插件</li><li>可以帮助开发者实现数据监听和多向数据同步变化</li><li>你可以轻松地在不同的对象之间建立数据绑定关系，以实现数据的自动同步更新</li></ul><h2 id="提供两种数据绑定"><a href="#提供两种数据绑定" class="headerlink" title="提供两种数据绑定"></a>提供两种数据绑定</h2><ul><li><p>单向绑定（数据监听）：通过监听单个值的变化，当被监听的值发生变化时，可以触发回调函数进行相应的处理。这种绑定适用于需要在特定情况下对数据进行响应式处理的场景。</p></li><li><p>多向绑定（数据同步变化）：通过建立多个绑定关系，当任意一个被绑定的值发生变化时，其他所有绑定的值也会自动更新到最新值。这种绑定适用于需要多个对象之间实现数据同步的场景。</p></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>WooBind 插件简化了数据绑定的过程，让开发者能够更加方便地处理数据的变化和同步。无论是单向绑定还是多向绑定，WooBind 都为开发者提供了一个可靠和高效的数据绑定解决方案。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooBind </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooBind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-WooSerialization-简介</title>
      <link href="/2023/07/05/Doc/WooSerialization/0-WooSerialization-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/07/05/Doc/WooSerialization/0-WooSerialization-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ul><li>json 序列化与反序列化 支持多种数据转换</li><li>csv文件读写</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooSerialization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooSerialization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆形图片毛边处理</title>
      <link href="/2023/07/03/Unity/UGUI/%E6%95%88%E6%9E%9C/%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%E6%AF%9B%E8%BE%B9%E5%A4%84%E7%90%86/"/>
      <url>/2023/07/03/Unity/UGUI/%E6%95%88%E6%9E%9C/%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%E6%AF%9B%E8%BE%B9%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">using System.Collections.Generic;using UnityEngine;using UnityEngine.Sprites;using UnityEngine.UI;public class CircleImage : Image&#123;    /// &lt;summary&gt;    ///圆形由多少块三角形拼成即圆形精度，值越大精度越高    /// &lt;/summary&gt;    [SerializeField]    private int segements = 100;    /// &lt;summary&gt;    /// 显示部分占圆形的百分比.    /// &lt;/summary&gt;    [SerializeField]    private float showPercent = 1f;    private readonly Color32 GRAY_COLOR = new Color32(60, 60, 60, 255);    private List&lt;Vector3&gt; _vertexList;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        vh.Clear();        _vertexList = new List&lt;Vector3&gt;();        AddVertex(vh, segements);        AddTriangle(vh, segements);    &#125;    private void AddVertex(VertexHelper vh, int segements)    &#123;        float width = rectTransform.rect.width;        float heigth = rectTransform.rect.height;        int realSegments = (int)(segements * showPercent);        //四维向量可代表着二维平面的四个坐标（uv.x,uv.y）,(uv.z,uv.y),(uv.x,uv.w)(uv.z,uv.w)        Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;        float uvWidth = uv.z - uv.x;        float uvHeight = uv.w - uv.y;        //获取贴图uv平面中心点        Vector2 uvCenter = new Vector2(uvWidth * 0.5f, uvHeight * 0.5f);        Vector2 convertRatio = new Vector2(uvWidth / width, uvHeight / heigth);        float radian = (2 * Mathf.PI) / segements;        float radius = width * 0.5f;        //轴心点设置        Vector2 originPos = new Vector2((0.5f - rectTransform.pivot.x) * width, (0.5f - rectTransform.pivot.y) * heigth);        Vector2 vertPos = Vector2.zero;        Color32 colorTemp = GetOriginColor();        UIVertex origin = GetUIVertex(colorTemp, originPos, vertPos, uvCenter, convertRatio);        vh.AddVert(origin);        int vertexCount = realSegments + 1;        float curRadian = 0;        Vector2 posTermp = Vector2.zero;        //遍历所有顶点信息        for (int i = 0; i &lt; segements + 1; i++)        &#123;            float x = Mathf.Cos(curRadian) * radius;            float y = Mathf.Sin(curRadian) * radius;            curRadian += radian;            if (i &lt; vertexCount)            &#123;                colorTemp = color;            &#125;            else            &#123;                colorTemp = GRAY_COLOR;            &#125;            posTermp = new Vector2(x, y);            UIVertex vertexTemp = GetUIVertex(colorTemp, posTermp + originPos, posTermp, uvCenter, convertRatio);            vh.AddVert(vertexTemp);            _vertexList.Add(posTermp + originPos);        &#125;    &#125;    /// &lt;summary&gt;    /// 设置颜色比重    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private Color32 GetOriginColor()    &#123;        Color32 colorTemp = (Color.white - GRAY_COLOR) * showPercent;        return new Color32(            (byte)(GRAY_COLOR.r + colorTemp.r),            (byte)(GRAY_COLOR.g + colorTemp.g),            (byte)(GRAY_COLOR.b + colorTemp.b),            255);    &#125;    private void AddTriangle(VertexHelper vh, int realSegements)    &#123;        int id = 1;        for (int i = 0; i &lt; realSegements; i++)        &#123;            vh.AddTriangle(id, 0, id + 1);//顺时针生成面片            id++;        &#125;    &#125;    private UIVertex GetUIVertex(Color32 col, Vector3 pos, Vector2 uvPos, Vector2 uvCenter, Vector2 uvScale)    &#123;        UIVertex vertexTemp = new UIVertex();        vertexTemp.color = col;        vertexTemp.position = pos;        vertexTemp.uv0 = new Vector2(uvPos.x * uvScale.x + uvCenter.x, uvPos.y * uvScale.y + uvCenter.y);        return vertexTemp;    &#125;    //设置图形的点击响应区域    public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Vector2 localPoint;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out localPoint);        return IsValid(localPoint);    &#125;    private bool IsValid(Vector2 localPoint)    &#123;        return GetCrossPointNum(localPoint, _vertexList) % 2 == 1;    &#125;    /// &lt;summary&gt;    /// 获取该点与图形区域相交点的数量 奇数表示在区域内 偶数表示在区域外    /// &lt;/summary&gt;    /// &lt;param name=&quot;localPoint&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertexList&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private int GetCrossPointNum(Vector2 localPoint, List&lt;Vector3&gt; vertexList)    &#123;        int count = 0;        Vector3 vert1 = Vector3.zero;        Vector3 vert2 = Vector3.zero;        int vertCount = vertexList.Count;        for (int i = 0; i &lt; vertCount; i++)        &#123;            vert1 = vertexList[i];            vert2 = vertexList[(i + 1) % vertCount];            if (IsYInRang(localPoint, vert1, vert2))            &#123;                if (localPoint.x &lt; GetX(vert1, vert2, localPoint.y))                &#123;                    count++;                &#125;            &#125;        &#125;        return count;    &#125;    //筛选     private bool IsYInRang(Vector2 localPoint, Vector3 vert1, Vector3 vert2)    &#123;        //该点y值是否在两点y值之间        if (vert1.y &gt; vert2.y)        &#123;            return localPoint.y &lt; vert1.y &amp;&amp; localPoint.y &gt; vert2.y;        &#125;        else        &#123;            return localPoint.y &lt; vert2.y &amp;&amp; localPoint.y &gt; vert1.y;        &#125;    &#125;    //两点求一直线再带入y值得出x值    private float GetX(Vector3 vert1, Vector3 vert2, float y)    &#123;        float k = (vert1.y - vert2.y) / (vert1.x - vert2.x);        return vert1.x + (y - vert1.y) / k;//vert2.x + (y - vert2.y)    &#125;&#125;</code></pre><pre><code class="csharp">//Editor文件下属性设置类using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;[CustomEditor(typeof(CircleImage), true)][CanEditMultipleObjects]public class CircleImageEditor : UnityEditor.UI.ImageEditor&#123;    SerializedProperty _fillPercent;    SerializedProperty _segements;    protected override void OnEnable()    &#123;        base.OnEnable();        _fillPercent = serializedObject.FindProperty(&quot;showPercent&quot;);        _segements = serializedObject.FindProperty(&quot;segements&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        base.OnInspectorGUI();        serializedObject.Update();        EditorGUILayout.Slider(_fillPercent, 0, 1, new GUIContent(&quot;显示比率&quot;));        EditorGUILayout.PropertyField(_segements, new GUIContent(&quot;显示精度&quot;));        serializedObject.ApplyModifiedProperties();        if (GUI.changed)        &#123;            EditorUtility.SetDirty(target);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持超链接的Text</title>
      <link href="/2023/07/03/Unity/UGUI/%E6%95%88%E6%9E%9C/%E6%94%AF%E6%8C%81%E8%B6%85%E9%93%BE%E6%8E%A5%E7%9A%84Text/"/>
      <url>/2023/07/03/Unity/UGUI/%E6%95%88%E6%9E%9C/%E6%94%AF%E6%8C%81%E8%B6%85%E9%93%BE%E6%8E%A5%E7%9A%84Text/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">using System;using System.Collections.Generic;using System.Text;using System.Text.RegularExpressions;using UnityEngine;using UnityEngine.Events;using UnityEngine.EventSystems;using UnityEngine.UI;/// &lt;summary&gt;/// 文本控件,支持超链接/// &lt;/summary&gt;public class HyperlinkText : Text, IPointerClickHandler&#123;    /// &lt;summary&gt;    /// 超链接类    /// &lt;/summary&gt;    private class HyperlinkInfo    &#123;        /// &lt;summary&gt;        /// 超链接的字符串的开始字符的第一个顶点的索引        /// &lt;/summary&gt;        public int startIndex;        /// &lt;summary&gt;        /// 超链接的字符串的最后字符的最后一个顶点的索引        /// &lt;/summary&gt;        public int endIndex;        public string linkUrl;        /// &lt;summary&gt;        /// 超链接的覆盖区域        /// &lt;/summary&gt;        public readonly List&lt;Rect&gt; textValidAreas = new List&lt;Rect&gt;();    &#125;    /// &lt;summary&gt;    /// 解析完最终的文本    /// &lt;/summary&gt;    private string colorAddedStr;    /// &lt;summary&gt;    /// 超链接信息列表    /// &lt;/summary&gt;    private readonly List&lt;HyperlinkInfo&gt; hrefInfos = new List&lt;HyperlinkInfo&gt;();    /// &lt;summary&gt;    /// 文本构造器    /// &lt;/summary&gt;    protected static readonly StringBuilder textRebuild = new StringBuilder();    [Serializable]    public class HrefClickEvent : UnityEvent&lt;string&gt; &#123; &#125;    [SerializeField]    private HrefClickEvent onHrefClickCB = new HrefClickEvent();    /// &lt;summary&gt;    /// 超链接点击事件    /// &lt;/summary&gt;    public HrefClickEvent onHrefClick    &#123;        get &#123; return onHrefClickCB; &#125;        set &#123; onHrefClickCB = value; &#125;    &#125;    /// &lt;summary&gt;    /// 每个字符的面片有4个顶点    /// &lt;/summary&gt;    const int perCharVerCount = 4;    const string pattern = @&quot;&lt;a href=([^&gt;\n\s]+)&gt;(.*?)(&lt;/a&gt;)&quot;;    const string colorStartStr = &quot;&lt;color=#01EAFFFF&gt;&quot;;    const string colorEndStr = &quot;&lt;/color&gt;&quot;;    /// &lt;summary&gt;    /// 超链接正则    /// &lt;/summary&gt;    private static readonly Regex s_HrefRegex =        new Regex(pattern, RegexOptions.Singleline);    private HyperlinkText mHyperlinkText;    protected override void Awake()    &#123;        base.Awake();        mHyperlinkText = GetComponent&lt;HyperlinkText&gt;();    &#125;    protected override void OnEnable()    &#123;        base.OnEnable();        mHyperlinkText.onHrefClick.AddListener(OnHyperlinkTextInfo);    &#125;    protected override void OnDisable()    &#123;        base.OnDisable();        mHyperlinkText.onHrefClick.RemoveListener(OnHyperlinkTextInfo);    &#125;    public override void SetVerticesDirty()    &#123;        base.SetVerticesDirty();#if UNITY_EDITOR        if (UnityEditor.PrefabUtility.GetPrefabType(this) == UnityEditor.PrefabType.Prefab)        &#123;            return;        &#125;#endif             colorAddedStr = GetDealedText(text);    &#125;    protected override void OnPopulateMesh(VertexHelper toFill)    &#123;        print(&quot;OnPopulateMesh &quot;);        var orignText = m_Text;        m_Text = colorAddedStr;        base.OnPopulateMesh(toFill);        m_Text = orignText;        //UGUI的网格处理类        UIVertex vert = new UIVertex();        // 重新创建超链接包围框        foreach (var hrefInfo in hrefInfos)        &#123;            hrefInfo.textValidAreas.Clear();            //toFill.currentVertCount表示当前Text组件的所有网格的最后一个网格的顶点索引            //hrefInfo.startIndex大于它 是startIndex大于它运算出错了 运算出错 则跳过包围框生成            if (hrefInfo.startIndex &gt;= toFill.currentVertCount)            &#123;                continue;            &#125;            //获取startIndex所指示的顶点            toFill.PopulateUIVertex(ref vert, hrefInfo.startIndex);            var pos = vert.position;            var bounds = new Bounds(pos, Vector3.zero);            for (int i = hrefInfo.startIndex, m = hrefInfo.endIndex; i &lt; m; i++)            &#123;                if (i &gt;= toFill.currentVertCount)                &#123;                    break;                &#125;                toFill.PopulateUIVertex(ref vert, i);                pos = vert.position;                if (pos.x &lt; bounds.min.x || pos.y &lt; bounds.min.y) // 换行重新添加包围框                &#123;                    hrefInfo.textValidAreas.Add(new Rect(bounds.min, bounds.size));                    bounds = new Bounds(pos, Vector3.zero);                &#125;                else                &#123;                    bounds.Encapsulate(pos); // 扩展包围框                &#125;            &#125;            hrefInfo.textValidAreas.Add(new Rect(bounds.min, bounds.size));        &#125;    &#125;    /// &lt;summary&gt;    /// 生成超链接文本的显示区域矩形和链接信息    /// 用于在点击的时候判断是否点击中了超链接    /// &lt;/summary&gt;    /// &lt;returns&gt;      /// 返回超链接解析后的最后输出文本    /// 即在原字符串的基础上用颜色标签的文本    /// 代替&lt;a href=xx&gt;&lt;\a&gt;这样text组件识别不了的标签&lt;/returns&gt;    protected virtual string GetDealedText(string originText)    &#123;        textRebuild.Clear();        hrefInfos.Clear();        //startIndex表示上次匹配正则的字符串的最后字符的索引+1        //例如这段话        //aa&lt;a href=666&gt;[本篇博客]&lt;/a&gt;aa        //第一次匹配到的字符串是&lt;a href=666&gt;[本篇博客]&lt;/a&gt;        //则它最后的字符在整个字符串的索引是24        //则startIndex在这时候为24+1即倒数第二个a的索引        var matchNextCharIndex = 0;        // 实际显示中 尖括号里面的是不显示的        // 上面那句话里面实际显示的就aa 和[本篇博客]        // 这些字符的最后字符]的索引是8        // 所以actualStartIndex表示的下次匹配的开始索引是9        var actualNextCharIndex = 0;               // 在第一个匹配正则式的字符串之前的字符串        // 或者这次匹配正则式的字符串与        // 上次匹配的字符串之间的字符串        var beforeStr = string.Empty;        //beforeStr的清空所有空白符形式        var beforeStrNoBlank = string.Empty;        //这次匹配到的字符串之前的字符串的最后一个字符的索引        //例如aa&lt;a href=666&gt;[本篇博客]&lt;/a&gt;aa        //第一次匹配的时候 beforeStrLastCharIndex是上面字符串第二个a的索引        var beforeStrLastCharIndex = 0;        // match.Groups[0]是常量pattern字符串匹配到的所有字符串        // match.Groups[1]是常量pattern字符串里面第一个小括号匹配到的字符串        // match.Groups[2]是常量pattern字符串里面第二个小括号匹配到的字符串        // 依次类推        foreach (Match match in s_HrefRegex.Matches(originText))        &#123;            beforeStr = originText.Substring(matchNextCharIndex,                match.Index - matchNextCharIndex);            //将firstStr里面的所有空白符（包括&#39;\n&#39;&#39;\t&#39;&#39; &#39;等）去掉            //这是因为空白字符不参与字体的网格生成              //超链接字符前面空白字符不能纳入超链接的可点击区域计算            //否则生成的点击区域会有问题            beforeStrNoBlank = Regex.Replace(beforeStr, @&quot;\s&quot;, &quot;&quot;);            textRebuild.Append(beforeStr);            textRebuild.Append(colorStartStr);  // 超链接颜色            var url = match.Groups[1];            var hyperText = match.Groups[2];            beforeStrLastCharIndex = (beforeStrNoBlank.Length + actualNextCharIndex);            DebugFunc(actualNextCharIndex, beforeStr, beforeStrNoBlank, match, url);            var hrefInfo = new HyperlinkInfo            &#123;                //因为 后面要根据startIndex和endIndex去获取实际的顶点，如果这两变量                //纳入了空白符的计算 会导致变量偏大，从而获取的顶点是后面的字的顶点                startIndex = beforeStrLastCharIndex * perCharVerCount,                endIndex = (beforeStrLastCharIndex + hyperText.Length ) * perCharVerCount,                linkUrl = url.Value            &#125;;            hrefInfos.Add(hrefInfo);            textRebuild.Append(hyperText.Value);            textRebuild.Append(colorEndStr);            matchNextCharIndex = match.Index + match.Length;            actualNextCharIndex += beforeStrNoBlank.Length + match.Groups[2].Length;        &#125;        //将最后一次匹配之后的字符串加上去        textRebuild.Append(originText.Substring(matchNextCharIndex, originText.Length - matchNextCharIndex));        return textRebuild.ToString();    &#125;    private static void DebugFunc(int actualStartIndex, string beforeStr, string beforeStrNoBlank, Match match, Group group)    &#123;        string str = &quot; HyperlinkText GetOutputText &quot;;        for (int i = 0; i &lt; match.Groups.Count; i++)        &#123;            str += (&quot; match.Groups[i]   &quot; + i + &quot;   &quot; +                   match.Groups[i] + &quot; match.Length &quot; + match.Length + &quot;\n&quot;);        &#125;        print(str + &quot; HyperlinkText GetOutputText  firstStr &quot; + beforeStr +            &quot;   &quot; + match.Groups[2] +            &quot; group.Value &quot; + group.Value +            &quot; actualStartIndex &quot; + actualStartIndex +            &quot;  firstStrNoBlank.Length &quot; + beforeStrNoBlank.Length +            &quot; match.Index &quot; + match.Index);    &#125;    /// &lt;summary&gt;    /// 点击事件检测是否点击到超链接文本    /// &lt;/summary&gt;    /// &lt;param name=&quot;eventData&quot;&gt;&lt;/param&gt;    public void OnPointerClick(PointerEventData eventData)    &#123;        Vector2 lp = Vector2.zero;        //将点击点从屏幕坐标系转换到rectTransform的局部坐标系        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform,            eventData.position, eventData.pressEventCamera, out lp);        foreach (var hrefInfo in hrefInfos)        &#123;            var boxes = hrefInfo.textValidAreas;            for (var i = 0; i &lt; boxes.Count; ++i)            &#123;                if (boxes[i].Contains(lp))                &#123;                    onHrefClickCB.Invoke(hrefInfo.linkUrl);                    return;                &#125;            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// 当前点击超链接回调    /// &lt;/summary&gt;    /// &lt;param name=&quot;info&quot;&gt;回调信息&lt;/param&gt;    private void OnHyperlinkTextInfo(string info)    &#123;        Debug.Log(&quot;超链接信息：&quot; + info);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-安装</title>
      <link href="/2023/06/27/Doc/WooAsset/1-WooAsset-%E5%AE%89%E8%A3%85/"/>
      <url>/2023/06/27/Doc/WooAsset/1-WooAsset-%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="方法一：通过UnityPackage安装"><a href="#方法一：通过UnityPackage安装" class="headerlink" title="方法一：通过UnityPackage安装"></a>方法一：通过UnityPackage安装</h1><ul><li>打开Unity Package Manager</li><li>点击左上角加号 选择 Add package from git URL</li><li>输入 <a href="https://github.com/OnClick9927/WooAsset.git#src">https://github.com/OnClick9927/WooAsset.git#src</a></li><li>点击Add后，稍等片刻即可完成安装</li></ul><h1 id="方法二：通过Git安装"><a href="#方法二：通过Git安装" class="headerlink" title="方法二：通过Git安装"></a>方法二：通过Git安装</h1><ul><li>git clone <a href="https://github.com/OnClick9927/WooAsset">https://github.com/OnClick9927/WooAsset</a></li><li>把 WooAsset文件夹拖入Unity工程即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-配置</title>
      <link href="/2023/06/27/Doc/WooAsset/2-WooAsset-%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/06/27/Doc/WooAsset/2-WooAsset-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次使用"><a href="#第一次使用" class="headerlink" title="第一次使用"></a>第一次使用</h1><ul><li>打开编辑器窗口，操作如下图</li><li>成功后，会在Assets&#x2F;Editor目录下看到两个配置文件</li><li>其中 AssetsEditorCache 可以删除（团队协作时候，不需要同步）<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"><br><img src="/../../../Pic/Doc/WooAsset/configasset_1.png" alt="Alt text"></li></ul><h1 id="配置资源"><a href="#配置资源" class="headerlink" title="配置资源"></a>配置资源</h1><p><img src="/../../../Pic/Doc/WooAsset/option_build1.png" alt="Alt text"></p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>Pkgs</td><td>资源包配置组</td></tr><tr><td>Version</td><td>此次打包出去的版本</td></tr><tr><td>MaxCacheVersionCount</td><td>远程版本文件最多包含的版本个数</td></tr><tr><td>CleanHistory</td><td>每次打包结束之后是否清理history文件夹</td></tr><tr><td>Build Pipeline</td><td>管线 内置 &#x2F;SBP</td></tr><tr><td>build mode</td><td>打包模式（是否增量式）</td></tr><tr><td>bundle name type</td><td>输出Bundle名称风格（名&#x2F;名_Hash&#x2F;Hash）</td></tr><tr><td>type tree option</td><td>Bundle类型信息</td></tr><tr><td>Compress</td><td>Bundle压缩格式</td></tr><tr><td>Asset Build</td><td>自定义打包流程（可扩展）</td></tr><tr><td>Encrypt</td><td>文件加密方式(可扩展)</td></tr><tr><td>Bundle Result Optimizer</td><td>对构建结果优化 (可扩展)(合理化分包，处理循环依赖、冗余，颗粒度…..)</td></tr><tr><td>Optimization Count</td><td>优化迭代次数</td></tr><tr><td>下面是内建资源选择</td><td></td></tr><tr><td>Copytostream</td><td>拷贝资源到stream，</td></tr><tr><td>BuildInAssets</td><td>在把bundle拷贝到stream时候，根据这个配置决定拷贝哪些bundle（不配置拷贝全部）</td></tr><tr><td>Build-In Bundle Selector</td><td>内建资源选择器  （可扩展）</td></tr><tr><td>下面都是默认值</td><td></td></tr><tr><td>Build Target</td><td>当前打包的平台</td></tr><tr><td>BuildTargetName</td><td>目标平台名字</td></tr><tr><td>stream bundle directory</td><td>stream保存资源的文件夹</td></tr><tr><td>Output Path</td><td>输出路径</td></tr><tr><td>History Path</td><td>历史文件所在文件夹，第一次打包时候把他删了，后续不要动里面的文件</td></tr></tbody></table><h2 id="资源组介绍"><a href="#资源组介绍" class="headerlink" title="资源组介绍"></a>资源组介绍</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>Build</td><td>该组是否需要打包 （给分布式打包使用）</td></tr><tr><td>Name</td><td>包的名字（不可重复，不为空）</td></tr><tr><td>Description</td><td>对包加点描述</td></tr><tr><td>Paths</td><td>对应的项目路径  （不可重复，不为空）</td></tr><tr><td>Tags</td><td>对包加一些标记</td></tr><tr><td>builds</td><td>分包规则       （也可以纯粹代码分包，但是此项目不可以存在配置）</td></tr></tbody></table><ul><li>每个资源组均可以分开打包，更新，加载</li><li>保持好良好的资源组结构，方式生成过多冗余</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-构建与部署</title>
      <link href="/2023/06/27/Doc/WooAsset/3-WooAsset-%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/06/27/Doc/WooAsset/3-WooAsset-%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><ul><li>设置好需要打包的组</li><li>点击Tools&#x2F;WooAsset&#x2F;Build</li><li>稍等片刻即可完成打包，内容全都在Sever目录下</li><li>按照Server 文件夹 拷贝到CDN即可</li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>CDN└─android    ├─v1.0（APP版本）    ├─v1.1（APP版本）    └─v2.0（APP版本）    └─版本列表└─iphone    ├─v1.0（APP版本）    ├─v1.1（APP版本）    └─v2.0（APP版本）    └─版本列表</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-一些工具</title>
      <link href="/2023/06/27/Doc/WooAsset/4-WooAsset-%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7/"/>
      <url>/2023/06/27/Doc/WooAsset/4-WooAsset-%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="收集资源预览（Option-x2F-Tools页签）"><a href="#收集资源预览（Option-x2F-Tools页签）" class="headerlink" title="收集资源预览（Option&#x2F;Tools页签）"></a>收集资源预览（Option&#x2F;Tools页签）</h1><p><img src="/../../../Pic/Doc/WooAsset/option_tool.png" alt="Alt text"></p><h2 id="AssetMode"><a href="#AssetMode" class="headerlink" title="AssetMode"></a>AssetMode</h2><ul><li>Normal  正式的模式</li><li>Rude    粗鲁的，纯粹的编辑器加载，不需要任何配置</li><li>AssetDatabase  与 Normal 差不多，但是 不需要打包，是编辑器模拟</li></ul><h2 id="Simulator"><a href="#Simulator" class="headerlink" title="Simulator"></a>Simulator</h2><ul><li>EditorSimulatorPath  (编辑器状态下，Bundle存储的位置)</li><li>ServerDirectory  (打包后，资源所在目录)（上传到CDN拷贝词目录即可）</li><li>Enable Server （是否开启本地资源模拟服务）</li><li>Server Port  （模拟服务绑定的端口）</li></ul><h2 id="Shader-Variant-防止-着色器丢失"><a href="#Shader-Variant-防止-着色器丢失" class="headerlink" title="Shader Variant 防止 着色器丢失"></a>Shader Variant 防止 着色器丢失</h2><ul><li>Shader Variant Input Directory （需要收集SHader 变体文件夹）</li><li>Shader Variant output Directory （shader 变体输出文件夹）</li><li>（如何执行）点击Tools&#x2F;WooAsset&#x2F;Help&#x2F;ShaderVariant</li></ul><h2 id="Sprite-Atlas-打图集"><a href="#Sprite-Atlas-打图集" class="headerlink" title="Sprite Atlas  打图集"></a>Sprite Atlas  打图集</h2><ul><li>设置好图集相关设置</li><li>点击Tools&#x2F;WooAsset&#x2F;Help&#x2F;SpriteAtlas</li></ul><h2 id="AssetTags-资源有哪些标签"><a href="#AssetTags-资源有哪些标签" class="headerlink" title="AssetTags 资源有哪些标签"></a>AssetTags 资源有哪些标签</h2><h2 id="Record-Ignore-不需要记录到资源清单的资源-配置"><a href="#Record-Ignore-不需要记录到资源清单的资源-配置" class="headerlink" title="Record Ignore 不需要记录到资源清单的资源 配置"></a>Record Ignore 不需要记录到资源清单的资源 配置</h2><h2 id="收集资源预览（Assets页签）"><a href="#收集资源预览（Assets页签）" class="headerlink" title="收集资源预览（Assets页签）"></a>收集资源预览（Assets页签）</h2><p><img src="/../../../Pic/Doc/WooAsset/%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86%E6%83%85%E5%86%B5.png" alt="Alt text"></p><ul><li>如果不是打包，会收集所有的buildGroup</li><li>可以方便的看到究竟打包了什么内容</li><li>双击资源可以定位</li><li>支持快速搜索</li><li>可以查看资源依赖情况</li></ul><h2 id="Asset-Tags"><a href="#Asset-Tags" class="headerlink" title="Asset Tags"></a>Asset Tags</h2><ul><li>给相应的资源加标记的记录</li><li>具体操作（在Assets页签，选中资源-》右键）</li><li>需要先在窗口  （Option&#x2F;Tools页签&#x2F;AssetTags） 中 预设tag</li></ul><h2 id="Record-Ignore"><a href="#Record-Ignore" class="headerlink" title="Record Ignore"></a>Record Ignore</h2><ul><li>规定一些资源不记录到资源清单内</li><li>属于优化选项，可以减小资源清单文件的大小<ul><li>哪些资源适合？满足以下条件</li><li>1、未在AssetReference中使用</li><li>2、不需要用代码指定路径加载的资源-&gt;即其他资源依赖的资源，属于运行时被动加载的</li><li>例子<ul><li>一个Scene 内有 N 个预制体</li><li>只需要标记场景文件，场景依赖的其他都是可以忽略的（包括预制体、材质、图片、shader、fbx 等）</li><li>这样一个场景就可以节约很大一部分的清单文件的占用</li></ul></li></ul></li><li>具体操作（在Assets页签，选中资源-》右键）</li></ul><h2 id="构建-Bundle-预览（Bundles页签）"><a href="#构建-Bundle-预览（Bundles页签）" class="headerlink" title="构建 Bundle 预览（Bundles页签）"></a>构建 Bundle 预览（Bundles页签）</h2><p><img src="/../../../Pic/Doc/WooAsset/%E6%89%93%E5%8C%85%E9%A2%84%E8%A7%88.png" alt="Alt text"></p><ul><li>如果不是打包，会收集所有的buildGroup</li><li>可以预览所有的assetBundle</li><li>可以查看每一个资源的依赖</li><li>可以查看每一个bundle的依赖</li><li>双击资源可以定位</li><li>支持快速搜索</li></ul><h2 id="资源加载情况（AssetsLife页签）"><a href="#资源加载情况（AssetsLife页签）" class="headerlink" title="资源加载情况（AssetsLife页签）"></a>资源加载情况（AssetsLife页签）</h2><p><img src="/../../../Pic/Doc/WooAsset/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5.png" alt="Alt text"></p><ul><li>资源加载实践</li><li>当前有多少引用</li><li>资源的标签</li><li>资源所属的 bundle</li><li>支持快速搜索</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-更新_初始化 _加载_卸载</title>
      <link href="/2023/06/27/Doc/WooAsset/5-WooAsset-%E6%9B%B4%E6%96%B0_%E5%88%9D%E5%A7%8B%E5%8C%96%20_%E5%8A%A0%E8%BD%BD_%E5%8D%B8%E8%BD%BD/"/>
      <url>/2023/06/27/Doc/WooAsset/5-WooAsset-%E6%9B%B4%E6%96%B0_%E5%88%9D%E5%A7%8B%E5%8C%96%20_%E5%8A%A0%E8%BD%BD_%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><h2 id="注意该例子演示的没有服务器的情况下，所以需要自己请求资源版本"><a href="#注意该例子演示的没有服务器的情况下，所以需要自己请求资源版本" class="headerlink" title="注意该例子演示的没有服务器的情况下，所以需要自己请求资源版本"></a>注意该例子演示的没有服务器的情况下，所以需要自己请求资源版本</h2><h2 id="如果有服务器-可以跳过请求请求远端版本信息，直接从-Assets-DownloadVersionData-version-开始"><a href="#如果有服务器-可以跳过请求请求远端版本信息，直接从-Assets-DownloadVersionData-version-开始" class="headerlink" title="如果有服务器 可以跳过请求请求远端版本信息，直接从 Assets.DownloadVersionData(version) 开始"></a>如果有服务器 可以跳过请求请求远端版本信息，直接从 Assets.DownloadVersionData(version) 开始</h2><h2 id="如果是-WebGL-或者-不希望本地有缓存，直接从初始化开始"><a href="#如果是-WebGL-或者-不希望本地有缓存，直接从初始化开始" class="headerlink" title="如果是 WebGL 或者 不希望本地有缓存，直接从初始化开始"></a>如果是 WebGL 或者 不希望本地有缓存，直接从初始化开始</h2><pre><code class="csharp">Assets.SetAssetsSetting(new LocalSetting());//拉取远端版本信息var op = await Assets.LoadRemoteVersions();//网络错误/AssetDatabaseMode/RudeMode 会=nullif (op.Versions != null)&#123;  //选择版本    var version = op.Versions.NewestVersion();  //下载远端版本文件    var down = await Assets.DownloadVersionData(version);    //得到版本数据    var versionData = down.GetVersion();    //本地和远端比较，第二个参数表示，比较哪些 pkg    var compare = await Assets.CompareVersion(versionData, versionData.GetAllPkgs());//下载所有需要更新的资源    for (int i = 0; i &lt; compare.add.Count; i++)        await Assets.DownLoadBundle(versionData.version, compare.add[i].bundleName);    for (int i = 0; i &lt; compare.change.Count; i++)        await Assets.DownLoadBundle(versionData.version, compare.change[i].bundleName);&#125;</code></pre><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><pre><code class="csharp">Assets.SetAssetsSetting(new LocalSetting());//初始化//可选参数 version 初始化哪一个版本，不传就是本地版本，本地没有就是远端最新版本//可选参数 ignoreLocalVersion 如果本地有版本文件是否忽略，直接去拿目标版本//可选参数 again 再一次初始化（使用场景，热更新界面也热更）//可选参数 getPkgs 始化包选择await Assets.InitAsync();</code></pre><h1 id="加载与卸载"><a href="#加载与卸载" class="headerlink" title="加载与卸载"></a>加载与卸载</h1><pre><code class="csharp">///正常加载var asset = await Assets.LoadAssetAsync(path);///获取要加载的资源var sp = asset.GetAsset&lt;Sprite&gt;();///加载Unity无法识别的资源var asset = await Assets.LoadRawAssetAsync(path);RawObject raw = asset.GetAsset();Debug.Log(raw.bytes.Length);///加载子资源var mainAsset = await Assets.LoadSubAsset(path);var sp = mainAsset.GetSubAsset&lt;Sprite&gt;(&quot;a_1&quot;);///上面几个的卸载资源Assets.Release(asset)///加载卸载场景var sceneAsset = await Assets.LoadSceneAssetAsync(path);await sceneAsset.LoadSceneAsync(LoadSceneMode.Additive);await Assets.UnloadSceneAsync(path, UnloadSceneOptions.UnloadAllEmbeddedSceneObjects);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-个性化</title>
      <link href="/2023/06/27/Doc/WooAsset/7-WooAsset-%E4%B8%AA%E6%80%A7%E5%8C%96/"/>
      <url>/2023/06/27/Doc/WooAsset/7-WooAsset-%E4%B8%AA%E6%80%A7%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="打包个性化"><a href="#打包个性化" class="headerlink" title="打包个性化"></a>打包个性化</h2><pre><code class="csharp"> //个性化打包流程public abstract class IAssetBuild&#123;//是否记录这个路径bool GetIsRecord(string path) ;//自定义 资源 Tag （可以按照tag加载一组资源）List&lt;string&gt; GetAssetTags(string path) ;//自定义版本规则string GetVersion(string settingVersion, AssetTaskContext context);//一个资源是不是可以忽略 protected virtual bool IsIgnorePath(string path);//更具一个路径返回资源类型（覆盖）AssetType CoverAssetType(string path, AssetType type) ;// 自定义资源分组void Create(List&lt;EditorAssetData&gt; assets, List&lt;EditorBundleData&gt; result, EditorPackageData pkg);//自定义加密IAssetStreamEncrypt GetBundleEncrypt(EditorPackageData pkg, EditorBundleData data, IAssetStreamEncrypt en) ;int GetEncryptCode(IAssetStreamEncrypt en);IAssetStreamEncrypt GetEncryptByCode(int code)&#125;</code></pre><h3 id="打包管线-内建（自带）-x2F-SBP（后续文章有）"><a href="#打包管线-内建（自带）-x2F-SBP（后续文章有）" class="headerlink" title="打包管线 内建（自带）&#x2F;SBP（后续文章有）"></a>打包管线 内建（自带）&#x2F;SBP（后续文章有）</h3><pre><code class="csharp">    public interface IBuildPipeLine    &#123;        bool BuildAssetBundles(string outputPath, AssetBundleBuild[] builds, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform);        List&lt;string&gt; GetAllAssetBundles(BundleNameType nameType);        List&lt;string&gt; GetAllDependencies(string assetBundleName, BundleNameType nameType);        uint GetBundleCrc(string directory, string bundleName, BundleNameType nameType);        string GetBundleHash(string directory, string bundleName, BundleNameType nameType);        BuildAssetBundleOptions GetBundleOption(AssetTaskParams param, out string err);    &#125;</code></pre><h3 id="资源分包优化"><a href="#资源分包优化" class="headerlink" title="资源分包优化"></a>资源分包优化</h3><pre><code class="csharp">    public interface IBundleOptimizer    &#123;        List&lt;EditorBundleData&gt; Optimize(List&lt;EditorBundleData&gt; builds, EditorPackageData buildPkg, IAssetsBuild build);    &#125;</code></pre><h3 id="内建资源选择"><a href="#内建资源选择" class="headerlink" title="内建资源选择"></a>内建资源选择</h3><pre><code class="csharp">    public interface IBuildInBundleSelector    &#123;        /// &lt;summary&gt;        ///         /// &lt;/summary&gt;        /// &lt;param name=&quot;files&quot;&gt;打包出的所有文件&lt;/param&gt;        /// &lt;param name=&quot;buildInAssets&quot;&gt;编辑器配置&lt;/param&gt;        /// &lt;param name=&quot;buildInConfig&quot;&gt;必须拷贝的文件&lt;/param&gt;        /// &lt;param name=&quot;manifest&quot;&gt;打包出来的配置文件（Merged）&lt;/param&gt;        /// &lt;param name=&quot;exports&quot;&gt;打包报告（Merged）&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        string[] Select(string[] files, List&lt;string&gt; buildInAssets, List&lt;string&gt; buildInConfig, ManifestData manifest, List&lt;PackageExportData&gt; exports);    &#125;</code></pre><h3 id="低代码打包，配合资源组分包-使用，用于选出需要的资源"><a href="#低代码打包，配合资源组分包-使用，用于选出需要的资源" class="headerlink" title="低代码打包，配合资源组分包 使用，用于选出需要的资源"></a>低代码打包，配合资源组分包 使用，用于选出需要的资源</h3><pre><code class="csharp">    public interface IAssetSelector    &#123;        List&lt;EditorAssetData&gt; Select(List&lt;EditorAssetData&gt; assets, AssetSelectorParam param);    &#125;</code></pre><h2 id="加载个性化"><a href="#加载个性化" class="headerlink" title="加载个性化"></a>加载个性化</h2><pre><code class="csharp">///写一个 class 继承于 AssetsSettingpublic abstract class AssetsSetting&#123;  //是否要检查总版本文件  //比如 服务器给出版本 0.0.1，是否去版本记录里面查有没有这个版本  public virtual bool CheckVersionByVersionCollection() =&gt; false;  //拷贝stream 路径重写  public virtual string GetStreamingFileUrl(string url)&#123;&#125;  //是否从缓存加载ab  public virtual bool GetCachesDownloadedBundles() =&gt; false;  //按照名字搜索时候，名字是否有后缀，可以近似实现 Resources.Load  public virtual FileNameSearchType GetFileNameSearchType()&#123;&#125;    //是否需要拷贝stream到沙盒  public virtual bool NeedCopyStreamBundles() &#123;&#125;  ///一帧内最多多少毫秒在加载资源  public virtual long GetLoadingMaxTimeSlice()&#123;&#125;    /// 如果本地没有是否需要保存文件  // GetBundleAlwaysFromWebRequest 返回 true 该选项不起效  public virtual bool GetSaveBytesWhenPlaying() =&gt; true;  ///下载的路径  //举例 ：https://xxx.xxx.xx  //http://127.0.0.1:8080  // Application.StreamingPath   protected virtual string GetBaseUrl() &#123;&#125;  ///自定义 bundle 去哪里下载public virtual string GetUrlByBundleName(string buildTarget, string bundleName) =&gt; $&quot;&#123;GetBaseUrl()&#125;/&#123;buildTarget&#125;/&#123;bundleName&#125;&quot;; public virtual string GetUrlByBundleName(string buildTarget, string version, string bundleName) =&gt; $&quot;&#123;GetBaseUrl()&#125;/&#123;buildTarget&#125;/&#123;version&#125;/&#123;bundleName&#125;&quot;;  //永远从远端下载   public virtual bool GetBundleAlwaysFromWebRequest() &#123;&#125;  /// 下载超时  public virtual int GetWebRequestTimeout() ;  ///下载重试次数  public virtual int GetWebRequestRetryCount() ;  ///同时存在下载器最大个数  public virtual int GetWebRequestCountAtSameTime() ;//是否开启模糊加载//Assets.loadAsset(&quot;Assets/a.png&quot;)//开启后 Assets.loadAsset(&quot;Assets/a&quot;)//注意 开启之后，同一个文件夹下不可以出现同名文件   public virtual string GetFuzzySearch()&#123;&#125;  ///是否自动卸载 AB  //如果未开启，需要在合适的时机手动调用   Assets.UnloadBundles  public virtual bool GetAutoUnloadBundle() &#123;&#125;  ///资源加密方式  public virtual IAssetStreamEncrypt GetEncrypt(int code) &#123;&#125;  /// 自定义的资源生命周期管理，bundle和asset均可以  public virtual IAssetLife GetAssetLife()&#123;&#125;&#125;</code></pre><h2 id="资源加密"><a href="#资源加密" class="headerlink" title="资源加密"></a>资源加密</h2><pre><code class="csharp">//个性化加密    public interface IAssetEncrypt    &#123;        byte[] Encode(string bundleName, byte[] buffer);        byte[] Decode(string bundleName, byte[] buffer);        byte[] Decode(string bundleName, byte[] buffer, int offset, int length);    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-运行时扩展功能</title>
      <link href="/2023/06/27/Doc/WooAsset/8-WooAsset-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/06/27/Doc/WooAsset/8-WooAsset-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="实例化-物体"><a href="#实例化-物体" class="headerlink" title="实例化 物体"></a>实例化 物体</h2><pre><code class="csharp">// 创建  var oppp = await Assets.InstantiateAsync(path, parent);// 干点啥  //销毁  //销毁时候会自动改变引用计数，不需要手动Assets.Release  oppp.Destroy();</code></pre><h2 id="AssetReference-amp-amp-使用例子"><a href="#AssetReference-amp-amp-使用例子" class="headerlink" title="AssetReference &amp;&amp; 使用例子"></a>AssetReference &amp;&amp; 使用例子</h2><pre><code class="csharp">  [System.Serializable]  public class AssetReference&lt;T&gt; : AssetReference where T : UnityEngine.Object  &#123;      public override Type type =&gt; typeof(T);  &#125;</code></pre><pre><code class="csharp">    public class AssetExample : UnityEngine.MonoBehaviour    &#123;        public Image image;        public AssetReference&lt;UnityEngine.Sprite&gt; assetReference;       async void Test()&#123;          var asset = await assetReference.LoadAssetAsync();          await asset;          image.sprite = asset.GetAsset&lt;UnityEngine.Sprite&gt;();        &#125;    &#125;</code></pre><h2 id="一些扩展方法"><a href="#一些扩展方法" class="headerlink" title="一些扩展方法"></a>一些扩展方法</h2><pre><code class="csharp">//使用时机-》avpro这种只能用路径的插件public static string GetRawAssetUrlOrPath(assetpath)//获得所有资源路径 public static IReadOnlyList&lt;string&gt; GetAllAssetPaths() ; //获得一个tag 的所有路径 public static IReadOnlyList&lt;string&gt; GetTagAssetPaths(string tag) ; //获得所有资源路径 public static IReadOnlyList&lt;string&gt; GetAllTags(); //更具tag 获得唯一 资源 public static string GetUniqueAssetPathByTag(string tag); //获得所有满足条件的资源 public static IReadOnlyList&lt;string&gt; GetAssetPath(Func&lt;AssetData, bool&gt; fit); //获得唯一满足条件的资源 public static string GetUniqueAssetPath(Func&lt;AssetData, bool&gt; fit); //通过名字找到名字一致的资源 public static IReadOnlyList&lt;string&gt; GetAssetsByAssetName(string name) ;//得到对应路径数据 public static AssetData GetAssetData(string assetPath);</code></pre><h2 id="资源组加载"><a href="#资源组加载" class="headerlink" title="资源组加载"></a>资源组加载</h2><h3 id="何时使用：某些地方必须需要同步加载资源（先准备一下）-x2F-一次型加载配置表，读取到内存之后，卸载"><a href="#何时使用：某些地方必须需要同步加载资源（先准备一下）-x2F-一次型加载配置表，读取到内存之后，卸载" class="headerlink" title="何时使用：某些地方必须需要同步加载资源（先准备一下）&#x2F; 一次型加载配置表，读取到内存之后，卸载"></a>何时使用：某些地方必须需要同步加载资源（先准备一下）&#x2F; 一次型加载配置表，读取到内存之后，卸载</h3><pre><code class="csharp">//准备一组资源string[] groups ;var assets= await Assets.PrepareAssets(groups)//或者按照 tag 准备一组资源var assets=Assets.PrepareAssetsByTag(tag)///加载对应的资源方法一string path;var asset = assets.FindAsset(path)///加载对应的资源方法二var asset = Assets.LoadAssetAsync(path)///注意：方式二会增加引用计数，需要在合适的地方 Assets.Release(asset)///方式一不会增加引用计数///把整组资源全都卸载了assets.Release();///配合资源模糊搜索一起使用//使用场景，进入战斗场景之前把战斗需要的资源全加载</code></pre><h2 id="方便的资源卸载"><a href="#方便的资源卸载" class="headerlink" title="方便的资源卸载"></a>方便的资源卸载</h2><h3 id="基础方式"><a href="#基础方式" class="headerlink" title="基础方式"></a>基础方式</h3><ul><li>场景</li><li>一个ui界面上面有一个image</li><li>运行时候需要不停的替换image的sprite</li><li>界面关闭的时候需要把image的sprite卸载</li></ul><pre><code class="csharp">///所有的设置图片都走这个方法public static async void SetSprite(Image image, string path)&#123;    var asset = await Assets.LoadAssetAsync(path);    if (asset.isErr) return;    image.sprite = asset.GetAsset&lt;Sprite&gt;();    Assets.AddBridge(new GameObjectBridge(image.gameObject,asset));&#125;///在合适的时候调用一次即可（比如：切换场景时候）public static void ReleaseUselessBridges()&#123;    Assets.ReleaseUselessBridges();&#125;</code></pre><p>其他类型的资源&#x2F;组件，可以 继承 AssetBridge&lt; T &gt; 自行实现即可</p><h3 id="更加方便的方式（有风险）"><a href="#更加方便的方式（有风险）" class="headerlink" title="更加方便的方式（有风险）"></a>更加方便的方式（有风险）</h3><pre><code class="csharp">public class LocalSetting : AssetsSetting&#123;    public override IAssetLife GetAssetLife()    &#123;      /// 参数是缓存的内存大小，超过这个数字会自动卸载最早的资源        return new LRULife(1024 * 50);    &#125;&#125;Assets.SetAssetsSetting(new LocalSetting());</code></pre><ul><li>可以实现 bundle 不自动卸载，到达一定大小在开始卸载</li><li>如果内存不足时候，最早被使用的资源会被优先卸载</li><li>内存设置的别太小，容易出现资源丢失</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-Document</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-Document/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-Document/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>此篇文章讲一下如何快速使用WooTween</li><li>根据自己需求怎么去扩展</li><li>以及重点内容</li></ul><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul><li><p>之前已经讲解过了Component是个什么东西 </p></li><li><p>这里我们看看如何使用</p></li><li><p>选择物体-添加组件</p></li><li><p>我们可以看到自带的三个组件</p><p><img src="/../../../Pic/Doc/WooTween/%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6.png" alt="Alt text"></p></li><li><p>autoPlay: 自动播放 autoRecycle: 自动回收</p></li><li><p>Duration：持续时间</p></li><li><p>Snap: 简单理解就是勾选后整数的数值来运动</p></li><li><p>Curve: 动画曲线 内置了5种曲线 可以自定义 并保存</p></li><li><p>LoopType: 循环模式 ReStart PingPong</p></li><li><p>Loop: 循环次数 -1无限 1..次数</p><ul><li>Type: 运动数值的模式 </li><li>Single 起始点和终点值</li></ul></li><li><p>Array 多个数值组成一条线路</p><ul><li>Play Rewind Complete 无需运行立即播放动画 倒放回原点 停止动画</li></ul></li></ul><p> <img src="/../../../Pic/Doc/WooTween/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D.png" alt="Alt text"><br> <img src="/../../../Pic/Doc/WooTween/ComponentGif.gif" alt="Alt text"></p><ul><li>使用方法一目了然这里就不过多讲解了 </li><li>如何扩展呢 我们以BoxCollider2D的Offset为例 </li><li>我们需要更改的数值为Vector2</li><li>新建两个脚本</li></ul><pre><code class="csharp">using UnityEngine;namespace WooTween&#123;    public class DoBoxCollider2DComponent : TweenComponent&lt;Vector2,BoxCollider2D&gt;    &#123;        protected override Vector2 GetTargetValue()        &#123;            //返回物体的缩放值            return transform.GetComponent&lt;BoxCollider2D&gt;().offset;         &#125;        protected override  void SetTargetValue(Vector2 value)        &#123;            //物体的缩放值等于value            transform.GetComponent&lt;BoxCollider2D&gt;().offset = value;        &#125;    &#125;&#125;using UnityEditor;using UnityEngine;namespace WooTween&#123;    [CustomEditor(typeof(DoBoxCollider2DComponent))]    public class DoBoxCollider2DComponentEditor : TweenComponentEditor&lt;Vector2 , BoxCollider2D&gt; &#123; &#125;&#125;</code></pre><h2 id="TweenEx"><a href="#TweenEx" class="headerlink" title="TweenEx"></a>TweenEx</h2><ul><li>所有会调用的方法都在TweenEx脚本里面 </li><li>此篇内容讲解一下如何使用和如何扩展</li></ul><pre><code class="csharp">transform.DoMove(new Vecotr3(0,1,2),2,false) .SetLoop(4, LoopType.PingPong)                  .SetAnimationCurve(curve)                  .SetRecycle(false)                  .OnComplete(() =&gt;                  &#123;                      Debug.Log(Time.time);                  &#125;);</code></pre><ul><li>传入位置 持续时间 移动数值是否为整型 设置循环 循环类型 设置动画曲线 设置回收 完成时委托内容</li></ul><pre><code class="csharp">ITween t = cube.DoMove(new Vector3[] &#123;               Vector3.zero,               Vector3.one,               Vector3.one * 2,               Vector3.one * 3,               Vector3.one * -4,               Vector3.one * 5,               Vector3.one * 6,            &#125;, 5, false)            .SetRecyle(false);</code></pre><ul><li>也可以以数组的形势传入参数</li></ul><pre><code class="csharp">        private void Update()        &#123;            if (Input.GetKeyDown(KeyCode.Space))            &#123;                t.Rewind(1);            &#125;            if (Input.GetKey(KeyCode.A))            &#123;                t.ReStart();            &#125;            if (Input.GetKey(KeyCode.Q))            &#123;                t.Complete(false);            &#125;        &#125;</code></pre><ul><li>也可以对动画进行一系列操作</li></ul><pre><code class="csharp">tc.SetUpdateType(TweenUpdateType.Update).SetDeltaTime(0.1f).SetDelta(0.2f).SetTimeScale(2);</code></pre><ul><li>设置动画的一系列参数</li></ul><p> <img src="/../../../Pic/Doc/WooTween/%E4%BB%A3%E7%A0%81Gif.gif" alt="Alt text"></p><h2 id="如何扩展"><a href="#如何扩展" class="headerlink" title="如何扩展"></a>如何扩展</h2><pre><code class="csharp">public static ITween&lt;T&gt; DoGoto&lt;T&gt;(T start, T end, float duration, Func&lt;T&gt; getter, Action&lt;T&gt; setter, bool snap, EnvironmentType env= EnvironmentType.RT) where T : struct        &#123;#if UNITY_EDITOR            if (!UnityEditor.EditorApplication.isPlaying &amp;&amp; !Application.isPlaying)            &#123;                env = EnvironmentType.Editor;            &#125;#endif            var tween = AllocateSingleTween&lt;T&gt;(env);            tween.Config(start, end, duration, getter, setter, snap);                        (tween as Tween).WaitToRun();            return tween;        &#125;        public static ITween&lt;T&gt; DoGoto&lt;T&gt;(T[] array, float duration, Func&lt;T&gt; getter, Action&lt;T&gt; setter, bool snap, EnvironmentType env = EnvironmentType.RT) where T : struct        &#123;#if UNITY_EDITOR            if (!UnityEditor.EditorApplication.isPlaying &amp;&amp; !Application.isPlaying)            &#123;                env = EnvironmentType.Editor;            &#125;#endif            var tween = AllocateArrayTween&lt;T&gt;(env);            tween.Config(array, duration, getter, setter, snap);            (tween as Tween).WaitToRun();            return tween;        &#125;</code></pre><ul><li>所有的方法扩展主要依靠于这两个函数 传入一个值还是数组</li><li>现在所支持的包括Transform、Material、Graphic、Light、Camera、CanvasGroup、Text、Image、ScrollRect、GameObject、Behaviour、Toggle、AudioSource、Rigidbody、Rigidbody2D、SpriteRenderer、LayoutElement、Outline、RectTransform、Slider</li><li>大部分经常会用到的扩展方法都在其中</li></ul><pre><code class="csharp">public static ITween&lt;float&gt; DoFieldOfView(this Camera target, float value, float duration, bool snap = false)&#123;   return DoGoto(target.fieldOfView,           value,           duration,           () =&gt; &#123; return target.fieldOfView; &#125;,          (value) =&gt; &#123; target.fieldOfView = value; &#125;,           snap);&#125;</code></pre><ul><li>以修改相机的FieldOfView为例</li><li>写一个静态方法 返回值为ITween&lt;数据类型&gt;  </li><li>第一个方法参数需要是 this + 类型 + 名称 | 传入值 持续时间 Snap</li><li>方法体里面可以写对传入值的判断 ，比如： 不能小于0 不能大于180</li><li>return 调用DoGoto方法 将之前写的参数一一对应 </li><li>剩下的事情就不需要我们去管了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-Tween</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-Tween/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-Tween/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>我们需要实现开始、重新开始、结束，回去</li><li>所以必须有四个方法</li><li>Run、ReStart、Rewind、Complete</li><li>因为要可以设置转换器，所以必须有一个引用</li><li>因为需要可以循环动画，所以必须要有一个方向、循环类型</li></ul><h2 id="呼之欲出的结果"><a href="#呼之欲出的结果" class="headerlink" title="呼之欲出的结果"></a>呼之欲出的结果</h2><pre><code class="csharp">///环境public enum TweenDirection&#123;    Forward,    Back&#125;public enum LoopType&#123;    ReStart,    PingPong&#125;public abstract class Tween : TweenObject, ITween&#123;    private TweenDirection _direction = TweenDirection.Forward;    public LoopType loopType &#123; get; set; &#125;    public abstract IPercentConverter converter &#123; get; set; &#125;    public abstract void Run();    public abstract void ReStart();    public abstract void Rewind(float duration,bool snap=false);    public abstract void Complete(bool invoke);&#125;</code></pre><h1 id="再次开始"><a href="#再次开始" class="headerlink" title="再次开始"></a>再次开始</h1><ul><li>动画的变化有可能是从一个值到另一个值</li><li>比如0-1</li><li>也有可能需要变化一组数值</li><li>比如dotween 经典的 dopath</li><li>所以我们有两种tween,SingleTween,ArrayTween</li></ul><h1 id="凉鞋专用"><a href="#凉鞋专用" class="headerlink" title="凉鞋专用"></a>凉鞋专用</h1><ul><li>为什么要有 WaitToRun 这个方法</li><li>因为需要支持链式编程，所以tween都是等到下一帧才会真的开始跑</li><li>对于为什么要有 UnbindTweenValue 这个方法</li><li>TweenValue 其实是一直跑的，直到他自己跑结束，会被驱动统一回收</li><li>tween想要中断被当前 TweenValue 控制数值，只要把 TweenValue 的plugin制空即可</li><li>还想继续跑，那就重新分配一个即可</li><li>这个就是我之前困扰的bug</li></ul><h1 id="更方便的书写"><a href="#更方便的书写" class="headerlink" title="更方便的书写"></a>更方便的书写</h1><ul><li>众所周知，dotween最出名的就是链式编程</li><li>我们也不能少</li></ul><pre><code class="csharp">public static ISingleTween&lt;T&gt; AllocateSingleTween&lt;T&gt;(EnvironmentType env)&#123;    if (env != EnvironmentType.Editor)        TweenSingleton.Initialized();    return TweenObject.Allocate&lt;SingleTween&lt;T&gt;&gt;(env);&#125;public static ITween&lt;T&gt; DoGoto&lt;T&gt;(T start, T end, float duration, Func&lt;T&gt; getter, Action&lt;T&gt; setter, bool snap, EnvironmentType env= EnvironmentType.RT)&#123;#if UNITY_EDITOR    if (!UnityEditor.EditorApplication.isPlaying &amp;&amp; !Application.isPlaying)    &#123;        env = EnvironmentType.Editor;    &#125;#endif    var tween = AllocateSingleTween&lt;T&gt;(env);    tween.Config(start, end, duration, getter, setter, snap);    (tween as Tween).WaitToRun();    return tween;&#125;public static ITween&lt;Vector3&gt; DoMove(this Transform target, Vector3 end, float duration, bool snap = false)&#123;    return DoGoto(target.position, end, duration, () =&gt; &#123; return target.position; &#125;,            (value) =&gt; &#123;                target.position = value;            &#125;, snap        );&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-TweenValue</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-TweenValue/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-TweenValue/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>这是一个单程车，</li><li>所以他的功能就是在曲线转换器的作用下</li><li>从一个值跑到另一个值即可</li><li>那么他肯定有一个 开始跑（run）和update</li><li>run 很简单</li><li>update ，在那里运行呢？</li><li>还记得我们的好司机吗？</li><li>对了，就是他带着我们的 TweenValue 跑</li><li>我们需要具有曲线的运行跑完这个单程</li><li>所以我们TweenValue得有一个 转换器</li><li>我们变化的值，也不可能是一种</li><li>有可能是 float、int、Vector3等等</li><li>所以 TweenValue 是一个泛型</li></ul><h2 id="呼之欲出的结果"><a href="#呼之欲出的结果" class="headerlink" title="呼之欲出的结果"></a>呼之欲出的结果</h2><pre><code class="csharp">///环境public abstract class TweenValue : TweenObject&#123;    ///提供统一的获取接口    public static TweenValue&lt;T&gt; Get&lt;T&gt;(EnvironmentType envType) where T : struct &#123;&#125;    private IPercentConverter _converter = EaseCoverter.Default;    private float _time;    public abstract float duration &#123; get; &#125;    public static float deltaTime = 0.02f;    protected abstract void MoveNext();    public void Run()    &#123;        TweenDrive container = TweenDrive.GetDrive(envType);        container.Subscribe(this);    &#125;    public void Update()    &#123;        _time += deltaTime ;        if (_time &gt;= duration)        &#123;            OnCompelete();        &#125;        else        &#123;            MoveNext();        &#125;    &#125;    protected virtual void OnCompelete()&#123;&#125;&#125;public abstract class TweenValue&lt;T&gt; : TweenValue where T : struct&#123;    ///对Tween传过来的设置打个包    private IPlugin&lt;T&gt; _plugin;    private T _current;    protected T pluginValue &#123; get &#123; return _plugin.getter.Invoke(); &#125; &#125;    ///设置当前的值    protected void SetCurrent(T value)    &#123;        if (_plugin != null)        &#123;            if (_plugin.snap)                _current = Snap(value);            else                _current = value;            if (_plugin.setter != null)            &#123;                _plugin.setter(_current);            &#125;        &#125;    &#125;    public T end &#123; get &#123; return _plugin.end; &#125; &#125;    public T start &#123; get &#123; return _plugin.start; &#125; &#125;    public override float duration &#123; get &#123; return _plugin != null ? _plugin.duration : 0; &#125; &#125;&#125;</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>基础的结构已经有了，接下来就是各种类型（float，int，Vector3）各自实现即可</p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-转换器</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="这是个什么东西"><a href="#这是个什么东西" class="headerlink" title="这是个什么东西"></a>这是个什么东西</h2><p>在dotween 里面有一个Ease的概念</p><p>我们要实现的就是这个</p><p>那么这个东西很简单</p><p>只需要实现从一个值到另一个值的映射即可</p><h2 id="呼之欲出的结果"><a href="#呼之欲出的结果" class="headerlink" title="呼之欲出的结果"></a>呼之欲出的结果</h2><pre><code class="csharp">///环境public interface IPercentConverter&#123;    float Convert(float percent, float time, float duration);    void Recycle();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-驱动器</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-%E9%A9%B1%E5%8A%A8%E5%99%A8/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-%E9%A9%B1%E5%8A%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>驱动器需要逐帧运行，所以需要update</li><li>因为需要分为编辑器和运行时，所以要有一个环境的概念</li><li>但是驱动总得有一个指挥他运行的东西<ul><li>运行时：单例</li><li>编辑器：绑定到编辑器的update</li></ul></li></ul><h3 id="呼之欲出的结果"><a href="#呼之欲出的结果" class="headerlink" title="呼之欲出的结果"></a>呼之欲出的结果</h3><pre><code class="csharp">///环境public enum EnvironmentType&#123;    RT,    Editor&#125;public class TweenDrive : System.IDisposable&#123;    //各自的指挥，调用这个方法即可    public void Update()    &#123;    &#125;    private static Dictionary&lt;EnvironmentType, TweenDrive&gt; dic = new Dictionary&lt;EnvironmentType, TweenDrive&gt;();    public static TweenDrive GetDrive(EnvironmentType env)    &#123;        if (!dic.ContainsKey(env))        &#123;            dic.Add(env, new TweenDrive());        &#125;        return dic[env];    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-对象池</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="如何实现一个对象池"><a href="#如何实现一个对象池" class="headerlink" title="如何实现一个对象池"></a>如何实现一个对象池</h2><ul><li>有最基本的存取能力</li><li>最好是可以通用</li><li>有一定的能力</li></ul><h3 id="基础的存取能力"><a href="#基础的存取能力" class="headerlink" title="基础的存取能力"></a>基础的存取能力</h3><ul><li>存 Set</li><li>取 Get ,如果不够 CreateNew</li><li>内部需要维护一个可以保存对象的集合</li></ul><h3 id="通用-x2F-扩展能力"><a href="#通用-x2F-扩展能力" class="headerlink" title="通用&#x2F;扩展能力"></a>通用&#x2F;扩展能力</h3><ul><li>使用泛型</li><li>方法可以重写</li></ul><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre><code class="csharp">public abstract ObjectPool&lt;T&gt;&#123;    protected Queue&lt;T&gt; pool ;    public T Get()&#123;        T t;            if (pool.Count &gt; 0)                t = pool.Dequeue();            else            &#123;                t = CreateNew();                OnCreate(t);            &#125;            OnGet(t);            return t;    &#125;    protected abstract T CreateNew();    protected virtual void OnGet(T t) &#123; &#125;    ///在被创建时候个性化的设置    protected virtual void OnCreate(T t) &#123; &#125;    public virtual bool Set(T t)    &#123;        if (!pool.Contains(t))        &#123;            if (OnSet(t))            pool.Enqueue(t);            return true;        &#125;        else        return false;    &#125;    ///为了实现可以控制数量的对象池    protected virtual bool OnSet(T t)    &#123;        return true;    &#125;&#125;</code></pre><h2 id="更加容易使用的对象池"><a href="#更加容易使用的对象池" class="headerlink" title="更加容易使用的对象池"></a>更加容易使用的对象池</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>上边的对象池已经可以实现对象的存取</li><li>但是每一个类型都得写一个子类</li><li>C#可以反射创建对象，但是需要类型</li></ul><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><pre><code class="csharp">public abstract ActivatorCreatePool&lt;T&gt;: ObjectPool&lt;T&gt;&#123;    ///反射创建对象    protected abstract T CreateNew()    &#123;        Type type = typeof(T);        return (T)Activator.CreateInstance(type);    &#125;&#125;</code></pre><h2 id="基类对象池"><a href="#基类对象池" class="headerlink" title="基类对象池"></a>基类对象池</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li>现在我们可以各种类型都使用同一个对象池</li><li>但是我们获取对象的时候，我们需要拿到具体的对象池</li><li>如果我们可以问一个对象池要各种对象该有多好<ul><li>例子：</li><li>假设我们想看动物</li><li>看鲨鱼-》海洋馆</li><li>看熊猫-》熊猫馆</li><li>就像上面，我们需要知道具体的展馆在哪里才行</li><li>但是大部分情况，她们都是在动物园里面的</li><li>动物园的路边是有指路牌的</li><li>因此我们的对象池也可以以做成动物园这种</li></ul></li><li>由此而言，我们有一个基类的概念，不能去动物园看飞机、坦克</li><li>我们需要一个对象池集合、并且需要指路牌</li><li>指路牌很简单、Type即可</li><li>所以用一个字典 Dictionary&lt;Type,Pool?&gt;</li><li>但是我们的对象池是泛型，后面这个类型咋写？</li><li>所以我们需要把之前额对象池再次抽象一次</li></ul><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><pre><code class="csharp">///更抽象public interface IObjectPool:IDisposable &#123;    /// 回收，解决不能使用泛型问题    void Set(object obj);&#125;public abstract class BaseTypePool&lt;T&gt;&#123;    private Dictionary&lt;Type, IObjectPool&gt; _poolMap;    /// 获取内部对象池    public ObjectPool&lt;Object&gt; GetPool&lt;Object&gt;() where Object : T    &#123;        Type type = typeof(Object);        var pool = GetPool(type);        return pool as ObjectPool&lt;Object&gt;;    &#125;    /// 获取内部对象池    public IObjectPool GetPool(Type type)    &#123;        IObjectPool pool;        if (!_poolMap.TryGetValue(type, out pool))        &#123;            var pooType = typeof(ActivatorCreatePool&lt;&gt;).MakeGenericType(type);            pool = Activator.CreateInstance(pooType, null) as IObjectPool;            _poolMap.Add(type, pool);        &#125;        return pool;    &#125;    /// 获取数据    public Object Get&lt;Object&gt;() where Object : T    &#123;        var pool = GetPool&lt;Object&gt;();        Object t = pool.Get();        return t;    &#125;    /// 回收数据    public void Set&lt;Object&gt;(Object t) where Object : T    &#123;        Type type = t.GetType();        var pool = GetPool(type);        pool.Set(t);    &#125;&#125;</code></pre><h2 id="全局扩展"><a href="#全局扩展" class="headerlink" title="全局扩展"></a>全局扩展</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>现在我们已经实现了只要去动物园就可以观赏各种动物</li><li>很爽，但是呢我们必须知道动物园在哪里</li><li>还有就是，我们可能还想看飞机、坦克，并不是动物园<ul><li>关于飞机坦克，还有动物，</li><li>我们可以抽象一点，他们都是一个东西</li><li>所以我们可以搞一个东西池子</li><li>也就是说，我们池子的 T 是 object</li><li>关于知道动物园在哪里</li><li>反正他是个东西，问东西池子要即可</li><li>所以我们实现一个全局的池子就好了</li><li>如何全局？C#正是个好语言-》静态扩展</li></ul></li></ul><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><pre><code class="csharp">public static class PoolEx&#123;    private class GlobalPool : BaseTypePool&lt;object&gt; &#123; &#125;    static private GlobalPool _globalPool = new GlobalPool();    /// 全局分配    public static T GlobalAllocate&lt;T&gt;()where T: class    &#123;        return _globalPool.Get&lt;T&gt;();    &#125;    /// 全局回收    public static void GlobalRecycle&lt;T&gt;(this T t)where T :class    &#123;        _globalPool.Set(t);    &#125;&#125;</code></pre><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>目前对象池，可以获取任何对象了 </p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-Component</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-Component/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-Component/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>有时候 效果很简单、很重复</li><li>有时候 效果是让策划美术调整</li><li>但是他们不会写代码</li><li>所以我们来编辑器扩展</li><li>具体代码项目看</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片交叉移动</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E4%BA%A4%E5%8F%89%E7%A7%BB%E5%8A%A8/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E4%BA%A4%E5%8F%89%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;UIEffect/UV Cross&quot;&#123;    Properties    &#123;      [PerRendererData]  _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Vector(&quot;Count And Move&quot;,Vector)=(1,1,1,1)    _xOffset(&quot;xOffset&quot;,float)=10    //_yOffset(&quot;_yOffset&quot;,float)=10    _Rotate(&quot;Rotate&quot;,float)=10    _Scale(&quot;Scale&quot;,float)=1    &#125;    SubShader    &#123;        // No culling or depth        Cull Off ZWrite Off ZTest Always        Blend SrcAlpha OneMinusSrcAlpha        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;UnityCG.cginc&quot;            struct appdata            &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;float4 color:COLOR;            &#125;;            struct v2f            &#123;                float2 uv : TEXCOORD0;                float4 vertex : SV_POSITION;float4 color:COLOR;            &#125;;            v2f vert (appdata v)            &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                o.uv = v.uv;o.color=v.color;                return o;            &#125;            sampler2D _MainTex;            float4 _Vector;float _xOffset;//float _yOffset;float _Rotate;float _Scale;            fixed4 frag (v2f i) : SV_Target            &#123;                float2 count=_Vector.xy;i.uv=i.uv-0.5;                float2 uv=i.uv*count* ((sin(_Time.x*_Scale)+1)/2+1);                float2 finalUV = uv;float angle=_Rotate*_Time.x;                finalUV.x = uv.x * cos(angle) - uv.y * sin(angle);                finalUV.y = uv.x * sin(angle) + uv.y * cos(angle);                finalUV += float2(0.5f, 0.5f);                uv=finalUV;                uv.y+=_Time.x*_Vector.w;                uv.x+=_Time.x*_Vector.z*(((floor(uv.y)%2)-0.5)*2);                uv.x+=(floor(uv.y)%2)*_xOffset;                //uv.y+=(floor(uv.x)%2)*_yOffset;                fixed4 col = tex2D(_MainTex, uv);//return fixed4(1,1,1,1);                return col*i.color;            &#125;            ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片置灰</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E7%BD%AE%E7%81%B0/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E7%BD%AE%E7%81%B0/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;UI/ImageGrey&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #pragma multi_compile_local _ UNITY_UI_CLIP_RECT            #pragma multi_compile_local _ UNITY_UI_ALPHACLIP            struct appdata_t            &#123;                float4 vertex   : POSITION;                float4 color    : COLOR;                float2 texcoord : TEXCOORD0;                UNITY_VERTEX_INPUT_INSTANCE_ID            &#125;;            struct v2f            &#123;                float4 vertex   : SV_POSITION;                fixed4 color    : COLOR;                float2 texcoord  : TEXCOORD0;                float4 worldPosition : TEXCOORD1;                UNITY_VERTEX_OUTPUT_STEREO            &#125;;            sampler2D _MainTex;            fixed4 _Color;            fixed4 _TextureSampleAdd;            float4 _ClipRect;            float4 _MainTex_ST;            v2f vert(appdata_t v)            &#123;                v2f OUT;                UNITY_SETUP_INSTANCE_ID(v);                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);                OUT.worldPosition = v.vertex;                OUT.vertex = UnityObjectToClipPos(OUT.worldPosition);                OUT.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex);                OUT.color = v.color * _Color;                return OUT;            &#125;            fixed4 frag(v2f IN) : SV_Target            &#123;                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;                fixed3 greyColor = dot(color.rgb, fixed3(0.22, 0.707, 0.09));                color.rgb = greyColor.rgb;                #ifdef UNITY_UI_CLIP_RECT                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                #endif                #ifdef UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过github 发布package</title>
      <link href="/2023/06/18/Unity/UPM/"/>
      <url>/2023/06/18/Unity/UPM/</url>
      
        <content type="html"><![CDATA[<h3 id="发布自己的包"><a href="#发布自己的包" class="headerlink" title="发布自己的包"></a>发布自己的包</h3><ul><li>1、创建一个正常的unity项目</li><li>2、在Assets 目录下 创建好内容（必须包含内容如下图）</li><li>3、把做好的内容推送到主分支</li><li>4、<code>git subtree split --prefix=Assets/xxx --branch upm</code></li><li>5、推送 upm 分支到github（<code>git push origin upm:upm</code>）</li><li>6、<code>git tag 1.0.0 upm</code></li><li>7、<code>git push origin upm --tags</code></li></ul><p>后续修改只需要重复执行3-7即可</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>打开unity package manager</li><li>点击 add package form git</li><li>填写 <a href="https://github.com/OnClick9927/NodeGraph.git#1.0.1">https://github.com/OnClick9927/NodeGraph.git#1.0.1</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>删除远程tag git push origin :refs&#x2F;tags&#x2F;标签名  </li><li>删除本地 tag git tag -d 标签名</li></ul><p><img src="/../../../Pic/Unity/UPM/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-接口及其他定义的说明</title>
      <link href="/2023/06/09/Doc/WooPool/WooPool-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/06/09/Doc/WooPool/WooPool-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="IObjectPool"><a href="#IObjectPool" class="headerlink" title="IObjectPool"></a>IObjectPool</h2><p>定义了对象池的<strong>对象数量</strong>、<strong>对象类型</strong>和<strong>回收方法</strong></p><pre><code class="csharp">public interface IObjectPool:IDisposable</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>获取当前对象池里对象的个数</td></tr><tr><td>type</td><td>获取当前对象池中对应对象的对象类型</td></tr></tbody></table><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Set(object,IPoolArgs)</td><td>将对象回收，也就是将对象放回到对象池中<br />回收成功时返回<code>true</code>，失败时返回<code>false</code></td></tr></tbody></table><h2 id="IPoolObject"><a href="#IPoolObject" class="headerlink" title="IPoolObject"></a>IPoolObject</h2><p>定义了对象池对象的生命周期的三个阶段</p><pre><code class="csharp">public interface IPoolObject : IDisposable</code></pre><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>OnAllocate()</td><td>在对象被创建时调用</td></tr><tr><td>OnGet()</td><td>在对象从对象池中被取出时调用</td></tr><tr><td>OnSet()</td><td>在对象被回收回对象池时调用</td></tr></tbody></table><h2 id="IPoolArgs"><a href="#IPoolArgs" class="headerlink" title="IPoolArgs"></a>IPoolArgs</h2><p>此接口用于抽象构造的参数</p><pre><code class="csharp">public interface IPoolArgs</code></pre><h2 id="PoolUnit"><a href="#PoolUnit" class="headerlink" title="PoolUnit"></a>PoolUnit</h2><p>定义对象池的销毁状态和销毁方法</p><pre><code class="csharp">public abstract class PoolUnit : IDisposable</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>disposed</td><td>当前对象池是否被销毁</td></tr></tbody></table><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>OnDispose()</td><td>在对象池被销毁时调用</td></tr><tr><td>Dispose()</td><td>销毁对象池</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-全局对象池</title>
      <link href="/2023/06/08/Doc/WooPool/WooPool-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/08/Doc/WooPool/WooPool-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>全局的对象池，不用考虑创建对象池，不用考虑对象的类型，即拿即用，用完归还。</p><ul><li>全局对象池操作使用PoolEx类</li><li><em><strong>注意回收时要自己初始化数据！！！</strong></em></li></ul><pre><code class="csharp">public static class PoolEx</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>GetGlbalPoolCount&lt;T&gt;()</td><td>public</td><td>从对象池中获取对应类型的数组对象</td></tr><tr><td>SetGlbalPool&lt;T&gt;(ObjectPool&lt;T&gt;)</td><td>public</td><td>将数组对象放回对象池</td></tr><tr><td>GlobalAllocate&lt;T&gt;(IPoolArgs)</td><td>public</td><td>全局分配对应类型的对象</td></tr><tr><td>GlobalAllocate(Type,IPoolArgs)</td><td>public</td><td>全局分配对应类型的对象</td></tr><tr><td>GlobalRecyle&lt;T&gt;(T,IPoolArgs)</td><td>public</td><td>全局回收</td></tr><tr><td>GlobalAllocateArray&lt;T&gt;(int)</td><td>public</td><td>获取对应类型和长度的数组对象</td></tr></tbody></table><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code class="csharp">//全局对象池示例void GlobalPoolExample() &#123;    //全局获取一个对象    var human = PoolEx.GlobalAllocate&lt;Human&gt;();    //全局回收一个对象    PoolEx.GlobalRecyle(human);    //从全局对象池中获取一个长度为10的数组对象    var arr = PoolEx.GlobalAllocateArray&lt;Human&gt;(10);    //Human类的定义在第一个示例    arr[0] = new Human(33, &quot;吉良吉影&quot;);    arr[0].Say();    //回收掉这个数组对象    PoolEx.GlobalRecyle(arr);    //重新从全局对象池中获取长度为10的数组对象    arr = PoolEx.GlobalAllocateArray&lt;Human&gt;(10);    arr[0].Say();    PoolEx.GlobalRecyle(arr);    //可以发现是和原先同样的对象    //因此回收的时候需要注意初始化数据！！！！&#125;//示例所需的类public class Human&#123;    public readonly int age;    public readonly string name;    public Human(int age, string name)    &#123;        this.age = age;        this.name = name;    &#125;    public Human()     &#123;        age= 0;        name = &quot;无名&quot;;    &#125;    public void Say()    &#123;        Console.WriteLine($&quot;我的名字叫&#123;name&#125;,&#123;age&#125;岁&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-基类对象池</title>
      <link href="/2023/06/07/Doc/WooPool/WooPool-%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/07/Doc/WooPool/WooPool-%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设置一个基类，可以从这个对象池中拿出继承这个基类的对象</p><pre><code class="csharp">public abstract class BaseTypePool&lt;T&gt; : PoolUnit</code></pre><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>基类对象池的本质是一个Key为 类型，Value为 对应类型对象池 的字典。获取对象时，根据类型找到对应的对象池，并从对应的对象池中获取对象。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>注：下面的<code>Object</code>类型是泛型类型，为了区分基类的泛型<code>T</code></p><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>SetPool&lt;Object&gt;(ObjectPool&lt;Object&gt;)</td><td>public</td><td>将对象池放入基类对象池中</td></tr><tr><td>SetPool(Type, IObjectPool)</td><td>public</td><td>将对应类型的对象池放入基类对象池中</td></tr><tr><td>GetPool&lt;Object&gt;()</td><td>public</td><td>根据类型获取对象池</td></tr><tr><td>GetPool(Type)</td><td>public</td><td>根据类型获取对象池</td></tr><tr><td>CreatePool(Type)</td><td>protected virtual</td><td>创建对象池</td></tr><tr><td>Get&lt;Object&gt;(IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的对象</td></tr><tr><td>Get(Type,IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的对象</td></tr><tr><td>Set&lt;Object&gt;(Object,IPoolArgs)</td><td>public</td><td>将对应类型的对象放回对象池</td></tr><tr><td>Set(Type,T,IPoolArgs)</td><td>public</td><td>将对应类型的对象放回对象池</td></tr><tr><td>GetPoolCount&lt;Object&gt;()</td><td>public</td><td>获取对应类型的对象池中对象的数量</td></tr><tr><td>GetPoolCount(Type)</td><td>public</td><td>获取对应类型的对象池中对象的数量</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁基类对象池</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//定义一个叫IObject的接口public interface IObject &#123; &#125;//创建两个实现IObject接口的类public class Obj_A : IObject &#123; &#125;public class Obj_B : IObject &#123; &#125;//以IObject为基类定义一个基类对象池public class MyBaseTypePool : BaseTypePool&lt;IObject&gt; &#123; &#125;//定义一个存放Obj_A对象的对象池public class ObjectPoolA : ObjectPool&lt;Obj_A&gt;&#123;    protected override Obj_A CreateNew(IPoolArgs arg)    &#123;        return new Obj_A();    &#125;&#125;//基类对象池使用示例方法void BaseTypePoolExample()&#123;    //创建基类对象池    MyBaseTypePool pool = new MyBaseTypePool();    //从基类对象池中获取Obj_A类型的对象    IObject _obj = pool.Get&lt;Obj_A&gt;();    //将对象放回    pool.Set(_obj);    //从基类对象池中获取Obj_B类型的对象    _obj = pool.Get(typeof(Obj_B));    //将对象放回    pool.Set(_obj);    //从基类对象池中获取Obj_A类型的对象池    ObjectPool&lt;Obj_A&gt; objPoolA = pool.GetPool&lt;Obj_A&gt;();    //也可使用如下方法    //ObjectPool&lt;Obj_A&gt; objPoolA = (ObjectPool&lt;Obj_A&gt;)pool.GetPool(typeof(Obj_A));    //创建一个Obj_A的对象池，替换基类对象池中的对应对象池    pool.SetPool(new ObjectPoolA());&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-数组对象池</title>
      <link href="/2023/06/06/Doc/WooPool/WooPool-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/06/Doc/WooPool/WooPool-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>能拿出数组对象的对象池</p><pre><code class="csharp">public class ArrayPool&lt;T&gt; : ObjectPool&lt;T[]&gt;</code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>参数ArrayPoolArg用于传入数组长度</p><pre><code class="csharp">public struct ArrayPoolArg : IPoolArgs</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>数组长度</td></tr></tbody></table><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="csharp">public ArrayPoolArg(int length)</code></pre><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>int</td><td>用于参数构造时传入数组长度</td></tr></tbody></table><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>Get(IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的数组对象</td></tr><tr><td>Set(T[],IPoolArgs)</td><td>public</td><td>将数组对象放回对象池</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁基类对象池</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">void ArrayPoolExample()&#123;    //创建数组对象池，示例使用存放int值的数组    var pool = new ArrayPool&lt;int&gt;();    //从数组对象池中拿出一个长度为2的数组    var objA = pool.Get(new ArrayPoolArg(2));    Console.WriteLine(&quot;取出的数组长度为&quot;+objA.Length);    //将数组中的第一个元素设置成1    objA[0] = 1;    //将数组回收，再拿出一个长度为2的数组    pool.Set(objA);    objA = pool.Get(new ArrayPoolArg(2));    //打印第一个元素    Console.WriteLine(&quot;数组的第一个元素的值为：&quot;+ objA[0]);    //因此需要注意放回数组时 根据自己需求判断是否需要重置一下数组&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-Activator构建对象池</title>
      <link href="/2023/06/05/Doc/WooPool/WooPool-Activator%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/05/Doc/WooPool/WooPool-Activator%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用Activator自动构建对象的对象池，支持传入对象创建时所需的参数</p><pre><code class="csharp">public class ActivatorCreatePool&lt;T&gt; : ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">public ActivatorCreatePool(params object[] args)</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>args</code></td><td>object[]</td><td>用于对象构造时所需的参数</td></tr></tbody></table><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>获取当前对象池里对象的个数（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>type</td><td>获取当前对象池中对应对象的对象类型（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>disposed</td><td>当前对象池是否被销毁（继承自 PoolUnit）</td></tr></tbody></table><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Get()</td><td>从对象池中获取对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Set(T)</td><td>将对象回收到对象池中（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Clear()</td><td>清空对象池中的所有对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Clear(int)</td><td>清除对象池里一定数量的对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Dispose()</td><td>销毁对象池（继承自 PoolUnit）</td></tr></tbody></table><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code class="csharp">/// &lt;summary&gt;/// 示例将会用到的示例类型，构造函数不含参数/// &lt;/summary&gt;public class Bottle &#123; &#125;/// &lt;summary&gt;/// 示例将会用到的示例类型，构造函数包含age和name两个参数/// &lt;/summary&gt;public class Human&#123;    public readonly int age;    public readonly string name;    public Human(int age, string name)    &#123;        this.age = age;        this.name = name;    &#125;    public void Say()    &#123;        Console.WriteLine($&quot;我的名字叫&#123;name&#125;,&#123;age&#125;岁&quot;);    &#125;&#125;/// &lt;summary&gt;/// ActivatorPool的使用示例/// &lt;/summary&gt;private void ActivatorPoolExample()&#123;    //创建一个存放Bottle的对象池    ActivatorCreatePool&lt;Bottle&gt; pool = new ActivatorCreatePool&lt;Bottle&gt;();        //从对象池中获取一个对象    var bottle = pool.Get();        //用对象池的Set方法将对象放回对象池    pool.Set(bottle);        //创建一个能够根据参数创建对象的对象池    //此处以Human类为例，传入age和name    ActivatorCreatePool&lt;Human&gt; humanPool = new ActivatorCreatePool&lt;Human&gt;(33, &quot;吉良吉影&quot;);    var human = humanPool.Get();    //调用对象的Say方法    human.Say();    //输出内容为 我的名字叫吉良吉影,33岁&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-委托对象池</title>
      <link href="/2023/06/04/Doc/WooPool/WooPool-%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/04/Doc/WooPool/WooPool-%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用委托创建对象的对象池，用于在CreateNew()中调用,方便外部动态修改创建对象的方法</p><pre><code class="csharp">public abstract class DelegatePool&lt;T&gt; : ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">public DelegatePool(Func&lt;T&gt; create)</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>create</td><td>Func&lt;T&gt;</td><td>创建对象的委托</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//用于示例的类型public class Obj_A &#123; &#125;//定义一个存放Obj_A对象的委托对象池public class DelegatePoolA : DelegatePool&lt;Obj_A&gt;&#123;    public DelegatePoolA(Func&lt;Obj_A&gt; create) : base(create)    &#123;    &#125;&#125;//创建Obj_A对象的方法Obj_A CreateObject()&#123;    Console.WriteLine(&quot;我创建了一个对象，哈哈哈哈哈哈！&quot;);    return new Obj_A();&#125;void DelegatePoolExample()&#123;    //创建委托对象池    var pool = new DelegatePoolA(CreateObject);    //获取一个对象，内部创建新对象时会调用方法    var objA = pool.Get();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-有容量的对象池</title>
      <link href="/2023/06/03/Doc/WooPool/WooPool-%E6%9C%89%E5%AE%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/03/Doc/WooPool/WooPool-%E6%9C%89%E5%AE%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>限制容量大小的对象池</p><pre><code class="csharp">public abstract class CapacityPool&lt;T&gt;: ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">protected CapacityPool(int capacity) : base() &#123; this._capacity = capacity; &#125;</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>capacity</td><td>int</td><td>对象池的最大容量</td></tr></tbody></table><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>capacity</td><td>对象池的最大容量，创建后可重新修改</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//用于示例的类型public class Obj_A &#123; &#125;//定义一个存放Obj_A对象的对象池public class CapacityPoolA : CapacityPool&lt;Obj_A&gt;&#123;    public CapacityPoolA(int capacity) : base(capacity)    &#123;    &#125;    protected override Obj_A CreateNew(IPoolArgs arg)    &#123;        return new Obj_A();    &#125;&#125;//限制大小对象池的示例void CapacityPoolExample()&#123;    //创建对象池，设置大小为1    var pool = new CapacityPoolA(1);    //放入一个对象，不会报错    Console.WriteLine(&quot;回收第一个对象，结果为：&quot; + pool.Set(new Obj_A()));    //再放入一个对象，会发现存放失败    Console.WriteLine(&quot;回收第二个对象，结果为：&quot; + pool.Set(new Obj_A()));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-基本定义</title>
      <link href="/2023/06/02/Doc/WooPool/WooPool-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/06/02/Doc/WooPool/WooPool-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对象池的基本定义，包括基本属性、基本方法、生命周期</p><pre><code class="csharp">public abstract class ObjectPool&lt;T&gt; : PoolUnit, IDisposable, IObjectPool</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>public</td><td>获取当前对象池里对象的个数</td></tr><tr><td>type</td><td>public</td><td>获取当前对象池中对应对象的对象类型</td></tr><tr><td>pool</td><td>protected</td><td>对象池的数据容器，默认是队列</td></tr><tr><td>para</td><td>protected</td><td>锁</td></tr></tbody></table><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>Get(IPoolArgs)</td><td>public virtual</td><td>从对象池中获取对象</td></tr><tr><td>Set(object,IPoolArgs)</td><td>public</td><td>将对象回收到对象池中，回收成功时返回true，失败时返回false</td></tr><tr><td>Set(T,IPoolArgs)</td><td>public virtual</td><td>将对象回收到对象池中，回收成功时返回true，失败时返回false</td></tr><tr><td>RealSet(T,IPoolArgs)</td><td>protected</td><td>对象回收的实际方法，上面两个只是用于调用的</td></tr><tr><td>Clear(IPoolArgs)</td><td>public</td><td>清空对象池中的所有对象</td></tr><tr><td>Clear(int,IPoolArgs)</td><td>public</td><td>清除对象池里一定数量的对象</td></tr><tr><td>CreateNew(IPoolArgs )</td><td>protected abstract</td><td>创建对象的方法，需要子类实现</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁对象池（继承自 PoolUnit）</td></tr></tbody></table><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>需要在对应周期增加操作时可以重写对应的方法</p><table><thead><tr><th>生命周期名</th><th>说明</th></tr></thead><tbody><tr><td>OnCreate(T, IPoolArgs)</td><td>对象池创建对象时调用</td></tr><tr><td>OnGet(T, IPoolArgs)</td><td>对象池中的对象被获取时调用</td></tr><tr><td>OnSet(T, IPoolArgs)</td><td>对象被回收时调用，返回false时表示不能回收</td></tr><tr><td>OnClear(T, IPoolArgs)</td><td>对象池中的对象被清除时调用</td></tr><tr><td>OnDispose()</td><td>对象池被销毁时调用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-简介</title>
      <link href="/2023/06/01/Doc/WooPool/WooPool-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/06/01/Doc/WooPool/WooPool-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h4 id="为什么要使用对象池？"><a href="#为什么要使用对象池？" class="headerlink" title="为什么要使用对象池？"></a>为什么要使用对象池？</h4><p>对象在生成和销毁时都是需要一定开销的，如果某个类型频繁地生成对象和销毁对象，会导致开销过大，影响性能。</p><p>举个例子：</p><ol><li><p>我们厨房里的碗架（对象池），容纳着很多个碗（对象）。</p></li><li><p>我们在盛饭的时候，从碗架里拿出一个碗（从对象池中拿出一个对象）。</p></li><li><p>在吃完饭之后，洗碗（对象的初始化）、放回碗架（将对象回收，放回到对象池中）。</p></li></ol><p>上述例子中，如果不使用对象池，也就意味着碗是一次性的，也就是吃完就把碗摔了，然后要用的时候再花钱买个新的碗，这样的做法很明显是特别烧钱（浪费资源）的。</p><h4 id="WooPool特点"><a href="#WooPool特点" class="headerlink" title="WooPool特点"></a>WooPool特点</h4><ul><li><p>支持传入参数构建对象</p></li><li><p>支持对象池创建对象时调用委托</p></li><li><p>支持限定对象池大小</p></li><li><p>支持从基类对象池中取出子类</p></li><li><p>支持数组对象池</p></li><li><p>支持操作非常简单的全局对象池</p></li><li><p>支持多个生命周期</p></li><li><p>支持自己扩展对象池</p></li></ul><h3 id="感谢使用WooPool！"><a href="#感谢使用WooPool！" class="headerlink" title="感谢使用WooPool！"></a>感谢使用WooPool！</h3><h3 id="欢迎加入QQ交流群782290296，各路大佬给你解惑！"><a href="#欢迎加入QQ交流群782290296，各路大佬给你解惑！" class="headerlink" title="欢迎加入QQ交流群782290296，各路大佬给你解惑！"></a>欢迎加入QQ交流群<a href="https://jq.qq.com/?_wv=1027&k=sbKbmsTY">782290296</a>，各路大佬给你解惑！</h3>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat 安装教程</title>
      <link href="/2023/05/23/Tools/Navicat/"/>
      <url>/2023/05/23/Tools/Navicat/</url>
      
        <content type="html"><![CDATA[<h2 id="Navicat-安装教程-下载"><a href="#Navicat-安装教程-下载" class="headerlink" title="Navicat 安装教程 下载"></a>Navicat 安装教程 <a href="/Files/DB/Navicat16-jihuo.zip">下载</a></h2><p>1、正常安装（装完不要打开）<br>2、断网<br>3、右键NavicatCracker.exe以管理员身份运行。<br>4、选择刚刚的安装目录，点击Patch<br>5、点击是<br>6、打开注册软件.点击Generate生成注册码.再点击copy.<br>7、打开Navicat16,点击注册<br>8、粘贴刚刚生成的注册码,点击激活.<br>9、点击手动激活<br>10、复制下图中生成的请求码<br>11、将 Navicat 给的请求码复制到注册机 Request Code 中<br>12、点击 Generate Activation Code进行激活.复制激活码.<br>13、然后粘贴激活码.点击激活即可.</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-安装</title>
      <link href="/2023/05/23/Doc/WooTween/2-WooTween-%E5%AE%89%E8%A3%85/"/>
      <url>/2023/05/23/Doc/WooTween/2-WooTween-%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><ul><li>打开 unity package manager</li><li>点击 add package form git</li><li>输入 <a href="https://github.com/OnClick9927/WooTween.git#1.0.0">https://github.com/OnClick9927/WooTween.git#1.0.0</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-简介</title>
      <link href="/2023/05/22/Doc/WooTween/1-WooTween-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/05/22/Doc/WooTween/1-WooTween-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="WooTween介绍"><a href="#WooTween介绍" class="headerlink" title="WooTween介绍"></a>WooTween介绍</h2><ul><li>内容：实现一个简易的、易扩展、支持编辑器预览的动画模块</li><li>适合人群<ul><li>高手 切磋</li><li>中手 理解、提高代码设计能力</li><li>低手 感受代码的魅力，扩展思路</li></ul></li></ul><h2 id="内容组成"><a href="#内容组成" class="headerlink" title="内容组成"></a>内容组成</h2><ul><li>0、对象池           默默无闻的螺丝钉</li><li>1、驱动器           好司机</li><li>2、转换器           翻译官</li><li>3、TweenValue      单程车</li><li>4、Tween           花样百出的乘客</li><li>5、Component       好保姆</li></ul><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><ul><li>为什么要使用对象池？<ul><li>频繁的 new 对象，会对GC 有压力</li><li>在tween的实现中 ，需要大量的的对象，这些对象并不是一直在使用</li></ul></li><li>包含内容：<ul><li>通用对象池，最简单的对象池</li><li>自动对象对象池，当对象不够时候，自动创建对象</li><li>全局对象池扩展，全局分配任意对象，简化使用</li></ul></li></ul><h2 id="驱动器"><a href="#驱动器" class="headerlink" title="驱动器"></a>驱动器</h2><ul><li>这是什么玩意儿？<ul><li>整个tween 模块的驱动器</li></ul></li><li>为什么需要？<ul><li>整个模块需要逐帧的运行，他的作用就是驱动模块运行</li><li>我们的tween是支持编辑器预览的，所以编辑器和运行时需要各自的驱动</li></ul></li></ul><h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><ul><li>这是什么玩意儿？<ul><li>曲线转换器</li></ul></li><li>为什么需要？<ul><li>我们的tween是具有曲线运行能力的</li><li>我们的tween需要支持多种曲线</li><li>我们的tween需要支持多种曲线类型</li></ul></li></ul><h2 id="TweenValue"><a href="#TweenValue" class="headerlink" title="TweenValue"></a>TweenValue</h2><ul><li>这是什么玩意儿？<ul><li>负责把一个值 逐帧的变化到目标值</li></ul></li><li>为什么需要？<ul><li>他是单向的</li><li>他是整个tween的核心之一</li></ul></li></ul><h2 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h2><ul><li>这是什么玩意儿？<ul><li>建立于 TweenValue 之上，与用户交互</li></ul></li><li>为什么需要？<ul><li>提供 双方向运行能力</li><li>提供 中断、重启、恢复能力</li></ul></li></ul><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul><li>这是什么玩意儿？<ul><li>直接在编辑器的环境之下，运行动画</li></ul></li><li>为什么需要？<ul><li>更加直观的看到效果</li><li>不再需要超多的代码</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-简介</title>
      <link href="/2023/05/19/Doc/WooAsset/0-WooAsset-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/05/19/Doc/WooAsset/0-WooAsset-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a><a href="https://github.com/OnClick9927/WooAsset">地址</a></h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>WooAsset可以满足以下任何需求：</p><ul><li>发布一个不包含任何游戏资源的安装包，然后玩家边玩边下载。</li><li>发布一个可以保证前期体验的安装包，然后玩家自己选择下载关卡内容。</li><li>发布一个保证300MB以下内容的安装包，然后进入游戏之前把剩余内容下载完毕。</li><li>发布一个偏单机的游戏安装包，在网络畅通的时候，支持正常更新。在没有网络的时候，支持游玩老版本。</li><li>发布一个MOD游戏安装包，玩家可以把自己制作的MOD内容上传到服务器，其它玩家可以下载游玩。</li><li>我们在制作一个超大体量的项目，有上百GB的资源内容，每次构建都花费大量时间，是否可以分工程构建？</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊-毛玻璃</title>
      <link href="/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/"/>
      <url>/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../../Pic/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83.png" alt="效果"></p><pre><code class="cg">Shader &quot;UI/UiObscure&quot;&#123;    Properties    &#123;        _Radius(&quot;Radius&quot;, Range(1, 255)) = 1        _MainTex(&quot;Tint Color (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Interval(&quot;Blur Nuance&quot;,Range(0.1, 100)) = 1        [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)] _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        [HideInInspector] _Stencil (&quot;Stencil ID&quot;, Float) = 0        [HideInInspector][Enum(UnityEngine.Rendering.StencilOp)] _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        [HideInInspector] _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        [HideInInspector] _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        [HideInInspector] _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        // Outline properties are drawn via custom editor.        [HideInInspector] _OutlineWidth(&quot;Outline Width&quot;, Range(0,8)) = 3.0        [HideInInspector] _OutlineColor(&quot;Outline Color&quot;, Color) = (1,1,0,1)        [HideInInspector] _OutlineReferenceTexWidth(&quot;Reference Texture Width&quot;, Int) = 1024        [HideInInspector] _ThresholdEnd(&quot;Outline Threshold&quot;, Range(0,1)) = 0.25        [HideInInspector] _OutlineSmoothness(&quot;Outline Smoothness&quot;, Range(0,1)) = 1.0        [HideInInspector][MaterialToggle(_USE8NEIGHBOURHOOD_ON)] _Use8Neighbourhood(&quot;Sample 8 Neighbours&quot;, Float) = 1        [HideInInspector] _OutlineMipLevel(&quot;Outline Mip Level&quot;, Range(0,3)) = 0    &#125;     Category    &#123;        Tags&#123; &quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;         SubShader        &#123;                     Stencil            &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]            &#125;                        Cull Off            Lighting Off            ZWrite Off            ZTest [unity_GUIZTestMode]            Fog &#123; Mode Off &#125;            Blend One OneMinusSrcAlpha            ColorMask [_ColorMask]                    GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM                #pragma vertex vert                #pragma fragment frag                #pragma fragmentoption ARB_precision_hint_fastest                #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                    v2f o;                    o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                    float scale = -1.0;                    #else                    float scale = 1.0;                    #endif                    o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                    o.uvgrab.zw = o.vertex.zw;                    return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                float _Interval;                half4 frag(v2f i) : COLOR                &#123;                    half4 sum = half4(0,0,0,0);                                 #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                                 sum += GRABXYPIXEL(0.0, 0.0);                    int measurments = 1;                                 for (float range = _Interval; range &lt;= _Radius; range += _Interval)                    &#123;                        sum += GRABXYPIXEL(range, range);                        sum += GRABXYPIXEL(range, -range);                        sum += GRABXYPIXEL(-range, range);                        sum += GRABXYPIXEL(-range, -range);                        measurments += 4;                    &#125;                    return sum / measurments;                &#125;            ENDCG            &#125;        GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma fragmentoption ARB_precision_hint_fastest            #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                float scale = -1.0;                    #else                float scale = 1.0;                    #endif                o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                o.uvgrab.zw = o.vertex.zw;                return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                    half4 frag(v2f i) : COLOR                &#123;                            half4 sum = half4(0,0,0,0);                float radius = 1.41421356237 * _Radius;                                #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                            sum += GRABXYPIXEL(0.0, 0.0);                int measurments = 1;                            for (float range = 1.41421356237f; range &lt;= radius * 1.41; range += 1.41421356237f)                &#123;                sum += GRABXYPIXEL(range, 0);                sum += GRABXYPIXEL(-range, 0);                sum += GRABXYPIXEL(0, range);                sum += GRABXYPIXEL(0, -range);                measurments += 4;                &#125;                            return sum / measurments;                &#125;            ENDCG            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可穿透按钮</title>
      <link href="/2023/05/16/Unity/UGUI/%E6%95%88%E6%9E%9C/%E5%8F%AF%E7%A9%BF%E9%80%8F%E6%8C%89%E9%92%AE/"/>
      <url>/2023/05/16/Unity/UGUI/%E6%95%88%E6%9E%9C/%E5%8F%AF%E7%A9%BF%E9%80%8F%E6%8C%89%E9%92%AE/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public class PenetratableButton : Button&#123;    List&lt;RaycastResult&gt; results = new List&lt;RaycastResult&gt;();    [Header(&quot;向下穿几层&quot;)]    public int depth = 1;    private List&lt;GameObject&gt; gos = new List&lt;GameObject&gt;();    public override void OnPointerDown(PointerEventData eventData)    &#123;        gos.Clear();        results.Clear();        base.OnPointerDown(eventData);        EventSystem.current.RaycastAll(eventData, results);        GameObject current = eventData.pointerCurrentRaycast.gameObject;        int _depth = 0;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject == current)            &#123;                _depth = results[i].depth;                break;            &#125;        &#125;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject != current &amp;&amp; results[i].depth &gt;= _depth - this.depth)            &#123;                gos.Add(results[i].gameObject);                ExecuteEvents.Execute(results[i].gameObject, eventData, ExecuteEvents.pointerDownHandler);            &#125;        &#125;    &#125;    public override void OnPointerUp(PointerEventData eventData)    &#123;        results.Clear();        base.OnPointerUp(eventData);        EventSystem.current.RaycastAll(eventData, results);        GameObject current = eventData.pointerCurrentRaycast.gameObject;        int _depth = 0;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject == current)            &#123;                _depth = results[i].depth;                break;            &#125;        &#125;        for (int i = 0; i &lt; gos.Count; i++)        &#123;            ExecuteEvents.Execute(gos[i].gameObject, eventData, ExecuteEvents.pointerUpHandler);        &#125;    &#125;    public override void OnPointerClick(PointerEventData eventData)    &#123;        results.Clear();        base.OnPointerClick(eventData);        EventSystem.current.RaycastAll(eventData, results);        GameObject current = eventData.pointerCurrentRaycast.gameObject;        int _depth = 0;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject == current)            &#123;                _depth = results[i].depth;                break;            &#125;        &#125;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject != current &amp;&amp; results[i].depth &gt;= _depth - this.depth)            &#123;                ExecuteEvents.Execute(results[i].gameObject, eventData, ExecuteEvents.pointerClickHandler);            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="csharp">using UnityEditor;[CustomEditor(typeof(PenetratableButton))]public class PenetratableButtonEditor : Editor&#123;    private SerializedProperty property;    private void OnEnable()    &#123;        property = serializedObject.FindProperty(&quot;depth&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        EditorGUILayout.PropertyField(property);        &#123;            serializedObject.ApplyModifiedProperties();        &#125;        base.OnInspectorGUI();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书写方式</title>
      <link href="/2023/05/15/README/"/>
      <url>/2023/05/15/README/</url>
      
        <content type="html"><![CDATA[<h2 id="sadasda"><a href="#sadasda" class="headerlink" title="sadasda"></a>sadasda</h2><h4 id="57d8a"><a href="#57d8a" class="headerlink" title="57d8a"></a>57d8a</h4><ul><li>哈哈哈</li><li>康康康<ul><li>777</li><li>888</li></ul></li><li>999</li></ul><pre><code class="csharp">public class A&#123;    public void DO()&#123;&#125;&#125;</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><img src="/../Pic/R-C.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
