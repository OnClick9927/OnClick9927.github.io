<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>圆形图片毛边处理</title>
      <link href="/2023/07/03/Unity/UGUI/%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%E6%AF%9B%E8%BE%B9%E5%A4%84%E7%90%86/"/>
      <url>/2023/07/03/Unity/UGUI/%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%E6%AF%9B%E8%BE%B9%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">using System.Collections.Generic;using UnityEngine;using UnityEngine.Sprites;using UnityEngine.UI;public class CircleImage : Image&#123;    /// &lt;summary&gt;    ///圆形由多少块三角形拼成即圆形精度，值越大精度越高    /// &lt;/summary&gt;    [SerializeField]    private int segements = 100;    /// &lt;summary&gt;    /// 显示部分占圆形的百分比.    /// &lt;/summary&gt;    [SerializeField]    private float showPercent = 1f;    private readonly Color32 GRAY_COLOR = new Color32(60, 60, 60, 255);    private List&lt;Vector3&gt; _vertexList;    protected override void OnPopulateMesh(VertexHelper vh)    &#123;        vh.Clear();        _vertexList = new List&lt;Vector3&gt;();        AddVertex(vh, segements);        AddTriangle(vh, segements);    &#125;    private void AddVertex(VertexHelper vh, int segements)    &#123;        float width = rectTransform.rect.width;        float heigth = rectTransform.rect.height;        int realSegments = (int)(segements * showPercent);        //四维向量可代表着二维平面的四个坐标（uv.x,uv.y）,(uv.z,uv.y),(uv.x,uv.w)(uv.z,uv.w)        Vector4 uv = overrideSprite != null ? DataUtility.GetOuterUV(overrideSprite) : Vector4.zero;        float uvWidth = uv.z - uv.x;        float uvHeight = uv.w - uv.y;        //获取贴图uv平面中心点        Vector2 uvCenter = new Vector2(uvWidth * 0.5f, uvHeight * 0.5f);        Vector2 convertRatio = new Vector2(uvWidth / width, uvHeight / heigth);        float radian = (2 * Mathf.PI) / segements;        float radius = width * 0.5f;        //轴心点设置        Vector2 originPos = new Vector2((0.5f - rectTransform.pivot.x) * width, (0.5f - rectTransform.pivot.y) * heigth);        Vector2 vertPos = Vector2.zero;        Color32 colorTemp = GetOriginColor();        UIVertex origin = GetUIVertex(colorTemp, originPos, vertPos, uvCenter, convertRatio);        vh.AddVert(origin);        int vertexCount = realSegments + 1;        float curRadian = 0;        Vector2 posTermp = Vector2.zero;        //遍历所有顶点信息        for (int i = 0; i &lt; segements + 1; i++)        &#123;            float x = Mathf.Cos(curRadian) * radius;            float y = Mathf.Sin(curRadian) * radius;            curRadian += radian;            if (i &lt; vertexCount)            &#123;                colorTemp = color;            &#125;            else            &#123;                colorTemp = GRAY_COLOR;            &#125;            posTermp = new Vector2(x, y);            UIVertex vertexTemp = GetUIVertex(colorTemp, posTermp + originPos, posTermp, uvCenter, convertRatio);            vh.AddVert(vertexTemp);            _vertexList.Add(posTermp + originPos);        &#125;    &#125;    /// &lt;summary&gt;    /// 设置颜色比重    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private Color32 GetOriginColor()    &#123;        Color32 colorTemp = (Color.white - GRAY_COLOR) * showPercent;        return new Color32(            (byte)(GRAY_COLOR.r + colorTemp.r),            (byte)(GRAY_COLOR.g + colorTemp.g),            (byte)(GRAY_COLOR.b + colorTemp.b),            255);    &#125;    private void AddTriangle(VertexHelper vh, int realSegements)    &#123;        int id = 1;        for (int i = 0; i &lt; realSegements; i++)        &#123;            vh.AddTriangle(id, 0, id + 1);//顺时针生成面片            id++;        &#125;    &#125;    private UIVertex GetUIVertex(Color32 col, Vector3 pos, Vector2 uvPos, Vector2 uvCenter, Vector2 uvScale)    &#123;        UIVertex vertexTemp = new UIVertex();        vertexTemp.color = col;        vertexTemp.position = pos;        vertexTemp.uv0 = new Vector2(uvPos.x * uvScale.x + uvCenter.x, uvPos.y * uvScale.y + uvCenter.y);        return vertexTemp;    &#125;    //设置图形的点击响应区域    public override bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)    &#123;        Vector2 localPoint;        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, screenPoint, eventCamera, out localPoint);        return IsValid(localPoint);    &#125;    private bool IsValid(Vector2 localPoint)    &#123;        return GetCrossPointNum(localPoint, _vertexList) % 2 == 1;    &#125;    /// &lt;summary&gt;    /// 获取该点与图形区域相交点的数量 奇数表示在区域内 偶数表示在区域外    /// &lt;/summary&gt;    /// &lt;param name=&quot;localPoint&quot;&gt;&lt;/param&gt;    /// &lt;param name=&quot;vertexList&quot;&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    private int GetCrossPointNum(Vector2 localPoint, List&lt;Vector3&gt; vertexList)    &#123;        int count = 0;        Vector3 vert1 = Vector3.zero;        Vector3 vert2 = Vector3.zero;        int vertCount = vertexList.Count;        for (int i = 0; i &lt; vertCount; i++)        &#123;            vert1 = vertexList[i];            vert2 = vertexList[(i + 1) % vertCount];            if (IsYInRang(localPoint, vert1, vert2))            &#123;                if (localPoint.x &lt; GetX(vert1, vert2, localPoint.y))                &#123;                    count++;                &#125;            &#125;        &#125;        return count;    &#125;    //筛选     private bool IsYInRang(Vector2 localPoint, Vector3 vert1, Vector3 vert2)    &#123;        //该点y值是否在两点y值之间        if (vert1.y &gt; vert2.y)        &#123;            return localPoint.y &lt; vert1.y &amp;&amp; localPoint.y &gt; vert2.y;        &#125;        else        &#123;            return localPoint.y &lt; vert2.y &amp;&amp; localPoint.y &gt; vert1.y;        &#125;    &#125;    //两点求一直线再带入y值得出x值    private float GetX(Vector3 vert1, Vector3 vert2, float y)    &#123;        float k = (vert1.y - vert2.y) / (vert1.x - vert2.x);        return vert1.x + (y - vert1.y) / k;//vert2.x + (y - vert2.y)    &#125;&#125;</code></pre><pre><code class="csharp">//Editor文件下属性设置类using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEditor;[CustomEditor(typeof(CircleImage), true)][CanEditMultipleObjects]public class CircleImageEditor : UnityEditor.UI.ImageEditor&#123;    SerializedProperty _fillPercent;    SerializedProperty _segements;    protected override void OnEnable()    &#123;        base.OnEnable();        _fillPercent = serializedObject.FindProperty(&quot;showPercent&quot;);        _segements = serializedObject.FindProperty(&quot;segements&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        base.OnInspectorGUI();        serializedObject.Update();        EditorGUILayout.Slider(_fillPercent, 0, 1, new GUIContent(&quot;显示比率&quot;));        EditorGUILayout.PropertyField(_segements, new GUIContent(&quot;显示精度&quot;));        serializedObject.ApplyModifiedProperties();        if (GUI.changed)        &#123;            EditorUtility.SetDirty(target);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持超链接的Text</title>
      <link href="/2023/07/03/Unity/UGUI/%E6%94%AF%E6%8C%81%E8%B6%85%E9%93%BE%E6%8E%A5%E7%9A%84Text/"/>
      <url>/2023/07/03/Unity/UGUI/%E6%94%AF%E6%8C%81%E8%B6%85%E9%93%BE%E6%8E%A5%E7%9A%84Text/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">using System;using System.Collections.Generic;using System.Text;using System.Text.RegularExpressions;using UnityEngine;using UnityEngine.Events;using UnityEngine.EventSystems;using UnityEngine.UI;/// &lt;summary&gt;/// 文本控件,支持超链接/// &lt;/summary&gt;public class HyperlinkText : Text, IPointerClickHandler&#123;    /// &lt;summary&gt;    /// 超链接类    /// &lt;/summary&gt;    private class HyperlinkInfo    &#123;        /// &lt;summary&gt;        /// 超链接的字符串的开始字符的第一个顶点的索引        /// &lt;/summary&gt;        public int startIndex;        /// &lt;summary&gt;        /// 超链接的字符串的最后字符的最后一个顶点的索引        /// &lt;/summary&gt;        public int endIndex;        public string linkUrl;        /// &lt;summary&gt;        /// 超链接的覆盖区域        /// &lt;/summary&gt;        public readonly List&lt;Rect&gt; textValidAreas = new List&lt;Rect&gt;();    &#125;    /// &lt;summary&gt;    /// 解析完最终的文本    /// &lt;/summary&gt;    private string colorAddedStr;    /// &lt;summary&gt;    /// 超链接信息列表    /// &lt;/summary&gt;    private readonly List&lt;HyperlinkInfo&gt; hrefInfos = new List&lt;HyperlinkInfo&gt;();    /// &lt;summary&gt;    /// 文本构造器    /// &lt;/summary&gt;    protected static readonly StringBuilder textRebuild = new StringBuilder();    [Serializable]    public class HrefClickEvent : UnityEvent&lt;string&gt; &#123; &#125;    [SerializeField]    private HrefClickEvent onHrefClickCB = new HrefClickEvent();    /// &lt;summary&gt;    /// 超链接点击事件    /// &lt;/summary&gt;    public HrefClickEvent onHrefClick    &#123;        get &#123; return onHrefClickCB; &#125;        set &#123; onHrefClickCB = value; &#125;    &#125;    /// &lt;summary&gt;    /// 每个字符的面片有4个顶点    /// &lt;/summary&gt;    const int perCharVerCount = 4;    const string pattern = @&quot;&lt;a href=([^&gt;\n\s]+)&gt;(.*?)(&lt;/a&gt;)&quot;;    const string colorStartStr = &quot;&lt;color=#01EAFFFF&gt;&quot;;    const string colorEndStr = &quot;&lt;/color&gt;&quot;;    /// &lt;summary&gt;    /// 超链接正则    /// &lt;/summary&gt;    private static readonly Regex s_HrefRegex =        new Regex(pattern, RegexOptions.Singleline);    private HyperlinkText mHyperlinkText;    protected override void Awake()    &#123;        base.Awake();        mHyperlinkText = GetComponent&lt;HyperlinkText&gt;();    &#125;    protected override void OnEnable()    &#123;        base.OnEnable();        mHyperlinkText.onHrefClick.AddListener(OnHyperlinkTextInfo);    &#125;    protected override void OnDisable()    &#123;        base.OnDisable();        mHyperlinkText.onHrefClick.RemoveListener(OnHyperlinkTextInfo);    &#125;    public override void SetVerticesDirty()    &#123;        base.SetVerticesDirty();#if UNITY_EDITOR        if (UnityEditor.PrefabUtility.GetPrefabType(this) == UnityEditor.PrefabType.Prefab)        &#123;            return;        &#125;#endif             colorAddedStr = GetDealedText(text);    &#125;    protected override void OnPopulateMesh(VertexHelper toFill)    &#123;        print(&quot;OnPopulateMesh &quot;);        var orignText = m_Text;        m_Text = colorAddedStr;        base.OnPopulateMesh(toFill);        m_Text = orignText;        //UGUI的网格处理类        UIVertex vert = new UIVertex();        // 重新创建超链接包围框        foreach (var hrefInfo in hrefInfos)        &#123;            hrefInfo.textValidAreas.Clear();            //toFill.currentVertCount表示当前Text组件的所有网格的最后一个网格的顶点索引            //hrefInfo.startIndex大于它 是startIndex大于它运算出错了 运算出错 则跳过包围框生成            if (hrefInfo.startIndex &gt;= toFill.currentVertCount)            &#123;                continue;            &#125;            //获取startIndex所指示的顶点            toFill.PopulateUIVertex(ref vert, hrefInfo.startIndex);            var pos = vert.position;            var bounds = new Bounds(pos, Vector3.zero);            for (int i = hrefInfo.startIndex, m = hrefInfo.endIndex; i &lt; m; i++)            &#123;                if (i &gt;= toFill.currentVertCount)                &#123;                    break;                &#125;                toFill.PopulateUIVertex(ref vert, i);                pos = vert.position;                if (pos.x &lt; bounds.min.x || pos.y &lt; bounds.min.y) // 换行重新添加包围框                &#123;                    hrefInfo.textValidAreas.Add(new Rect(bounds.min, bounds.size));                    bounds = new Bounds(pos, Vector3.zero);                &#125;                else                &#123;                    bounds.Encapsulate(pos); // 扩展包围框                &#125;            &#125;            hrefInfo.textValidAreas.Add(new Rect(bounds.min, bounds.size));        &#125;    &#125;    /// &lt;summary&gt;    /// 生成超链接文本的显示区域矩形和链接信息    /// 用于在点击的时候判断是否点击中了超链接    /// &lt;/summary&gt;    /// &lt;returns&gt;      /// 返回超链接解析后的最后输出文本    /// 即在原字符串的基础上用颜色标签的文本    /// 代替&lt;a href=xx&gt;&lt;\a&gt;这样text组件识别不了的标签&lt;/returns&gt;    protected virtual string GetDealedText(string originText)    &#123;        textRebuild.Clear();        hrefInfos.Clear();        //startIndex表示上次匹配正则的字符串的最后字符的索引+1        //例如这段话        //aa&lt;a href=666&gt;[本篇博客]&lt;/a&gt;aa        //第一次匹配到的字符串是&lt;a href=666&gt;[本篇博客]&lt;/a&gt;        //则它最后的字符在整个字符串的索引是24        //则startIndex在这时候为24+1即倒数第二个a的索引        var matchNextCharIndex = 0;        // 实际显示中 尖括号里面的是不显示的        // 上面那句话里面实际显示的就aa 和[本篇博客]        // 这些字符的最后字符]的索引是8        // 所以actualStartIndex表示的下次匹配的开始索引是9        var actualNextCharIndex = 0;               // 在第一个匹配正则式的字符串之前的字符串        // 或者这次匹配正则式的字符串与        // 上次匹配的字符串之间的字符串        var beforeStr = string.Empty;        //beforeStr的清空所有空白符形式        var beforeStrNoBlank = string.Empty;        //这次匹配到的字符串之前的字符串的最后一个字符的索引        //例如aa&lt;a href=666&gt;[本篇博客]&lt;/a&gt;aa        //第一次匹配的时候 beforeStrLastCharIndex是上面字符串第二个a的索引        var beforeStrLastCharIndex = 0;        // match.Groups[0]是常量pattern字符串匹配到的所有字符串        // match.Groups[1]是常量pattern字符串里面第一个小括号匹配到的字符串        // match.Groups[2]是常量pattern字符串里面第二个小括号匹配到的字符串        // 依次类推        foreach (Match match in s_HrefRegex.Matches(originText))        &#123;            beforeStr = originText.Substring(matchNextCharIndex,                match.Index - matchNextCharIndex);            //将firstStr里面的所有空白符（包括&#39;\n&#39;&#39;\t&#39;&#39; &#39;等）去掉            //这是因为空白字符不参与字体的网格生成              //超链接字符前面空白字符不能纳入超链接的可点击区域计算            //否则生成的点击区域会有问题            beforeStrNoBlank = Regex.Replace(beforeStr, @&quot;\s&quot;, &quot;&quot;);            textRebuild.Append(beforeStr);            textRebuild.Append(colorStartStr);  // 超链接颜色            var url = match.Groups[1];            var hyperText = match.Groups[2];            beforeStrLastCharIndex = (beforeStrNoBlank.Length + actualNextCharIndex);            DebugFunc(actualNextCharIndex, beforeStr, beforeStrNoBlank, match, url);            var hrefInfo = new HyperlinkInfo            &#123;                //因为 后面要根据startIndex和endIndex去获取实际的顶点，如果这两变量                //纳入了空白符的计算 会导致变量偏大，从而获取的顶点是后面的字的顶点                startIndex = beforeStrLastCharIndex * perCharVerCount,                endIndex = (beforeStrLastCharIndex + hyperText.Length ) * perCharVerCount,                linkUrl = url.Value            &#125;;            hrefInfos.Add(hrefInfo);            textRebuild.Append(hyperText.Value);            textRebuild.Append(colorEndStr);            matchNextCharIndex = match.Index + match.Length;            actualNextCharIndex += beforeStrNoBlank.Length + match.Groups[2].Length;        &#125;        //将最后一次匹配之后的字符串加上去        textRebuild.Append(originText.Substring(matchNextCharIndex, originText.Length - matchNextCharIndex));        return textRebuild.ToString();    &#125;    private static void DebugFunc(int actualStartIndex, string beforeStr, string beforeStrNoBlank, Match match, Group group)    &#123;        string str = &quot; HyperlinkText GetOutputText &quot;;        for (int i = 0; i &lt; match.Groups.Count; i++)        &#123;            str += (&quot; match.Groups[i]   &quot; + i + &quot;   &quot; +                   match.Groups[i] + &quot; match.Length &quot; + match.Length + &quot;\n&quot;);        &#125;        print(str + &quot; HyperlinkText GetOutputText  firstStr &quot; + beforeStr +            &quot;   &quot; + match.Groups[2] +            &quot; group.Value &quot; + group.Value +            &quot; actualStartIndex &quot; + actualStartIndex +            &quot;  firstStrNoBlank.Length &quot; + beforeStrNoBlank.Length +            &quot; match.Index &quot; + match.Index);    &#125;    /// &lt;summary&gt;    /// 点击事件检测是否点击到超链接文本    /// &lt;/summary&gt;    /// &lt;param name=&quot;eventData&quot;&gt;&lt;/param&gt;    public void OnPointerClick(PointerEventData eventData)    &#123;        Vector2 lp = Vector2.zero;        //将点击点从屏幕坐标系转换到rectTransform的局部坐标系        RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform,            eventData.position, eventData.pressEventCamera, out lp);        foreach (var hrefInfo in hrefInfos)        &#123;            var boxes = hrefInfo.textValidAreas;            for (var i = 0; i &lt; boxes.Count; ++i)            &#123;                if (boxes[i].Contains(lp))                &#123;                    onHrefClickCB.Invoke(hrefInfo.linkUrl);                    return;                &#125;            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// 当前点击超链接回调    /// &lt;/summary&gt;    /// &lt;param name=&quot;info&quot;&gt;回调信息&lt;/param&gt;    private void OnHyperlinkTextInfo(string info)    &#123;        Debug.Log(&quot;超链接信息：&quot; + info);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-安装</title>
      <link href="/2023/06/27/Doc/WooAsset/1-WooAsset-%E5%AE%89%E8%A3%85/"/>
      <url>/2023/06/27/Doc/WooAsset/1-WooAsset-%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="方法一：通过UnityPackage安装"><a href="#方法一：通过UnityPackage安装" class="headerlink" title="方法一：通过UnityPackage安装"></a>方法一：通过UnityPackage安装</h1><ul><li>打开Unity Package Manager</li><li>点击左上角加号 选择 Add package from git URL</li><li>输入 <a href="https://github.com/OnClick9927/WooAsset.git#1.0.6">https://github.com/OnClick9927/WooAsset.git#1.0.6</a></li><li>点击Add后，稍等片刻即可完成安装</li><li>注意：具体版本号以tag为准</li></ul><h1 id="方法二：通过Git安装"><a href="#方法二：通过Git安装" class="headerlink" title="方法二：通过Git安装"></a>方法二：通过Git安装</h1><ul><li>git clone <a href="https://github.com/OnClick9927/WooAsset">https://github.com/OnClick9927/WooAsset</a></li><li>把 WooAsset文件夹拖入Unity工程即可</li></ul><h1 id="方法三：通过Git安装"><a href="#方法三：通过Git安装" class="headerlink" title="方法三：通过Git安装"></a>方法三：通过Git安装</h1><ul><li>打开想要存放代码的文件夹</li><li>在此目录打开cmd 窗口</li><li>‘git clone -b src <a href="https://github.com/OnClick9927/WooAsset">https://github.com/OnClick9927/WooAsset</a>‘</li><li>等待片刻即可看到此目录最新的源码<br>更新 </li><li>打开源码所在目录</li><li>git pull</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-配置</title>
      <link href="/2023/06/27/Doc/WooAsset/2-WooAsset-%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/06/27/Doc/WooAsset/2-WooAsset-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="第一次使用"><a href="#第一次使用" class="headerlink" title="第一次使用"></a>第一次使用</h1><ul><li>打开编辑器窗口，操作如下图</li><li>如果报错，关闭窗口再打开一次即可</li><li>如果成功了，会在Assets&#x2F;Editor目录下看到两个配置文件<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"><br><img src="/../../../Pic/Doc/WooAsset/configasset.png" alt="Alt text"></li></ul><h1 id="配置资源"><a href="#配置资源" class="headerlink" title="配置资源"></a>配置资源</h1><p><img src="/../../../Pic/Doc/WooAsset/buildcfgwin.png" alt="Alt text"></p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>BuildGroups</td><td>打包的资源组</td></tr><tr><td>ignoreFileExtend</td><td>不需要打包的文件后缀</td></tr><tr><td>Version</td><td>此次打包出去的版本</td></tr><tr><td>Bundle Size</td><td>打出来的bundle最大大小</td></tr><tr><td>ignore Type Tree change</td><td></td></tr><tr><td>Compress</td><td>资源压缩格式</td></tr><tr><td>Asset Build</td><td>自定义打包流程（可扩展）</td></tr><tr><td>Encrypt</td><td>文件加密方式（可扩展）</td></tr><tr><td>Output Path</td><td>输出路径</td></tr><tr><td>Build Target</td><td>当前打包的平台</td></tr><tr><td>History Path</td><td>历史文件所在文件夹，第一次打包时候把他删了，后续不要动里面的文件</td></tr></tbody></table><h2 id="资源组介绍"><a href="#资源组介绍" class="headerlink" title="资源组介绍"></a>资源组介绍</h2><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>Build</td><td>该组是否需要打包 （给分布式打包使用）</td></tr><tr><td>Name</td><td>组的名字（不可重复，不为空）</td></tr><tr><td>Path</td><td>组对应的项目路径  （不可重复，不为空）</td></tr><tr><td>Description</td><td>对组加点描述</td></tr><tr><td>Tags</td><td>对组加一些标记</td></tr></tbody></table><ul><li>每个资源组均可以分开打包，更新，加载</li><li>保持好良好的资源组结构，方式生成过多冗余</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-构建与部署</title>
      <link href="/2023/06/27/Doc/WooAsset/3-WooAsset-%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/06/27/Doc/WooAsset/3-WooAsset-%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><ul><li>设置好需要打包的组</li><li>点击Tools&#x2F;WooAsset&#x2F;Build</li><li>稍等片刻即可完成打包，内容全都在输出目录下<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"></li></ul><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><pre><code>CDN└─android    ├─v1.0（APP版本）    ├─v1.1（APP版本）    └─v2.0（APP版本）└─iphone    ├─v1.0（APP版本）    ├─v1.1（APP版本）    └─v2.0（APP版本）</code></pre><ul><li>也可以允许下面的目录结构</li><li>所有的版本文件都在一起</li></ul><pre><code>CDN└─android└─iphone</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-着色器变体与图集</title>
      <link href="/2023/06/27/Doc/WooAsset/4-WooAsset-%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E4%BD%93%E4%B8%8E%E5%9B%BE%E9%9B%86/"/>
      <url>/2023/06/27/Doc/WooAsset/4-WooAsset-%E7%9D%80%E8%89%B2%E5%99%A8%E5%8F%98%E4%BD%93%E4%B8%8E%E5%9B%BE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><img src="/../../../Pic/Doc/WooAsset/svcandsa.png" alt="Alt text"></p><table><thead><tr><th>名字</th><th>描述</th></tr></thead><tbody><tr><td>shaderVariantDirectory</td><td>svc   输出的文件夹</td></tr><tr><td>atlasPaths</td><td>需要做图集的文件夹（给一个根路径即可）</td></tr><tr><td>packSetting</td><td>图集设置</td></tr><tr><td>textureSetting</td><td>图集设置</td></tr><tr><td>PlatformSetting</td><td>图集设置</td></tr></tbody></table><h1 id="收集着色器变体"><a href="#收集着色器变体" class="headerlink" title="收集着色器变体"></a>收集着色器变体</h1><ul><li>设置好shaderVariantDirectory</li><li>点击Tools&#x2F;WooAsset&#x2F;Help&#x2F;ShaderVariant</li><li>稍等片刻即可完成，内容全都在shaderVariantDirectory目录下<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"></li></ul><h1 id="生成图集"><a href="#生成图集" class="headerlink" title="生成图集"></a>生成图集</h1><ul><li>设置好图集相关设置</li><li>点击Tools&#x2F;WooAsset&#x2F;Help&#x2F;SpriteAtlas</li><li>稍等片刻即可完成<br><img src="/../../../Pic/Doc/WooAsset/firstopen.png" alt="Alt text"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-更新与初始化</title>
      <link href="/2023/06/27/Doc/WooAsset/5-WooAsset-%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%20copy/"/>
      <url>/2023/06/27/Doc/WooAsset/5-WooAsset-%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96%20copy/</url>
      
        <content type="html"><![CDATA[<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><pre><code class="csharp">Assets.SetAssetsSetting(new LocalSetting());//拉取远端版本信息var op = await Assets.VersionCheck();//远端的所有版本数据，内容是buildGroupvar versions = op.versions;//远端和本地进行版本比较//可选参数 versionIndex 和远端的第几个版本比较，不传入就是最后一个版本//可选参数 tags 只比较包含标签的组，不传入就是所有组var compare = await op.Compare(op.versions.Count);//下载所有需要更新的资源for (int i = 0; i &lt; compare.add.Count; i++)    await Assets.DownLoadBundle(compare.add[i].name);for (int i = 0; i &lt; compare.change.Count; i++)    await Assets.DownLoadBundle(compare.change[i].name);</code></pre><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><pre><code class="csharp">Assets.SetAssetsSetting(new LocalSetting());//初始化//可选参数 version 初始化哪一个版本，不传就是本地版本，本地没有就是远端最新版本//可选参数 again 再一次初始化（使用场景，热更新界面也热更）//可选参数 tags 只初始化包含标签的组，不传入就是所有组await Assets.InitAsync();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-加载与卸载</title>
      <link href="/2023/06/27/Doc/WooAsset/6-WooAsset-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD/"/>
      <url>/2023/06/27/Doc/WooAsset/6-WooAsset-%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">///正常加载var asset = await Assets.LoadAssetAsync(path);///获取要加载的资源var sp = asset.GetAsset&lt;Sprite&gt;();///加载场景var sceneAsset = await Assets.LoadSceneAssetAsync(path);await sceneAsset.LoadSceneAsync(LoadSceneMode.Additive);///加载Unity无法识别的资源var asset = await Assets.LoadAssetAsync(path);RawObject raw = asset.GetAsset&lt;RawObject&gt;();Debug.Log(raw.bytes.Length);///加载子资源var mainAsset = await Assets.LoadAssetAsync(path);var sp = mainAsset.GetSubAsset&lt;Sprite&gt;(&quot;a_1&quot;);///卸载资源Assets.Release(asset)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-个性化</title>
      <link href="/2023/06/27/Doc/WooAsset/7-WooAsset-%E4%B8%AA%E6%80%A7%E5%8C%96/"/>
      <url>/2023/06/27/Doc/WooAsset/7-WooAsset-%E4%B8%AA%E6%80%A7%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="打包个性化"><a href="#打包个性化" class="headerlink" title="打包个性化"></a>打包个性化</h2><pre><code class="csharp"> //个性化打包流程public interface IAssetBuild&#123;    //自定义版本规则    string GetVersion(string settingVersion, AssetTaskContext context);    //自定义 资源 Tag （可以按照tag加载一组资源）    IReadOnlyList&lt;string&gt; GetTags(EditorAssetData info);    // 自定义资源分组    void Create(AssetTagCollection tags,List&lt;EditorAssetData&gt; assets, Dictionary&lt;EditorAssetData, List&lt;EditorAssetData&gt;&gt; dpsDic, List&lt;BundleGroup&gt; result);    //自定义打包结束之后需要执行的任务    //比如输出一些Log、上传文件到服务器等    List&lt;AssetTask&gt; GetPipelineFinishTasks(AssetTaskContext context);    //更具一个路径返回资源类型    AssetType GetAssetType(string path);&#125;</code></pre><h2 id="加载个性化"><a href="#加载个性化" class="headerlink" title="加载个性化"></a>加载个性化</h2><pre><code class="csharp">///写一个 class 继承于 AssetsSettingpublic abstract class AssetsSetting&#123;  ///自定义Bundle下载器  public virtual BundleDownloader GetBundleDownloader(string url,string bundleName) &#123;&#125;  ///下载的路径  protected virtual string GetBaseUrl() &#123;&#125;  ///自定义 bundle 去哪里下载  public virtual string GetUrlByBundleName(string buildTarget, string bundleName)&#123;&#125;  ///自定义 版本文件 去哪里下载  public virtual string GetVersionUrl(string buildTarget)&#123;&#125;  /// 文件比对方式  public virtual FileCompareType GetFileCheckType() &#123;&#125;  /// 下载等待  public virtual int GetWebRequestTimeout() &#123;&#125;  ///资源加密方式  public virtual IAssetStreamEncrypt GetEncrypt() &#123;&#125;  ///是否自动卸载  public virtual bool GetAutoUnloadBundle() &#123;&#125;  /// 如果本地没有是否需要保存文件  public virtual bool GetSaveBundlesWhenPlaying()&#123;&#125;  /// 自定义的资源生命周期管理，bundle和asset均可以  public virtual IAssetLife GetAssetLife()&#123;&#125;&#125;</code></pre><h2 id="资源加密"><a href="#资源加密" class="headerlink" title="资源加密"></a>资源加密</h2><pre><code class="csharp">//个性化加密public interface IAssetStreamEncrypt&#123;    byte[] Encode(string bundleName, byte[] buffer);    byte[] Decode(string bundleName, byte[] buffer);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-运行时扩展功能</title>
      <link href="/2023/06/27/Doc/WooAsset/8-WooAsset-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/06/27/Doc/WooAsset/8-WooAsset-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="资源模糊搜索"><a href="#资源模糊搜索" class="headerlink" title="资源模糊搜索"></a>资源模糊搜索</h2><pre><code class="csharp">public class AssetsSearch    &#123;///以下是交集        public static IReadOnlyList&lt;string&gt; IntersectNameAndTag(string assetName, params string[] tags);        public static IReadOnlyList&lt;string&gt; IntersectTag(params string[] tags);        public static IReadOnlyList&lt;string&gt; IntersectTypeAndNameAndTag(AssetType type, string assetName, params string[] tags);        public static IReadOnlyList&lt;string&gt; IntersectTypeAndTag(AssetType type, params string[] tags);///以下是并集        public static IReadOnlyList&lt;string&gt; Union(params string[] nameOrTags);        public static IReadOnlyList&lt;string&gt; UnionTag(params string[] tags);        public static IReadOnlyList&lt;string&gt; UnionName(params string[] names);        public static IReadOnlyList&lt;string&gt; UnionNameAndTag(string assetName, params string[] tags);        public static IReadOnlyList&lt;string&gt; UnionTypeAndNameAndTag(AssetType type, string assetName, params string[] tags);        public static IReadOnlyList&lt;string&gt; UnionTypeAndTag(AssetType type, params string[] tags);        public static IReadOnlyList&lt;string&gt; AssetPathByType(AssetType type);    &#125;</code></pre><h2 id="资源组加载"><a href="#资源组加载" class="headerlink" title="资源组加载"></a>资源组加载</h2><pre><code class="csharp">//准备一组资源string[] groups ;var assets= await Assets.PrepareAssets(groups)///加载对应的资源方法一string path;var asset = assets.FindAsset(path)///加载对应的资源方法二var asset = Assets.LoadAssetAsync(path)///把整组资源全都卸载了assets.Release();///配合资源模糊搜索一起使用//使用场景，进入战斗场景之前把战斗需要的资源全加载</code></pre><h2 id="方便的资源卸载"><a href="#方便的资源卸载" class="headerlink" title="方便的资源卸载"></a>方便的资源卸载</h2><h3 id="基础方式"><a href="#基础方式" class="headerlink" title="基础方式"></a>基础方式</h3><ul><li>场景</li><li>一个ui界面上面有一个image</li><li>运行时候需要不停的替换image的sprite</li><li>界面关闭的时候需要把image的sprite卸载</li></ul><pre><code class="csharp">///所有的设置图片都走这个方法public static async void SetSprite(Image image, string path)&#123;    var asset = await Assets.LoadAssetAsync(path);    if (asset.isErr) return;    image.sprite = asset.GetAsset&lt;Sprite&gt;();    Assets.AddBridge(new GameObjectBridge(image.gameObject,asset));&#125;///在合适的时候调用一次即可（比如：切换场景时候）public static void ReleaseUselessBridges()&#123;    Assets.ReleaseUselessBridges();&#125;</code></pre><h3 id="更加方便的方式（有风险）"><a href="#更加方便的方式（有风险）" class="headerlink" title="更加方便的方式（有风险）"></a>更加方便的方式（有风险）</h3><pre><code class="csharp">public class LocalSetting : AssetsSetting&#123;    public override IAssetLife GetAssetLife()    &#123;      /// 参数是缓存的内存大小，超过这个数字会自动卸载最早的资源        return new LRULife(1024 * 50);    &#125;&#125;Assets.SetAssetsSetting(new LocalSetting());</code></pre><ul><li>可以实现 bundle 不自动卸载，到达一定大小在开始卸载</li><li>如果内存不足时候，最早被使用的资源会被优先卸载</li><li>内存设置的别太小，容易出现资源丢失</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-编辑器扩展功能</title>
      <link href="/2023/06/27/Doc/WooAsset/9-WooAsset-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/06/27/Doc/WooAsset/9-WooAsset-%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="模拟资源服务器"><a href="#模拟资源服务器" class="headerlink" title="模拟资源服务器"></a>模拟资源服务器</h2><p><img src="/../../../Pic/Doc/WooAsset/%E6%A8%A1%E6%8B%9F%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="Alt text"></p><ul><li><p>使用场景</p></li><li><p>省的每次都上传到远端</p></li><li><p>配合资源加载情况窗口一起观察资源加载情况</p></li><li><p>使用方法</p></li><li><p>设置好 Enable Server ，Server Directory ，Server Port</p></li><li><p>编辑器进入运行模式会自动开启资源服务器，console窗口有输出</p></li><li><p>注意</p></li><li><p>Server Directory ，Server Port 一般情况默认即可</p></li><li><p>资源服务器只会在运行状态且NormalMode状态下打开</p></li><li><p>如果资源服务器的配置不为空，在打包资源的时候会把输出文件拷贝过去</p></li></ul><h2 id="资源加载情况"><a href="#资源加载情况" class="headerlink" title="资源加载情况"></a>资源加载情况</h2><p><img src="/../../../Pic/Doc/WooAsset/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E6%83%85%E5%86%B5.png" alt="Alt text"></p><ul><li>资源加载实践</li><li>当前有多少引用</li><li>资源的标签</li><li>资源所属的 bundle</li><li>支持快速搜索</li></ul><h2 id="收集资源预览"><a href="#收集资源预览" class="headerlink" title="收集资源预览"></a>收集资源预览</h2><p><img src="/../../../Pic/Doc/WooAsset/%E8%B5%84%E6%BA%90%E6%94%B6%E9%9B%86%E6%83%85%E5%86%B5.png" alt="Alt text"></p><ul><li>如果不是打包，会收集所有的buildGroup</li><li>可以方便的看到究竟打包了什么内容</li><li>双击资源可以定位</li><li>支持快速搜索</li><li>可以查看资源依赖情况</li></ul><h2 id="构建-Bundle-预览"><a href="#构建-Bundle-预览" class="headerlink" title="构建 Bundle 预览"></a>构建 Bundle 预览</h2><p><img src="/../../../Pic/Doc/WooAsset/%E6%89%93%E5%8C%85%E9%A2%84%E8%A7%88.png" alt="Alt text"></p><ul><li>如果不是打包，会收集所有的buildGroup</li><li>可以预览所有的assetBundle</li><li>可以查看每一个资源的依赖</li><li>可以查看每一个bundle的依赖</li><li>双击资源可以定位</li><li>支持快速搜索</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-Document</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-Document/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-Document/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>此篇文章讲一下如何快速使用WooTween</li><li>根据自己需求怎么去扩展</li><li>以及重点内容</li></ul><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul><li><p>之前已经讲解过了Component是个什么东西 </p></li><li><p>这里我们看看如何使用</p></li><li><p>选择物体-添加组件</p></li><li><p>我们可以看到自带的三个组件</p><p><img src="/../../../Pic/Doc/WooTween/%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6.png" alt="Alt text"></p></li><li><p>autoPlay: 自动播放 autoRecycle: 自动回收</p></li><li><p>Duration：持续时间</p></li><li><p>Snap: 简单理解就是勾选后整数的数值来运动</p></li><li><p>Curve: 动画曲线 内置了5种曲线 可以自定义 并保存</p></li><li><p>LoopType: 循环模式 ReStart PingPong</p></li><li><p>Loop: 循环次数 -1无限 1..次数</p><ul><li>Type: 运动数值的模式 </li><li>Single 起始点和终点值</li></ul></li><li><p>Array 多个数值组成一条线路</p><ul><li>Play Rewind Complete 无需运行立即播放动画 倒放回原点 停止动画</li></ul></li></ul><p> <img src="/../../../Pic/Doc/WooTween/%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D.png" alt="Alt text"><br> <img src="/../../../Pic/Doc/WooTween/ComponentGif.gif" alt="Alt text"></p><ul><li>使用方法一目了然这里就不过多讲解了 </li><li>如何扩展呢 我们以BoxCollider2D的Offset为例 </li><li>我们需要更改的数值为Vector2</li><li>新建两个脚本</li></ul><pre><code class="csharp">using UnityEngine;namespace WooTween&#123;    public class DoBoxCollider2DComponent : TweenComponent&lt;Vector2,BoxCollider2D&gt;    &#123;        protected override Vector2 GetTargetValue()        &#123;            //返回物体的缩放值            return transform.GetComponent&lt;BoxCollider2D&gt;().offset;         &#125;        protected override  void SetTargetValue(Vector2 value)        &#123;            //物体的缩放值等于value            transform.GetComponent&lt;BoxCollider2D&gt;().offset = value;        &#125;    &#125;&#125;using UnityEditor;using UnityEngine;namespace WooTween&#123;    [CustomEditor(typeof(DoBoxCollider2DComponent))]    public class DoBoxCollider2DComponentEditor : TweenComponentEditor&lt;Vector2 , BoxCollider2D&gt; &#123; &#125;&#125;</code></pre><h2 id="TweenEx"><a href="#TweenEx" class="headerlink" title="TweenEx"></a>TweenEx</h2><ul><li>所有会调用的方法都在TweenEx脚本里面 </li><li>此篇内容讲解一下如何使用和如何扩展</li></ul><pre><code class="csharp">transform.DoMove(new Vecotr3(0,1,2),2,false) .SetLoop(4, LoopType.PingPong)                  .SetAnimationCurve(curve)                  .SetRecycle(false)                  .OnComplete(() =&gt;                  &#123;                      Debug.Log(Time.time);                  &#125;);</code></pre><ul><li>传入位置 持续时间 移动数值是否为整型 设置循环 循环类型 设置动画曲线 设置回收 完成时委托内容</li></ul><pre><code class="csharp">ITween t = cube.DoMove(new Vector3[] &#123;               Vector3.zero,               Vector3.one,               Vector3.one * 2,               Vector3.one * 3,               Vector3.one * -4,               Vector3.one * 5,               Vector3.one * 6,            &#125;, 5, false)            .SetRecyle(false);</code></pre><ul><li>也可以以数组的形势传入参数</li></ul><pre><code class="csharp">        private void Update()        &#123;            if (Input.GetKeyDown(KeyCode.Space))            &#123;                t.Rewind(1);            &#125;            if (Input.GetKey(KeyCode.A))            &#123;                t.ReStart();            &#125;            if (Input.GetKey(KeyCode.Q))            &#123;                t.Complete(false);            &#125;        &#125;</code></pre><ul><li>也可以对动画进行一系列操作</li></ul><pre><code class="csharp">tc.SetUpdateType(TweenUpdateType.Update).SetDeltaTime(0.1f).SetDelta(0.2f).SetTimeScale(2);</code></pre><ul><li>设置动画的一系列参数</li></ul><p> <img src="/../../../Pic/Doc/WooTween/%E4%BB%A3%E7%A0%81Gif.gif" alt="Alt text"></p><h2 id="如何扩展"><a href="#如何扩展" class="headerlink" title="如何扩展"></a>如何扩展</h2><pre><code class="csharp">public static ITween&lt;T&gt; DoGoto&lt;T&gt;(T start, T end, float duration, Func&lt;T&gt; getter, Action&lt;T&gt; setter, bool snap, EnvironmentType env= EnvironmentType.RT) where T : struct        &#123;#if UNITY_EDITOR            if (!UnityEditor.EditorApplication.isPlaying &amp;&amp; !Application.isPlaying)            &#123;                env = EnvironmentType.Editor;            &#125;#endif            var tween = AllocateSingleTween&lt;T&gt;(env);            tween.Config(start, end, duration, getter, setter, snap);                        (tween as Tween).WaitToRun();            return tween;        &#125;        public static ITween&lt;T&gt; DoGoto&lt;T&gt;(T[] array, float duration, Func&lt;T&gt; getter, Action&lt;T&gt; setter, bool snap, EnvironmentType env = EnvironmentType.RT) where T : struct        &#123;#if UNITY_EDITOR            if (!UnityEditor.EditorApplication.isPlaying &amp;&amp; !Application.isPlaying)            &#123;                env = EnvironmentType.Editor;            &#125;#endif            var tween = AllocateArrayTween&lt;T&gt;(env);            tween.Config(array, duration, getter, setter, snap);            (tween as Tween).WaitToRun();            return tween;        &#125;</code></pre><ul><li>所有的方法扩展主要依靠于这两个函数 传入一个值还是数组</li><li>现在所支持的包括Transform、Material、Graphic、Light、Camera、CanvasGroup、Text、Image、ScrollRect、GameObject、Behaviour、Toggle、AudioSource、Rigidbody、Rigidbody2D、SpriteRenderer、LayoutElement、Outline、RectTransform、Slider</li><li>大部分经常会用到的扩展方法都在其中</li></ul><pre><code class="csharp">public static ITween&lt;float&gt; DoFieldOfView(this Camera target, float value, float duration, bool snap = false)&#123;   return DoGoto(target.fieldOfView,           value,           duration,           () =&gt; &#123; return target.fieldOfView; &#125;,          (value) =&gt; &#123; target.fieldOfView = value; &#125;,           snap);&#125;</code></pre><ul><li>以修改相机的FieldOfView为例</li><li>写一个静态方法 返回值为ITween&lt;数据类型&gt;  </li><li>第一个方法参数需要是 this + 类型 + 名称 | 传入值 持续时间 Snap</li><li>方法体里面可以写对传入值的判断 ，比如： 不能小于0 不能大于180</li><li>return 调用DoGoto方法 将之前写的参数一一对应 </li><li>剩下的事情就不需要我们去管了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-Tween</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-Tween/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-Tween/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>我们需要实现开始、重新开始、结束，回去</li><li>所以必须有四个方法</li><li>Run、ReStart、Rewind、Complete</li><li>因为要可以设置转换器，所以必须有一个引用</li><li>因为需要可以循环动画，所以必须要有一个方向、循环类型</li></ul><h2 id="呼之欲出的结果"><a href="#呼之欲出的结果" class="headerlink" title="呼之欲出的结果"></a>呼之欲出的结果</h2><pre><code class="csharp">///环境public enum TweenDirection&#123;    Forward,    Back&#125;public enum LoopType&#123;    ReStart,    PingPong&#125;public abstract class Tween : TweenObject, ITween&#123;    private TweenDirection _direction = TweenDirection.Forward;    public LoopType loopType &#123; get; set; &#125;    public abstract IPercentConverter converter &#123; get; set; &#125;    public abstract void Run();    public abstract void ReStart();    public abstract void Rewind(float duration,bool snap=false);    public abstract void Complete(bool invoke);&#125;</code></pre><h1 id="再次开始"><a href="#再次开始" class="headerlink" title="再次开始"></a>再次开始</h1><ul><li>动画的变化有可能是从一个值到另一个值</li><li>比如0-1</li><li>也有可能需要变化一组数值</li><li>比如dotween 经典的 dopath</li><li>所以我们有两种tween,SingleTween,ArrayTween</li></ul><h1 id="凉鞋专用"><a href="#凉鞋专用" class="headerlink" title="凉鞋专用"></a>凉鞋专用</h1><ul><li>为什么要有 WaitToRun 这个方法</li><li>因为需要支持链式编程，所以tween都是等到下一帧才会真的开始跑</li><li>对于为什么要有 UnbindTweenValue 这个方法</li><li>TweenValue 其实是一直跑的，直到他自己跑结束，会被驱动统一回收</li><li>tween想要中断被当前 TweenValue 控制数值，只要把 TweenValue 的plugin制空即可</li><li>还想继续跑，那就重新分配一个即可</li><li>这个就是我之前困扰的bug</li></ul><h1 id="更方便的书写"><a href="#更方便的书写" class="headerlink" title="更方便的书写"></a>更方便的书写</h1><ul><li>众所周知，dotween最出名的就是链式编程</li><li>我们也不能少</li></ul><pre><code class="csharp">public static ISingleTween&lt;T&gt; AllocateSingleTween&lt;T&gt;(EnvironmentType env)&#123;    if (env != EnvironmentType.Editor)        TweenSingleton.Initialized();    return TweenObject.Allocate&lt;SingleTween&lt;T&gt;&gt;(env);&#125;public static ITween&lt;T&gt; DoGoto&lt;T&gt;(T start, T end, float duration, Func&lt;T&gt; getter, Action&lt;T&gt; setter, bool snap, EnvironmentType env= EnvironmentType.RT)&#123;#if UNITY_EDITOR    if (!UnityEditor.EditorApplication.isPlaying &amp;&amp; !Application.isPlaying)    &#123;        env = EnvironmentType.Editor;    &#125;#endif    var tween = AllocateSingleTween&lt;T&gt;(env);    tween.Config(start, end, duration, getter, setter, snap);    (tween as Tween).WaitToRun();    return tween;&#125;public static ITween&lt;Vector3&gt; DoMove(this Transform target, Vector3 end, float duration, bool snap = false)&#123;    return DoGoto(target.position, end, duration, () =&gt; &#123; return target.position; &#125;,            (value) =&gt; &#123;                target.position = value;            &#125;, snap        );&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-TweenValue</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-TweenValue/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-TweenValue/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>这是一个单程车，</li><li>所以他的功能就是在曲线转换器的作用下</li><li>从一个值跑到另一个值即可</li><li>那么他肯定有一个 开始跑（run）和update</li><li>run 很简单</li><li>update ，在那里运行呢？</li><li>还记得我们的好司机吗？</li><li>对了，就是他带着我们的 TweenValue 跑</li><li>我们需要具有曲线的运行跑完这个单程</li><li>所以我们TweenValue得有一个 转换器</li><li>我们变化的值，也不可能是一种</li><li>有可能是 float、int、Vector3等等</li><li>所以 TweenValue 是一个泛型</li></ul><h2 id="呼之欲出的结果"><a href="#呼之欲出的结果" class="headerlink" title="呼之欲出的结果"></a>呼之欲出的结果</h2><pre><code class="csharp">///环境public abstract class TweenValue : TweenObject&#123;    ///提供统一的获取接口    public static TweenValue&lt;T&gt; Get&lt;T&gt;(EnvironmentType envType) where T : struct &#123;&#125;    private IPercentConverter _converter = EaseCoverter.Default;    private float _time;    public abstract float duration &#123; get; &#125;    public static float deltaTime = 0.02f;    protected abstract void MoveNext();    public void Run()    &#123;        TweenDrive container = TweenDrive.GetDrive(envType);        container.Subscribe(this);    &#125;    public void Update()    &#123;        _time += deltaTime ;        if (_time &gt;= duration)        &#123;            OnCompelete();        &#125;        else        &#123;            MoveNext();        &#125;    &#125;    protected virtual void OnCompelete()&#123;&#125;&#125;public abstract class TweenValue&lt;T&gt; : TweenValue where T : struct&#123;    ///对Tween传过来的设置打个包    private IPlugin&lt;T&gt; _plugin;    private T _current;    protected T pluginValue &#123; get &#123; return _plugin.getter.Invoke(); &#125; &#125;    ///设置当前的值    protected void SetCurrent(T value)    &#123;        if (_plugin != null)        &#123;            if (_plugin.snap)                _current = Snap(value);            else                _current = value;            if (_plugin.setter != null)            &#123;                _plugin.setter(_current);            &#125;        &#125;    &#125;    public T end &#123; get &#123; return _plugin.end; &#125; &#125;    public T start &#123; get &#123; return _plugin.start; &#125; &#125;    public override float duration &#123; get &#123; return _plugin != null ? _plugin.duration : 0; &#125; &#125;&#125;</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>基础的结构已经有了，接下来就是各种类型（float，int，Vector3）各自实现即可</p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-转换器</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-%E8%BD%AC%E6%8D%A2%E5%99%A8/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="这是个什么东西"><a href="#这是个什么东西" class="headerlink" title="这是个什么东西"></a>这是个什么东西</h2><p>在dotween 里面有一个Ease的概念</p><p>我们要实现的就是这个</p><p>那么这个东西很简单</p><p>只需要实现从一个值到另一个值的映射即可</p><h2 id="呼之欲出的结果"><a href="#呼之欲出的结果" class="headerlink" title="呼之欲出的结果"></a>呼之欲出的结果</h2><pre><code class="csharp">///环境public interface IPercentConverter&#123;    float Convert(float percent, float time, float duration);    void Recyle();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-驱动器</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-%E9%A9%B1%E5%8A%A8%E5%99%A8/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-%E9%A9%B1%E5%8A%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>驱动器需要逐帧运行，所以需要update</li><li>因为需要分为编辑器和运行时，所以要有一个环境的概念</li><li>但是驱动总得有一个指挥他运行的东西<ul><li>运行时：单例</li><li>编辑器：绑定到编辑器的update</li></ul></li></ul><h3 id="呼之欲出的结果"><a href="#呼之欲出的结果" class="headerlink" title="呼之欲出的结果"></a>呼之欲出的结果</h3><pre><code class="csharp">///环境public enum EnvironmentType&#123;    RT,    Editor&#125;public class TweenDrive : System.IDisposable&#123;    //各自的指挥，调用这个方法即可    public void Update()    &#123;    &#125;    private static Dictionary&lt;EnvironmentType, TweenDrive&gt; dic = new Dictionary&lt;EnvironmentType, TweenDrive&gt;();    public static TweenDrive GetDrive(EnvironmentType env)    &#123;        if (!dic.ContainsKey(env))        &#123;            dic.Add(env, new TweenDrive());        &#125;        return dic[env];    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-对象池</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="如何实现一个对象池"><a href="#如何实现一个对象池" class="headerlink" title="如何实现一个对象池"></a>如何实现一个对象池</h2><ul><li>有最基本的存取能力</li><li>最好是可以通用</li><li>有一定的能力</li></ul><h3 id="基础的存取能力"><a href="#基础的存取能力" class="headerlink" title="基础的存取能力"></a>基础的存取能力</h3><ul><li>存 Set</li><li>取 Get ,如果不够 CreateNew</li><li>内部需要维护一个可以保存对象的集合</li></ul><h3 id="通用-x2F-扩展能力"><a href="#通用-x2F-扩展能力" class="headerlink" title="通用&#x2F;扩展能力"></a>通用&#x2F;扩展能力</h3><ul><li>使用泛型</li><li>方法可以重写</li></ul><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><pre><code class="csharp">public abstract ObjectPool&lt;T&gt;&#123;    protected Queue&lt;T&gt; pool ;    public T Get()&#123;        T t;            if (pool.Count &gt; 0)                t = pool.Dequeue();            else            &#123;                t = CreateNew();                OnCreate(t);            &#125;            OnGet(t);            return t;    &#125;    protected abstract T CreateNew();    protected virtual void OnGet(T t) &#123; &#125;    ///在被创建时候个性化的设置    protected virtual void OnCreate(T t) &#123; &#125;    public virtual bool Set(T t)    &#123;        if (!pool.Contains(t))        &#123;            if (OnSet(t))            pool.Enqueue(t);            return true;        &#125;        else        return false;    &#125;    ///为了实现可以控制数量的对象池    protected virtual bool OnSet(T t)    &#123;        return true;    &#125;&#125;</code></pre><h2 id="更加容易使用的对象池"><a href="#更加容易使用的对象池" class="headerlink" title="更加容易使用的对象池"></a>更加容易使用的对象池</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>上边的对象池已经可以实现对象的存取</li><li>但是每一个类型都得写一个子类</li><li>C#可以反射创建对象，但是需要类型</li></ul><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><pre><code class="csharp">public abstract ActivatorCreatePool&lt;T&gt;: ObjectPool&lt;T&gt;&#123;    ///反射创建对象    protected abstract T CreateNew()    &#123;        Type type = typeof(T);        return (T)Activator.CreateInstance(type);    &#125;&#125;</code></pre><h2 id="基类对象池"><a href="#基类对象池" class="headerlink" title="基类对象池"></a>基类对象池</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li>现在我们可以各种类型都使用同一个对象池</li><li>但是我们获取对象的时候，我们需要拿到具体的对象池</li><li>如果我们可以问一个对象池要各种对象该有多好<ul><li>例子：</li><li>假设我们想看动物</li><li>看鲨鱼-》海洋馆</li><li>看熊猫-》熊猫馆</li><li>就像上面，我们需要知道具体的展馆在哪里才行</li><li>但是大部分情况，她们都是在动物园里面的</li><li>动物园的路边是有指路牌的</li><li>因此我们的对象池也可以以做成动物园这种</li></ul></li><li>由此而言，我们有一个基类的概念，不能去动物园看飞机、坦克</li><li>我们需要一个对象池集合、并且需要指路牌</li><li>指路牌很简单、Type即可</li><li>所以用一个字典 Dictionary&lt;Type,Pool?&gt;</li><li>但是我们的对象池是泛型，后面这个类型咋写？</li><li>所以我们需要把之前额对象池再次抽象一次</li></ul><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><pre><code class="csharp">///更抽象public interface IObjectPool:IDisposable &#123;    /// 回收，解决不能使用泛型问题    void Set(object obj);&#125;public abstract class BaseTypePool&lt;T&gt;&#123;    private Dictionary&lt;Type, IObjectPool&gt; _poolMap;    /// 获取内部对象池    public ObjectPool&lt;Object&gt; GetPool&lt;Object&gt;() where Object : T    &#123;        Type type = typeof(Object);        var pool = GetPool(type);        return pool as ObjectPool&lt;Object&gt;;    &#125;    /// 获取内部对象池    public IObjectPool GetPool(Type type)    &#123;        IObjectPool pool;        if (!_poolMap.TryGetValue(type, out pool))        &#123;            var pooType = typeof(ActivatorCreatePool&lt;&gt;).MakeGenericType(type);            pool = Activator.CreateInstance(pooType, null) as IObjectPool;            _poolMap.Add(type, pool);        &#125;        return pool;    &#125;    /// 获取数据    public Object Get&lt;Object&gt;() where Object : T    &#123;        var pool = GetPool&lt;Object&gt;();        Object t = pool.Get();        return t;    &#125;    /// 回收数据    public void Set&lt;Object&gt;(Object t) where Object : T    &#123;        Type type = t.GetType();        var pool = GetPool(type);        pool.Set(t);    &#125;&#125;</code></pre><h2 id="全局扩展"><a href="#全局扩展" class="headerlink" title="全局扩展"></a>全局扩展</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>现在我们已经实现了只要去动物园就可以观赏各种动物</li><li>很爽，但是呢我们必须知道动物园在哪里</li><li>还有就是，我们可能还想看飞机、坦克，并不是动物园<ul><li>关于飞机坦克，还有动物，</li><li>我们可以抽象一点，他们都是一个东西</li><li>所以我们可以搞一个东西池子</li><li>也就是说，我们池子的 T 是 object</li><li>关于知道动物园在哪里</li><li>反正他是个东西，问东西池子要即可</li><li>所以我们实现一个全局的池子就好了</li><li>如何全局？C#正是个好语言-》静态扩展</li></ul></li></ul><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><pre><code class="csharp">public static class PoolEx&#123;    private class GlobalPool : BaseTypePool&lt;object&gt; &#123; &#125;    static private GlobalPool _globalPool = new GlobalPool();    /// 全局分配    public static T GlobalAllocate&lt;T&gt;()where T: class    &#123;        return _globalPool.Get&lt;T&gt;();    &#125;    /// 全局回收    public static void GlobalRecyle&lt;T&gt;(this T t)where T :class    &#123;        _globalPool.Set(t);    &#125;&#125;</code></pre><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>目前对象池，可以获取任何对象了 </p>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-Component</title>
      <link href="/2023/06/23/Doc/WooTween/WooTween-Component/"/>
      <url>/2023/06/23/Doc/WooTween/WooTween-Component/</url>
      
        <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>有时候 效果很简单、很重复</li><li>有时候 效果是让策划美术调整</li><li>但是他们不会写代码</li><li>所以我们来编辑器扩展</li><li>具体代码项目看</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片过渡</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E8%BF%87%E6%B8%A1/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E8%BF%87%E6%B8%A1/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;Hidden/UI/Default (UITransition)&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        [Header(Transition)]        _TransitionTex (&quot;Transition Texture (A)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _ParamTex (&quot;Parameter Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #define REVERSE 1            #define ADD 1            #pragma multi_compile __ UNITY_UI_ALPHACLIP            #pragma multi_compile __ FADE CUTOFF DISSOLVE            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #define UI_TRANSITION 1            #include &quot;UIEffect.cginc&quot;            #include &quot;UIEffectSprite.cginc&quot;            fixed4 frag(v2f IN) : SV_Target            &#123;                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd);                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                color = ApplyTransitionEffect(color, IN.eParam) * IN.color;                #if UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片溶解</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E6%BA%B6%E8%A7%A3/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E6%BA%B6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;Hidden/UI/Default (UIDissolve)&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        [Header(Dissolve)]        _TransitionTex (&quot;Transition Texture (A)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _ParamTex (&quot;Parameter Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #define DISSOLVE 1            #pragma multi_compile __ UNITY_UI_ALPHACLIP            #pragma multi_compile __ ADD SUBTRACT FILL            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #define UI_DISSOLVE 1            #include &quot;UIEffect.cginc&quot;            #include &quot;UIEffectSprite.cginc&quot;            fixed4 frag(v2f IN) : SV_Target            &#123;                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                // Dissolve                color = ApplyTransitionEffect(color, IN.eParam);                #ifdef UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片交叉移动</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E4%BA%A4%E5%8F%89%E7%A7%BB%E5%8A%A8/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E4%BA%A4%E5%8F%89%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;UIEffect/UV Cross&quot;&#123;    Properties    &#123;      [PerRendererData]  _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Vector(&quot;Count And Move&quot;,Vector)=(1,1,1,1)    _xOffset(&quot;xOffset&quot;,float)=10    //_yOffset(&quot;_yOffset&quot;,float)=10    _Rotate(&quot;Rotate&quot;,float)=10    _Scale(&quot;Scale&quot;,float)=1    &#125;    SubShader    &#123;        // No culling or depth        Cull Off ZWrite Off ZTest Always        Blend SrcAlpha OneMinusSrcAlpha        Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot;&#125;        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #include &quot;UnityCG.cginc&quot;            struct appdata            &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;float4 color:COLOR;            &#125;;            struct v2f            &#123;                float2 uv : TEXCOORD0;                float4 vertex : SV_POSITION;float4 color:COLOR;            &#125;;            v2f vert (appdata v)            &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                o.uv = v.uv;o.color=v.color;                return o;            &#125;            sampler2D _MainTex;            float4 _Vector;float _xOffset;//float _yOffset;float _Rotate;float _Scale;            fixed4 frag (v2f i) : SV_Target            &#123;                float2 count=_Vector.xy;i.uv=i.uv-0.5;                float2 uv=i.uv*count* ((sin(_Time.x*_Scale)+1)/2+1);                float2 finalUV = uv;float angle=_Rotate*_Time.x;                finalUV.x = uv.x * cos(angle) - uv.y * sin(angle);                finalUV.y = uv.x * sin(angle) + uv.y * cos(angle);                finalUV += float2(0.5f, 0.5f);                uv=finalUV;                uv.y+=_Time.x*_Vector.w;                uv.x+=_Time.x*_Vector.z*(((floor(uv.y)%2)-0.5)*2);                uv.x+=(floor(uv.y)%2)*_xOffset;                //uv.y+=(floor(uv.x)%2)*_yOffset;                fixed4 col = tex2D(_MainTex, uv);//return fixed4(1,1,1,1);                return col*i.color;            &#125;            ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片闪亮</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E9%97%AA%E4%BA%AE/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E9%97%AA%E4%BA%AE/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;Hidden/UI/Default (UIShiny)&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex (&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color (&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        _Stencil (&quot;Stencil ID&quot;, Float) = 0        _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        _ParamTex (&quot;Parameter Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;    &#125;    SubShader    &#123;        Tags        &#123;            &quot;Queue&quot;=&quot;Transparent&quot;            &quot;IgnoreProjector&quot;=&quot;True&quot;            &quot;RenderType&quot;=&quot;Transparent&quot;            &quot;PreviewType&quot;=&quot;Plane&quot;            &quot;CanUseSpriteAtlas&quot;=&quot;True&quot;        &#125;        Stencil        &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]        &#125;        Cull Off        Lighting Off        ZWrite Off        ZTest [unity_GUIZTestMode]        Blend SrcAlpha OneMinusSrcAlpha        ColorMask [_ColorMask]        Pass        &#123;            Name &quot;Default&quot;        CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma target 2.0            #pragma multi_compile __ UNITY_UI_ALPHACLIP            #include &quot;UnityCG.cginc&quot;            #include &quot;UnityUI.cginc&quot;            #define UI_SHINY 1            #include &quot;UIEffect.cginc&quot;            #include &quot;UIEffectSprite.cginc&quot;            fixed4 frag(v2f IN) : SV_Target            &#123;                half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;                color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                color = ApplyShinyEffect(color, IN.eParam);                #ifdef UNITY_UI_ALPHACLIP                clip (color.a - 0.001);                #endif                return color;            &#125;        ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片置灰</title>
      <link href="/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E7%BD%AE%E7%81%B0/"/>
      <url>/2023/06/19/Unity/Shader/%E5%9B%BE%E7%89%87%E7%BD%AE%E7%81%B0/</url>
      
        <content type="html"><![CDATA[<pre><code class="cg">Shader &quot;UI/ImageGrey&quot;&#123;    Properties    &#123;        [PerRendererData] _MainTex(&quot;Sprite Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Color(&quot;Tint&quot;, Color) = (1,1,1,1)        _StencilComp(&quot;Stencil Comparison&quot;, Float) = 8        _Stencil(&quot;Stencil ID&quot;, Float) = 0        _StencilOp(&quot;Stencil Operation&quot;, Float) = 0        _StencilWriteMask(&quot;Stencil Write Mask&quot;, Float) = 255        _StencilReadMask(&quot;Stencil Read Mask&quot;, Float) = 255        _ColorMask(&quot;Color Mask&quot;, Float) = 15        _Gray(&quot;Gray&quot;,Range(0,1)) = 0    &#125;        SubShader        &#123;            Tags            &#123;                &quot;Queue&quot; = &quot;Transparent&quot;                &quot;IgnoreProjector&quot; = &quot;True&quot;                &quot;RenderType&quot; = &quot;Transparent&quot;                &quot;PreviewType&quot; = &quot;Plane&quot;                &quot;CanUseSpriteAtlas&quot; = &quot;True&quot;            &#125;            Stencil            &#123;                Ref[_Stencil]                Comp[_StencilComp]                Pass[_StencilOp]                ReadMask[_StencilReadMask]                WriteMask[_StencilWriteMask]            &#125;            Cull back            Lighting Off            ZWrite Off            ZTest[unity_GUIZTestMode]            Blend SrcAlpha OneMinusSrcAlpha            ColorMask[_ColorMask]            Pass            &#123;                CGPROGRAM                #pragma vertex vert                #pragma fragment frag                #include &quot;UnityCG.cginc&quot;                #include &quot;UnityUI.cginc&quot;                #pragma multi_compile_local _ UNITY_UI_CLIP_RECT                struct appdata_t                &#123;                    float4 vertex   : POSITION;                    float4 color    : COLOR;                    float2 texcoord : TEXCOORD0;                &#125;;                struct v2f                &#123;                    float4 vertex   : SV_POSITION;                    fixed4 color : COLOR;                    half2 texcoord  : TEXCOORD0;                    float4 worldPosition : TEXCOORD1;                &#125;;                fixed4 _Color;                v2f vert(appdata_t IN)                &#123;                    v2f OUT;                    OUT.worldPosition = IN.vertex;                    OUT.vertex = UnityObjectToClipPos(IN.vertex);                    OUT.texcoord = IN.texcoord;                    #ifdef UNITY_HALF_TEXEL_OFFSET                        OUT.vertex.xy += (_ScreenParams.zw - 1.0) * float2(-1,1);                    #endif                    OUT.color = IN.color * _Color;                    return OUT;                &#125;                sampler2D _MainTex;                fixed _Gray;                float4 _ClipRect;                fixed4 frag(v2f IN) : SV_Target                &#123;                    half4 color = tex2D(_MainTex, IN.texcoord) * IN.color;                    clip(color.a - 0.01);                    if (_Gray &gt; 0) &#123;                        fixed gray = dot(color.rgb, fixed3(0.299, 0.587, 0.114));                        color.rgb = lerp(color.rgb,fixed3(gray, gray, gray),_Gray);                    &#125;                    #ifdef UNITY_UI_CLIP_RECT                        color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);                    #endif                    return color;                &#125;                ENDCG            &#125;        &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过github 发布package</title>
      <link href="/2023/06/18/Unity/UPM/UPM/"/>
      <url>/2023/06/18/Unity/UPM/UPM/</url>
      
        <content type="html"><![CDATA[<h3 id="发布自己的包"><a href="#发布自己的包" class="headerlink" title="发布自己的包"></a>发布自己的包</h3><ul><li>1、创建一个正常的unity项目</li><li>2、在Assets 目录下 创建好内容（必须包含内容如下图）</li><li>3、把做好的内容推送到主分支</li><li>4、<code>git subtree split --prefix=Assets/xxx --branch upm</code></li><li>5、推送 upm 分支到github（<code>git push origin upm:upm</code>）</li><li>6、<code>git tag 1.0.0 upm</code></li><li>7、<code>git push origin upm --tags</code></li></ul><p>后续修改只需要重复执行3-7即可</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>打开unity package manager</li><li>点击 add package form git</li><li>填写 <a href="https://github.com/OnClick9927/NodeGraph.git#1.0.1">https://github.com/OnClick9927/NodeGraph.git#1.0.1</a></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>删除远程tag git push origin :refs&#x2F;tags&#x2F;标签名  </li><li>删除本地 tag git tag -d 标签名</li></ul><p><img src="/../../../Pic/Unity/UPM/1.png"></p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UPM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-接口及其他定义的说明</title>
      <link href="/2023/06/09/Doc/WooPool/WooPool-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/06/09/Doc/WooPool/WooPool-%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E4%BB%96%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="IObjectPool"><a href="#IObjectPool" class="headerlink" title="IObjectPool"></a>IObjectPool</h2><p>定义了对象池的<strong>对象数量</strong>、<strong>对象类型</strong>和<strong>回收方法</strong></p><pre><code class="csharp">public interface IObjectPool:IDisposable</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>获取当前对象池里对象的个数</td></tr><tr><td>type</td><td>获取当前对象池中对应对象的对象类型</td></tr></tbody></table><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Set(object,IPoolArgs)</td><td>将对象回收，也就是将对象放回到对象池中<br />回收成功时返回<code>true</code>，失败时返回<code>false</code></td></tr></tbody></table><h2 id="IPoolObject"><a href="#IPoolObject" class="headerlink" title="IPoolObject"></a>IPoolObject</h2><p>定义了对象池对象的生命周期的三个阶段</p><pre><code class="csharp">public interface IPoolObject : IDisposable</code></pre><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>OnAllocate()</td><td>在对象被创建时调用</td></tr><tr><td>OnGet()</td><td>在对象从对象池中被取出时调用</td></tr><tr><td>OnSet()</td><td>在对象被回收回对象池时调用</td></tr></tbody></table><h2 id="IPoolArgs"><a href="#IPoolArgs" class="headerlink" title="IPoolArgs"></a>IPoolArgs</h2><p>此接口用于抽象构造的参数</p><pre><code class="csharp">public interface IPoolArgs</code></pre><h2 id="PoolUnit"><a href="#PoolUnit" class="headerlink" title="PoolUnit"></a>PoolUnit</h2><p>定义对象池的销毁状态和销毁方法</p><pre><code class="csharp">public abstract class PoolUnit : IDisposable</code></pre><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>disposed</td><td>当前对象池是否被销毁</td></tr></tbody></table><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>OnDispose()</td><td>在对象池被销毁时调用</td></tr><tr><td>Dispose()</td><td>销毁对象池</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-全局对象池</title>
      <link href="/2023/06/08/Doc/WooPool/WooPool-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/08/Doc/WooPool/WooPool-%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>全局的对象池，不用考虑创建对象池，不用考虑对象的类型，即拿即用，用完归还。</p><ul><li>全局对象池操作使用PoolEx类</li><li><em><strong>注意回收时要自己初始化数据！！！</strong></em></li></ul><pre><code class="csharp">public static class PoolEx</code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>GetGlbalPoolCount&lt;T&gt;()</td><td>public</td><td>从对象池中获取对应类型的数组对象</td></tr><tr><td>SetGlbalPool&lt;T&gt;(ObjectPool&lt;T&gt;)</td><td>public</td><td>将数组对象放回对象池</td></tr><tr><td>GlobalAllocate&lt;T&gt;(IPoolArgs)</td><td>public</td><td>全局分配对应类型的对象</td></tr><tr><td>GlobalAllocate(Type,IPoolArgs)</td><td>public</td><td>全局分配对应类型的对象</td></tr><tr><td>GlobalRecyle&lt;T&gt;(T,IPoolArgs)</td><td>public</td><td>全局回收</td></tr><tr><td>GlobalAllocateArray&lt;T&gt;(int)</td><td>public</td><td>获取对应类型和长度的数组对象</td></tr></tbody></table><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code class="csharp">//全局对象池示例void GlobalPoolExample() &#123;    //全局获取一个对象    var human = PoolEx.GlobalAllocate&lt;Human&gt;();    //全局回收一个对象    PoolEx.GlobalRecyle(human);    //从全局对象池中获取一个长度为10的数组对象    var arr = PoolEx.GlobalAllocateArray&lt;Human&gt;(10);    //Human类的定义在第一个示例    arr[0] = new Human(33, &quot;吉良吉影&quot;);    arr[0].Say();    //回收掉这个数组对象    PoolEx.GlobalRecyle(arr);    //重新从全局对象池中获取长度为10的数组对象    arr = PoolEx.GlobalAllocateArray&lt;Human&gt;(10);    arr[0].Say();    PoolEx.GlobalRecyle(arr);    //可以发现是和原先同样的对象    //因此回收的时候需要注意初始化数据！！！！&#125;//示例所需的类public class Human&#123;    public readonly int age;    public readonly string name;    public Human(int age, string name)    &#123;        this.age = age;        this.name = name;    &#125;    public Human()     &#123;        age= 0;        name = &quot;无名&quot;;    &#125;    public void Say()    &#123;        Console.WriteLine($&quot;我的名字叫&#123;name&#125;,&#123;age&#125;岁&quot;);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-基类对象池</title>
      <link href="/2023/06/07/Doc/WooPool/WooPool-%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/07/Doc/WooPool/WooPool-%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设置一个基类，可以从这个对象池中拿出继承这个基类的对象</p><pre><code class="csharp">public abstract class BaseTypePool&lt;T&gt; : PoolUnit</code></pre><h4 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h4><p>基类对象池的本质是一个Key为 类型，Value为 对应类型对象池 的字典。获取对象时，根据类型找到对应的对象池，并从对应的对象池中获取对象。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>注：下面的<code>Object</code>类型是泛型类型，为了区分基类的泛型<code>T</code></p><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>SetPool&lt;Object&gt;(ObjectPool&lt;Object&gt;)</td><td>public</td><td>将对象池放入基类对象池中</td></tr><tr><td>SetPool(Type, IObjectPool)</td><td>public</td><td>将对应类型的对象池放入基类对象池中</td></tr><tr><td>GetPool&lt;Object&gt;()</td><td>public</td><td>根据类型获取对象池</td></tr><tr><td>GetPool(Type)</td><td>public</td><td>根据类型获取对象池</td></tr><tr><td>CreatePool(Type)</td><td>protected virtual</td><td>创建对象池</td></tr><tr><td>Get&lt;Object&gt;(IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的对象</td></tr><tr><td>Get(Type,IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的对象</td></tr><tr><td>Set&lt;Object&gt;(Object,IPoolArgs)</td><td>public</td><td>将对应类型的对象放回对象池</td></tr><tr><td>Set(Type,T,IPoolArgs)</td><td>public</td><td>将对应类型的对象放回对象池</td></tr><tr><td>GetPoolCount&lt;Object&gt;()</td><td>public</td><td>获取对应类型的对象池中对象的数量</td></tr><tr><td>GetPoolCount(Type)</td><td>public</td><td>获取对应类型的对象池中对象的数量</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁基类对象池</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//定义一个叫IObject的接口public interface IObject &#123; &#125;//创建两个实现IObject接口的类public class Obj_A : IObject &#123; &#125;public class Obj_B : IObject &#123; &#125;//以IObject为基类定义一个基类对象池public class MyBaseTypePool : BaseTypePool&lt;IObject&gt; &#123; &#125;//定义一个存放Obj_A对象的对象池public class ObjectPoolA : ObjectPool&lt;Obj_A&gt;&#123;    protected override Obj_A CreateNew(IPoolArgs arg)    &#123;        return new Obj_A();    &#125;&#125;//基类对象池使用示例方法void BaseTypePoolExample()&#123;    //创建基类对象池    MyBaseTypePool pool = new MyBaseTypePool();    //从基类对象池中获取Obj_A类型的对象    IObject _obj = pool.Get&lt;Obj_A&gt;();    //将对象放回    pool.Set(_obj);    //从基类对象池中获取Obj_B类型的对象    _obj = pool.Get(typeof(Obj_B));    //将对象放回    pool.Set(_obj);    //从基类对象池中获取Obj_A类型的对象池    ObjectPool&lt;Obj_A&gt; objPoolA = pool.GetPool&lt;Obj_A&gt;();    //也可使用如下方法    //ObjectPool&lt;Obj_A&gt; objPoolA = (ObjectPool&lt;Obj_A&gt;)pool.GetPool(typeof(Obj_A));    //创建一个Obj_A的对象池，替换基类对象池中的对应对象池    pool.SetPool(new ObjectPoolA());&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-数组对象池</title>
      <link href="/2023/06/06/Doc/WooPool/WooPool-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/06/Doc/WooPool/WooPool-%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>能拿出数组对象的对象池</p><pre><code class="csharp">public class ArrayPool&lt;T&gt; : ObjectPool&lt;T[]&gt;</code></pre><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>参数ArrayPoolArg用于传入数组长度</p><pre><code class="csharp">public struct ArrayPoolArg : IPoolArgs</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>数组长度</td></tr></tbody></table><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><pre><code class="csharp">public ArrayPoolArg(int length)</code></pre><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>length</td><td>int</td><td>用于参数构造时传入数组长度</td></tr></tbody></table><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>Get(IPoolArgs)</td><td>public</td><td>从对象池中获取对应类型的数组对象</td></tr><tr><td>Set(T[],IPoolArgs)</td><td>public</td><td>将数组对象放回对象池</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁基类对象池</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">void ArrayPoolExample()&#123;    //创建数组对象池，示例使用存放int值的数组    var pool = new ArrayPool&lt;int&gt;();    //从数组对象池中拿出一个长度为2的数组    var objA = pool.Get(new ArrayPoolArg(2));    Console.WriteLine(&quot;取出的数组长度为&quot;+objA.Length);    //将数组中的第一个元素设置成1    objA[0] = 1;    //将数组回收，再拿出一个长度为2的数组    pool.Set(objA);    objA = pool.Get(new ArrayPoolArg(2));    //打印第一个元素    Console.WriteLine(&quot;数组的第一个元素的值为：&quot;+ objA[0]);    //因此需要注意放回数组时 根据自己需求判断是否需要重置一下数组&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-Activator构建对象池</title>
      <link href="/2023/06/05/Doc/WooPool/WooPool-Activator%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/05/Doc/WooPool/WooPool-Activator%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用Activator自动构建对象的对象池，支持传入对象创建时所需的参数</p><pre><code class="csharp">public class ActivatorCreatePool&lt;T&gt; : ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">public ActivatorCreatePool(params object[] args)</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>args</code></td><td>object[]</td><td>用于对象构造时所需的参数</td></tr></tbody></table><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>获取当前对象池里对象的个数（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>type</td><td>获取当前对象池中对应对象的对象类型（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>disposed</td><td>当前对象池是否被销毁（继承自 PoolUnit）</td></tr></tbody></table><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Get()</td><td>从对象池中获取对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Set(T)</td><td>将对象回收到对象池中（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Clear()</td><td>清空对象池中的所有对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Clear(int)</td><td>清除对象池里一定数量的对象（继承自 ObjectPool&lt;T&gt;）</td></tr><tr><td>Dispose()</td><td>销毁对象池（继承自 PoolUnit）</td></tr></tbody></table><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><pre><code class="csharp">/// &lt;summary&gt;/// 示例将会用到的示例类型，构造函数不含参数/// &lt;/summary&gt;public class Bottle &#123; &#125;/// &lt;summary&gt;/// 示例将会用到的示例类型，构造函数包含age和name两个参数/// &lt;/summary&gt;public class Human&#123;    public readonly int age;    public readonly string name;    public Human(int age, string name)    &#123;        this.age = age;        this.name = name;    &#125;    public void Say()    &#123;        Console.WriteLine($&quot;我的名字叫&#123;name&#125;,&#123;age&#125;岁&quot;);    &#125;&#125;/// &lt;summary&gt;/// ActivatorPool的使用示例/// &lt;/summary&gt;private void ActivatorPoolExample()&#123;    //创建一个存放Bottle的对象池    ActivatorCreatePool&lt;Bottle&gt; pool = new ActivatorCreatePool&lt;Bottle&gt;();        //从对象池中获取一个对象    var bottle = pool.Get();        //用对象池的Set方法将对象放回对象池    pool.Set(bottle);        //创建一个能够根据参数创建对象的对象池    //此处以Human类为例，传入age和name    ActivatorCreatePool&lt;Human&gt; humanPool = new ActivatorCreatePool&lt;Human&gt;(33, &quot;吉良吉影&quot;);    var human = humanPool.Get();    //调用对象的Say方法    human.Say();    //输出内容为 我的名字叫吉良吉影,33岁&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-委托对象池</title>
      <link href="/2023/06/04/Doc/WooPool/WooPool-%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/04/Doc/WooPool/WooPool-%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用委托创建对象的对象池，用于在CreateNew()中调用,方便外部动态修改创建对象的方法</p><pre><code class="csharp">public abstract class DelegatePool&lt;T&gt; : ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">public DelegatePool(Func&lt;T&gt; create)</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>create</td><td>Func&lt;T&gt;</td><td>创建对象的委托</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//用于示例的类型public class Obj_A &#123; &#125;//定义一个存放Obj_A对象的委托对象池public class DelegatePoolA : DelegatePool&lt;Obj_A&gt;&#123;    public DelegatePoolA(Func&lt;Obj_A&gt; create) : base(create)    &#123;    &#125;&#125;//创建Obj_A对象的方法Obj_A CreateObject()&#123;    Console.WriteLine(&quot;我创建了一个对象，哈哈哈哈哈哈！&quot;);    return new Obj_A();&#125;void DelegatePoolExample()&#123;    //创建委托对象池    var pool = new DelegatePoolA(CreateObject);    //获取一个对象，内部创建新对象时会调用方法    var objA = pool.Get();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-有容量的对象池</title>
      <link href="/2023/06/03/Doc/WooPool/WooPool-%E6%9C%89%E5%AE%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2023/06/03/Doc/WooPool/WooPool-%E6%9C%89%E5%AE%B9%E9%87%8F%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>限制容量大小的对象池</p><pre><code class="csharp">public abstract class CapacityPool&lt;T&gt;: ObjectPool&lt;T&gt;</code></pre><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><pre><code class="csharp">protected CapacityPool(int capacity) : base() &#123; this._capacity = capacity; &#125;</code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table><thead><tr><th>参数名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>capacity</td><td>int</td><td>对象池的最大容量</td></tr></tbody></table><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>capacity</td><td>对象池的最大容量，创建后可重新修改</td></tr></tbody></table><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><pre><code class="csharp">//用于示例的类型public class Obj_A &#123; &#125;//定义一个存放Obj_A对象的对象池public class CapacityPoolA : CapacityPool&lt;Obj_A&gt;&#123;    public CapacityPoolA(int capacity) : base(capacity)    &#123;    &#125;    protected override Obj_A CreateNew(IPoolArgs arg)    &#123;        return new Obj_A();    &#125;&#125;//限制大小对象池的示例void CapacityPoolExample()&#123;    //创建对象池，设置大小为1    var pool = new CapacityPoolA(1);    //放入一个对象，不会报错    Console.WriteLine(&quot;回收第一个对象，结果为：&quot; + pool.Set(new Obj_A()));    //再放入一个对象，会发现存放失败    Console.WriteLine(&quot;回收第二个对象，结果为：&quot; + pool.Set(new Obj_A()));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-基本定义</title>
      <link href="/2023/06/02/Doc/WooPool/WooPool-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89/"/>
      <url>/2023/06/02/Doc/WooPool/WooPool-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对象池的基本定义，包括基本属性、基本方法、生命周期</p><pre><code class="csharp">public abstract class ObjectPool&lt;T&gt; : PoolUnit, IDisposable, IObjectPool</code></pre><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><table><thead><tr><th>属性名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>count</td><td>public</td><td>获取当前对象池里对象的个数</td></tr><tr><td>type</td><td>public</td><td>获取当前对象池中对应对象的对象类型</td></tr><tr><td>pool</td><td>protected</td><td>对象池的数据容器，默认是队列</td></tr><tr><td>para</td><td>protected</td><td>锁</td></tr></tbody></table><h2 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h2><table><thead><tr><th>方法名</th><th>可见性级别</th><th>说明</th></tr></thead><tbody><tr><td>Get(IPoolArgs)</td><td>public virtual</td><td>从对象池中获取对象</td></tr><tr><td>Set(object,IPoolArgs)</td><td>public</td><td>将对象回收到对象池中，回收成功时返回true，失败时返回false</td></tr><tr><td>Set(T,IPoolArgs)</td><td>public virtual</td><td>将对象回收到对象池中，回收成功时返回true，失败时返回false</td></tr><tr><td>RealSet(T,IPoolArgs)</td><td>protected</td><td>对象回收的实际方法，上面两个只是用于调用的</td></tr><tr><td>Clear(IPoolArgs)</td><td>public</td><td>清空对象池中的所有对象</td></tr><tr><td>Clear(int,IPoolArgs)</td><td>public</td><td>清除对象池里一定数量的对象</td></tr><tr><td>CreateNew(IPoolArgs )</td><td>protected abstract</td><td>创建对象的方法，需要子类实现</td></tr><tr><td>Dispose()</td><td>public</td><td>销毁对象池（继承自 PoolUnit）</td></tr></tbody></table><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>需要在对应周期增加操作时可以重写对应的方法</p><table><thead><tr><th>生命周期名</th><th>说明</th></tr></thead><tbody><tr><td>OnCreate(T, IPoolArgs)</td><td>对象池创建对象时调用</td></tr><tr><td>OnGet(T, IPoolArgs)</td><td>对象池中的对象被获取时调用</td></tr><tr><td>OnSet(T, IPoolArgs)</td><td>对象被回收时调用，返回false时表示不能回收</td></tr><tr><td>OnClear(T, IPoolArgs)</td><td>对象池中的对象被清除时调用</td></tr><tr><td>OnDispose()</td><td>对象池被销毁时调用</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooPool-简介</title>
      <link href="/2023/06/01/Doc/WooPool/WooPool-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/06/01/Doc/WooPool/WooPool-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h4 id="为什么要使用对象池？"><a href="#为什么要使用对象池？" class="headerlink" title="为什么要使用对象池？"></a>为什么要使用对象池？</h4><p>对象在生成和销毁时都是需要一定开销的，如果某个类型频繁地生成对象和销毁对象，会导致开销过大，影响性能。</p><p>举个例子：</p><ol><li><p>我们厨房里的碗架（对象池），容纳着很多个碗（对象）。</p></li><li><p>我们在盛饭的时候，从碗架里拿出一个碗（从对象池中拿出一个对象）。</p></li><li><p>在吃完饭之后，洗碗（对象的初始化）、放回碗架（将对象回收，放回到对象池中）。</p></li></ol><p>上述例子中，如果不使用对象池，也就意味着碗是一次性的，也就是吃完就把碗摔了，然后要用的时候再花钱买个新的碗，这样的做法很明显是特别烧钱（浪费资源）的。</p><h4 id="WooPool特点"><a href="#WooPool特点" class="headerlink" title="WooPool特点"></a>WooPool特点</h4><ul><li><p>支持传入参数构建对象</p></li><li><p>支持对象池创建对象时调用委托</p></li><li><p>支持限定对象池大小</p></li><li><p>支持从基类对象池中取出子类</p></li><li><p>支持数组对象池</p></li><li><p>支持操作非常简单的全局对象池</p></li><li><p>支持多个生命周期</p></li><li><p>支持自己扩展对象池</p></li></ul><h3 id="感谢使用WooPool！"><a href="#感谢使用WooPool！" class="headerlink" title="感谢使用WooPool！"></a>感谢使用WooPool！</h3><h3 id="欢迎加入QQ交流群782290296，各路大佬给你解惑！"><a href="#欢迎加入QQ交流群782290296，各路大佬给你解惑！" class="headerlink" title="欢迎加入QQ交流群782290296，各路大佬给你解惑！"></a>欢迎加入QQ交流群<a href="https://jq.qq.com/?_wv=1027&k=sbKbmsTY">782290296</a>，各路大佬给你解惑！</h3>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooPool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat 安装教程</title>
      <link href="/2023/05/23/DB/Navicat/"/>
      <url>/2023/05/23/DB/Navicat/</url>
      
        <content type="html"><![CDATA[<h2 id="Navicat-安装教程-下载"><a href="#Navicat-安装教程-下载" class="headerlink" title="Navicat 安装教程 下载"></a>Navicat 安装教程 <a href="https://wwqq.lanzouf.com/iszHt0x1hikf">下载</a></h2><p>1、正常安装（装完不要打开）<br>2、断网<br>3、右键NavicatCracker.exe以管理员身份运行。<br>4、选择刚刚的安装目录，点击Patch<br>5、点击是<br>6、打开注册软件.点击Generate生成注册码.再点击copy.<br>7、打开Navicat16,点击注册<br>8、粘贴刚刚生成的注册码,点击激活.<br>9、点击手动激活<br>10、复制下图中生成的请求码<br>11、将 Navicat 给的请求码复制到注册机 Request Code 中<br>12、点击 Generate Activation Code进行激活.复制激活码.<br>13、然后粘贴激活码.点击激活即可.</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooTween-简介</title>
      <link href="/2023/05/22/Doc/WooTween/WooTween-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/05/22/Doc/WooTween/WooTween-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="WooTween介绍"><a href="#WooTween介绍" class="headerlink" title="WooTween介绍"></a>WooTween介绍</h2><ul><li>内容：实现一个简易的、易扩展、支持编辑器预览的动画模块</li><li>适合人群<ul><li>高手 切磋</li><li>中手 理解、提高代码设计能力</li><li>低手 感受代码的魅力，扩展思路</li></ul></li></ul><h2 id="内容组成"><a href="#内容组成" class="headerlink" title="内容组成"></a>内容组成</h2><ul><li>0、对象池           默默无闻的螺丝钉</li><li>1、驱动器           好司机</li><li>2、转换器           翻译官</li><li>3、TweenValue      单程车</li><li>4、Tween           花样百出的乘客</li><li>5、Component       好保姆</li></ul><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><ul><li>为什么要使用对象池？<ul><li>频繁的 new 对象，会对GC 有压力</li><li>在tween的实现中 ，需要大量的的对象，这些对象并不是一直在使用</li></ul></li><li>包含内容：<ul><li>通用对象池，最简单的对象池</li><li>自动对象对象池，当对象不够时候，自动创建对象</li><li>全局对象池扩展，全局分配任意对象，简化使用</li></ul></li></ul><h2 id="驱动器"><a href="#驱动器" class="headerlink" title="驱动器"></a>驱动器</h2><ul><li>这是什么玩意儿？<ul><li>整个tween 模块的驱动器</li></ul></li><li>为什么需要？<ul><li>整个模块需要逐帧的运行，他的作用就是驱动模块运行</li><li>我们的tween是支持编辑器预览的，所以编辑器和运行时需要各自的驱动</li></ul></li></ul><h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><ul><li>这是什么玩意儿？<ul><li>曲线转换器</li></ul></li><li>为什么需要？<ul><li>我们的tween是具有曲线运行能力的</li><li>我们的tween需要支持多种曲线</li><li>我们的tween需要支持多种曲线类型</li></ul></li></ul><h2 id="TweenValue"><a href="#TweenValue" class="headerlink" title="TweenValue"></a>TweenValue</h2><ul><li>这是什么玩意儿？<ul><li>负责把一个值 逐帧的变化到目标值</li></ul></li><li>为什么需要？<ul><li>他是单向的</li><li>他是整个tween的核心之一</li></ul></li></ul><h2 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h2><ul><li>这是什么玩意儿？<ul><li>建立于 TweenValue 之上，与用户交互</li></ul></li><li>为什么需要？<ul><li>提供 双方向运行能力</li><li>提供 中断、重启、恢复能力</li></ul></li></ul><h2 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h2><ul><li>这是什么玩意儿？<ul><li>直接在编辑器的环境之下，运行动画</li></ul></li><li>为什么需要？<ul><li>更加直观的看到效果</li><li>不再需要超多的代码</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooTween </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooTween </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WooAsset-简介</title>
      <link href="/2023/05/19/Doc/WooAsset/0-WooAsset-%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/05/19/Doc/WooAsset/0-WooAsset-%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a><a href="https://github.com/OnClick9927/WooAsset">地址</a></h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>WooAsset可以满足以下任何需求：</p><ul><li>我想发布一个不包含任何游戏资源的安装包，然后玩家边玩边下载。</li><li>我想发布一个可以保证前期体验的安装包，然后玩家自己选择下载关卡内容。</li><li>我想发布一个保证300MB以下内容的安装包，然后进入游戏之前把剩余内容下载完毕。</li><li>我想发布一个偏单机的游戏安装包，在网络畅通的时候，支持正常更新。在没有网络的时候，支持游玩老版本。</li><li>我想发布一个MOD游戏安装包，玩家可以把自己制作的MOD内容上传到服务器，其它玩家可以下载游玩。</li><li>我们在制作一个超大体量的项目，有上百GB的资源内容，每次构建都花费大量时间，是否可以分工程构建？</li></ul><h2 id="系统特点"><a href="#系统特点" class="headerlink" title="系统特点"></a>系统特点</h2><ul><li>Editor、Runtime均支持同步、异步、委托、携程</li><li>支持各个模式切换（无需修改代码）</li><li>支持自定义资源加密</li><li>支持分布式构建(支持mod)</li><li>支持 shader 变体收集</li><li>支持 构建 spriteAtlas</li><li>支持打包&#x2F;加载Unity无法识别的文件</li><li>支持打包流程自定义（自定义分包、版本规划、结束流程、自定义标签）</li><li>包含本地资源服务器</li><li>支持快速版本切换，回退</li><li>支持资源模糊搜索</li><li>支持自定义下载器</li><li>支持子资源加载</li><li>支持资源懒卸载&#x2F;内存大小控制</li><li>支持WebGL</li><li>支持加载Resources文件夹内容</li></ul><h2 id="支持的模式"><a href="#支持的模式" class="headerlink" title="支持的模式"></a>支持的模式</h2><p>各个模式切换无需修改代码</p><ul><li>0 编辑器模拟加载         (纯粹编辑器模拟)</li><li>1 纯粹的C#空包，   （注意：本地不会有任何ab）</li><li>2 发布 正常流程包       （比模式1 多一个版本检查）</li><li>3 发布 游戏前期的体验包  (把资源拷贝到stream)</li><li>4 边玩边下载</li><li>5 先准备一部分，后续靠下载</li></ul><h3 id="模式区别"><a href="#模式区别" class="headerlink" title="模式区别"></a>模式区别</h3><table><tr><th></th><th>模式/流程</th><th>编辑器模拟</th><th>纯C#空包</th><th>正常流程</th><th>前期的体验</th><th>边玩边下载</th><th>先准备一部分</th></tr><tr ><td rowspan="5">打包</td></tr><tr><th>选择FastMode        </th><th>✔</th><th> </th><th> </th><th> </th><th> </th><th> </th></tr><tr><th>打包资源            </th><th>  </th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th></tr><tr><th>拷贝资源到stream     </th><th>  </th><th> </th><th> </th><th>✔</th><th> </th><th>按tag拷贝</th></tr><tr><th>上传资源到服务器     </th><th>  </th><th>✔</th><th>✔</th><th> </th><th>✔</th><th>✔</th></tr><tr ><td rowspan="7">加载</td></tr><tr><th>设置AssetsSetting   </th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th></tr><tr><th>拷贝资源到沙盒路径   </th><th> </th><th> </th><th> </th><th>✔</th><th> </th><th>✔</th></tr><tr><th>版本检查            </th><th> </th><th> </th><th>✔</th><th> </th><th>可选</th><th>可选</th></tr><tr><th>下载变化资源        </th><th> </th><th> </th><th>✔</th><th> </th><th> </th><th>可选</th></tr><tr><th>初始化              </th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th></tr><tr><th>正常加载            </th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th><th>✔</th></tr></table>]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊-毛玻璃</title>
      <link href="/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/"/>
      <url>/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../../Pic/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83.png" alt="效果"></p><pre><code class="cg">Shader &quot;UI/UiObscure&quot;&#123;    Properties    &#123;        _Radius(&quot;Radius&quot;, Range(1, 255)) = 1        _MainTex(&quot;Tint Color (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Interval(&quot;Blur Nuance&quot;,Range(0.1, 100)) = 1        [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)] _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        [HideInInspector] _Stencil (&quot;Stencil ID&quot;, Float) = 0        [HideInInspector][Enum(UnityEngine.Rendering.StencilOp)] _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        [HideInInspector] _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        [HideInInspector] _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        [HideInInspector] _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        // Outline properties are drawn via custom editor.        [HideInInspector] _OutlineWidth(&quot;Outline Width&quot;, Range(0,8)) = 3.0        [HideInInspector] _OutlineColor(&quot;Outline Color&quot;, Color) = (1,1,0,1)        [HideInInspector] _OutlineReferenceTexWidth(&quot;Reference Texture Width&quot;, Int) = 1024        [HideInInspector] _ThresholdEnd(&quot;Outline Threshold&quot;, Range(0,1)) = 0.25        [HideInInspector] _OutlineSmoothness(&quot;Outline Smoothness&quot;, Range(0,1)) = 1.0        [HideInInspector][MaterialToggle(_USE8NEIGHBOURHOOD_ON)] _Use8Neighbourhood(&quot;Sample 8 Neighbours&quot;, Float) = 1        [HideInInspector] _OutlineMipLevel(&quot;Outline Mip Level&quot;, Range(0,3)) = 0    &#125;     Category    &#123;        Tags&#123; &quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;         SubShader        &#123;                     Stencil            &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]            &#125;                        Cull Off            Lighting Off            ZWrite Off            ZTest [unity_GUIZTestMode]            Fog &#123; Mode Off &#125;            Blend One OneMinusSrcAlpha            ColorMask [_ColorMask]                    GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM                #pragma vertex vert                #pragma fragment frag                #pragma fragmentoption ARB_precision_hint_fastest                #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                    v2f o;                    o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                    float scale = -1.0;                    #else                    float scale = 1.0;                    #endif                    o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                    o.uvgrab.zw = o.vertex.zw;                    return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                float _Interval;                half4 frag(v2f i) : COLOR                &#123;                    half4 sum = half4(0,0,0,0);                                 #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                                 sum += GRABXYPIXEL(0.0, 0.0);                    int measurments = 1;                                 for (float range = _Interval; range &lt;= _Radius; range += _Interval)                    &#123;                        sum += GRABXYPIXEL(range, range);                        sum += GRABXYPIXEL(range, -range);                        sum += GRABXYPIXEL(-range, range);                        sum += GRABXYPIXEL(-range, -range);                        measurments += 4;                    &#125;                    return sum / measurments;                &#125;            ENDCG            &#125;        GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma fragmentoption ARB_precision_hint_fastest            #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                float scale = -1.0;                    #else                float scale = 1.0;                    #endif                o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                o.uvgrab.zw = o.vertex.zw;                return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                    half4 frag(v2f i) : COLOR                &#123;                            half4 sum = half4(0,0,0,0);                float radius = 1.41421356237 * _Radius;                                #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                            sum += GRABXYPIXEL(0.0, 0.0);                int measurments = 1;                            for (float range = 1.41421356237f; range &lt;= radius * 1.41; range += 1.41421356237f)                &#123;                sum += GRABXYPIXEL(range, 0);                sum += GRABXYPIXEL(-range, 0);                sum += GRABXYPIXEL(0, range);                sum += GRABXYPIXEL(0, -range);                measurments += 4;                &#125;                            return sum / measurments;                &#125;            ENDCG            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可穿透按钮</title>
      <link href="/2023/05/16/Unity/UGUI/%E5%8F%AF%E7%A9%BF%E9%80%8F%E6%8C%89%E9%92%AE/"/>
      <url>/2023/05/16/Unity/UGUI/%E5%8F%AF%E7%A9%BF%E9%80%8F%E6%8C%89%E9%92%AE/</url>
      
        <content type="html"><![CDATA[<pre><code class="csharp">using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.EventSystems;using UnityEngine.UI;public class PenetratableButton : Button&#123;    List&lt;RaycastResult&gt; results = new List&lt;RaycastResult&gt;();    [Header(&quot;向下穿几层&quot;)]    public int depth = 1;    private List&lt;GameObject&gt; gos = new List&lt;GameObject&gt;();    public override void OnPointerDown(PointerEventData eventData)    &#123;        gos.Clear();        results.Clear();        base.OnPointerDown(eventData);        EventSystem.current.RaycastAll(eventData, results);        GameObject current = eventData.pointerCurrentRaycast.gameObject;        int _depth = 0;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject == current)            &#123;                _depth = results[i].depth;                break;            &#125;        &#125;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject != current &amp;&amp; results[i].depth &gt;= _depth - this.depth)            &#123;                gos.Add(results[i].gameObject);                ExecuteEvents.Execute(results[i].gameObject, eventData, ExecuteEvents.pointerDownHandler);            &#125;        &#125;    &#125;    public override void OnPointerUp(PointerEventData eventData)    &#123;        results.Clear();        base.OnPointerUp(eventData);        EventSystem.current.RaycastAll(eventData, results);        GameObject current = eventData.pointerCurrentRaycast.gameObject;        int _depth = 0;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject == current)            &#123;                _depth = results[i].depth;                break;            &#125;        &#125;        for (int i = 0; i &lt; gos.Count; i++)        &#123;            ExecuteEvents.Execute(gos[i].gameObject, eventData, ExecuteEvents.pointerUpHandler);        &#125;    &#125;    public override void OnPointerClick(PointerEventData eventData)    &#123;        results.Clear();        base.OnPointerClick(eventData);        EventSystem.current.RaycastAll(eventData, results);        GameObject current = eventData.pointerCurrentRaycast.gameObject;        int _depth = 0;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject == current)            &#123;                _depth = results[i].depth;                break;            &#125;        &#125;        for (int i = 0; i &lt; results.Count; i++)        &#123;            if (results[i].gameObject != current &amp;&amp; results[i].depth &gt;= _depth - this.depth)            &#123;                ExecuteEvents.Execute(results[i].gameObject, eventData, ExecuteEvents.pointerClickHandler);            &#125;        &#125;    &#125;&#125;</code></pre><pre><code class="csharp">using UnityEditor;[CustomEditor(typeof(PenetratableButton))]public class PenetratableButtonEditor : Editor&#123;    private SerializedProperty property;    private void OnEnable()    &#123;        property = serializedObject.FindProperty(&quot;depth&quot;);    &#125;    public override void OnInspectorGUI()    &#123;        EditorGUILayout.PropertyField(property);        &#123;            serializedObject.ApplyModifiedProperties();        &#125;        base.OnInspectorGUI();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> UGUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UGUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书写方式</title>
      <link href="/2023/05/15/README/"/>
      <url>/2023/05/15/README/</url>
      
        <content type="html"><![CDATA[<h2 id="sadasda"><a href="#sadasda" class="headerlink" title="sadasda"></a>sadasda</h2><h4 id="57d8a"><a href="#57d8a" class="headerlink" title="57d8a"></a>57d8a</h4><ul><li>哈哈哈</li><li>康康康<ul><li>777</li><li>888</li></ul></li><li>999</li></ul><pre><code class="csharp">public class A&#123;    public void DO()&#123;&#125;&#125;</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><img src="/../Pic/R-C.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
