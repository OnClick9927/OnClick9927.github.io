<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WooAsset-1</title>
      <link href="/2023/05/19/Doc/WooAsset/WooAsset-1/"/>
      <url>/2023/05/19/Doc/WooAsset/WooAsset-1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文档 </category>
          
          <category> WooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步与Task-Like</title>
      <link href="/2023/05/19/Unity/CSharp/%E5%BC%82%E6%AD%A5%E4%B8%8ETaskLike/"/>
      <url>/2023/05/19/Unity/CSharp/%E5%BC%82%E6%AD%A5%E4%B8%8ETaskLike/</url>
      
        <content type="html"><![CDATA[<h3 id="文末有反编译IL代码，文首有原理分析！！！"><a href="#文末有反编译IL代码，文首有原理分析！！！" class="headerlink" title="文末有反编译IL代码，文首有原理分析！！！"></a>文末有反编译IL代码，文首有原理分析！！！</h3><p><a href="https://github.com/yueh0607/AirFramework/tree/main/Framework/Core/Async">我的项目地址-github</a>这个地址有可能要求梯子，球球了，觉得好就点个star吧<br>如果上面地址进不去，就进这个<a href="https://gitee.com/imyueh/AirFramework/tree/main/Assets/Framework/Core/Async">”gitee地址“</a>这个更新可能不及时，但是作为参考没问题</p><h1 id="1-异步"><a href="#1-异步" class="headerlink" title="1.异步"></a>1.异步</h1><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202303241053728.png" alt="在这里插入图片描述"></p><pre><code class="csharp">//这个方法在开始时自动被调用void Start()&#123;    AAA();    //这个代表输出到控制台”666“    666.L();&#125;//每隔一秒将输出一个数字，同时不会阻塞主线程的行为public async void AAA()    &#123;        await Async.Delay(1);        1.L();        await Async.Delay(1);        2.L();        await Async.Delay(1);        3.L();        await Async.Delay(1);        4.L();    &#125;</code></pre><p>按照同步的逻辑分析，666应该输出在1234之后，但是在异步中不同，AAA方法不会停留，而是继续向下，可以理解为新开了一个线程执行AAA方法，但是是假的，实际上还是在主线程里。</p><h2 id="原理分析-结合后面一起看"><a href="#原理分析-结合后面一起看" class="headerlink" title="原理分析(结合后面一起看)"></a>原理分析(结合后面一起看)</h2><p>1.Start方法执行到AAA进入方法<br>2.调用AsyncTaskMethodBuilder.Create静态创建并返回Builder<br>3.进入Delay获取Delay返回的AsyncTask对象<br>4.await等待AsyncTask时调用AsyncTask.GetAwaiter返回AsyncTask(IAwiter)<br>5.调用OnCompleted方法，将continuation委托更新为await以后的代码<br>5.等待Dealy方法内的Timer对象完成回调AsyncTask.SetResult方法<br>6.调用SetResult后，执行continuation委托，执行await之后的代码<br>7.进入下一个await</p><p>以上大错特错，其实这个过程是在编译时生成了一个异步状态机。用代码生成的方式展开了这个异步的过程，而不是在调用来调用去。</p><p>总结：OnCompleted的continuation就是await之后，直到方法结束的代码，每次执行到await都会执行来更新到下一个段落，此前会检查IsCompleted，然后需要我们调用SetResult才能切换到下一个状态。</p><h1 id="2-自定义await支持"><a href="#2-自定义await支持" class="headerlink" title="2.自定义await支持"></a>2.自定义await支持</h1><p>首先毫无道理的讲，<strong>C#就要求我们定义的类满足这个要求才能像下面这么写</strong>，原因简单粗暴：编译器要调用这个方法，按照要求做就可以。</p><pre><code class="csharp">await new AsyncTask();</code></pre><p><font color=red>  <strong>要想使得类支持await关键字的唯一要求：</strong> <strong>包含GetAwaiter方法</strong></font>(也可以是拓展方法)<br>我们当然不允许项目内出现这样的无礼要求！！！用接口约束可等待的类，<font color=red>  <strong>只要实现了这个接口，就能被await关键字支持。</strong></font></p><pre><code class="csharp">    public interface IAwaitable&lt;out TAwaiter&gt; where TAwaiter : IAwaiter    &#123;        TAwaiter GetAwaiter();    &#125;    public interface IAwaitable&lt;out TAwaiter,out TResult&gt; where TAwaiter : IAwaiter&lt;TResult&gt;    &#123;        TAwaiter GetAwaiter();    &#125;</code></pre><p>我们可以看到GetAwaiter方法返回了一个IAwaiter，接下来我们尝试自定义Awaiter</p><h1 id="3-自定义Awaiter"><a href="#3-自定义Awaiter" class="headerlink" title="3.自定义Awaiter"></a>3.自定义Awaiter</h1><p><font color=red><strong>System.Runtime.CompilerServices</strong></font>命名空间下提供了这样两个接口，<font color=red><strong>编译器要求Awaiter必须实现其中一个接口</strong></font></p><pre><code class="csharp">    public interface INotifyCompletion    &#123;        void OnCompleted(Action continuation);    &#125;    public interface ICriticalNotifyCompletion : INotifyCompletion    &#123;        void UnsafeOnCompleted(Action continuation);    &#125;</code></pre><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202303241053728.jpeg" alt="在这里插入图片描述"><br><strong>关于Awaiter的要求：</strong></p><ol><li><font color=red><strong>有bool IsCompleted { get; }</strong>   </font></li><li><font color=red><strong>有GetResult方法</strong></font></li></ol><p>关于IsCompleted，异步流程执行到await时，会检查IsCompleted，如果为true，则表明任务已经完成，await直接结束。</p><pre><code class="csharp">int value = await GetValueAsync();</code></pre><p>关于GetResult也很好理解，我们不陌生上面这样的语法，在await被结束时，会调用GetResult方法返回一个值。</p><pre><code class="csharp">    public interface IAwaiter : INotifyCompletion    &#123;        bool IsCompleted &#123; get; &#125;        void GetResult();    &#125;        public interface IAwaiter&lt;T&gt; : INotifyCompletion    &#123;        bool IsCompleted &#123; get; &#125;        T GetResult();    &#125;    public interface ICriticalAwaiter :ICriticalNotifyCompletion,IAwaiter    &#123;    &#125;    public interface ICriticalAwaiter&lt;T&gt;:ICriticalNotifyCompletion,IAwaiter&lt;T&gt;    &#123;    &#125;</code></pre><p>在上面我们定义了四个接口，都是与Awaiter相关的，CriticalAwaiter不同的是UnsafeOnCompleted方法，在异步执行的代码可能给程序产生负面影响(如异常)时，我们可以使用这个Awaiter接口。</p><h1 id="3-自定义异步任务接口"><a href="#3-自定义异步任务接口" class="headerlink" title="3. 自定义异步任务接口"></a>3. 自定义异步任务接口</h1><p>我们进一步拓展，给异步任务更多的功能，这些不是编译器的要求了，而是我们自己的需要。<br>当任务完成时，<strong>我们可以手动调用</strong>SetResult，在出现异常时调用SetException。</p><pre><code class="csharp"> public interface IAsyncTask : ICriticalAwaiter    &#123;           void SetResult();        void SetException(Exception exception);    &#125;    public interface IAsyncTask&lt;T&gt; : ICriticalAwaiter&lt;T&gt;     &#123;        //参数就是GetResult拿到的结果        void SetResult(T result);        void SetException(Exception exception);    &#125;</code></pre><h1 id="4-实现异步任务类"><a href="#4-实现异步任务类" class="headerlink" title="4.实现异步任务类"></a>4.实现异步任务类</h1><p><strong>千万记住要加上这个特性</strong>，只有这样才能指定AsyncTask作为返回值时进行AsyncTaskMethodBuilder自动创建，泛型时写<strong>[AsyncMethodBuilder(typeof(AsyncTaskMethodBuilder&lt;&gt;))]</strong></p><pre><code class="csharp">    //特性指定AsyncMethodBuilder    [AsyncMethodBuilder(typeof(AsyncTaskMethodBuilder))]    public partial class AsyncTask : PoolableObject&lt;AsyncTask&gt;, IAsyncTask    &#123;        public AsyncTask GetAwaiter() =&gt; this;        public Action continuation;        public Exception Exception &#123; get; private set; &#125;        public bool IsCompleted &#123; get; set; &#125;               public void OnCompleted(Action continuation)        &#123;            UnsafeOnCompleted(continuation);        &#125;        public void UnsafeOnCompleted(Action continuation)        &#123;            this.continuation = continuation;        &#125;        public void SetException(Exception exception)        &#123;            IsCompleted= true;            this.Exception = exception;        &#125;        //啥也不返回        public void GetResult()&#123; &#125;        public void SetResult()        &#123;            //执行await以后的代码            continuation?.Invoke();            //回收到Pool内            this.Dispose();        &#125;    &#125;</code></pre><h1 id="5-AsyncTaskMethodBuilder"><a href="#5-AsyncTaskMethodBuilder" class="headerlink" title="5.AsyncTaskMethodBuilder"></a>5.AsyncTaskMethodBuilder</h1><p>没错，这些又是编译器的无礼要求，已经快要成模板了</p><pre><code class="csharp"> public struct AsyncTaskMethodBuilder    &#123;        private AsyncTask task;        // 1. Static Create method 编译器调用静态创建方法来创建Builder        [DebuggerHidden]        public static AsyncTaskMethodBuilder Create() =&gt; new AsyncTaskMethodBuilder(AsyncTask.Create(fromPool:true));        //2.Construct Method 构造Builder时调用        public AsyncTaskMethodBuilder(AsyncTask task) =&gt; this.task = task;        // . TaskLike Task property.        [DebuggerHidden]        public AsyncTask Task =&gt; task;        // 3. Start 构造之后开启状态机        [DebuggerHidden]        public void Start&lt;TStateMachine&gt;(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine        &#123;            stateMachine.MoveNext();        &#125;        // 4. SetException 当出现异常时编译器调用，将异常绑定到任务        [DebuggerHidden]        public void SetException(Exception exception)        &#123;            task.SetException(exception);        &#125;        // 5. SetResult 当任务成功完成时编译器调用这个方法,将该任务标记为已成功完成        [DebuggerHidden]        public void SetResult()        &#123;            task.SetResult();        &#125;        // 6. AwaitOnCompleted  在SetResult之后编译器调用OnCompleted        [DebuggerHidden]        public void AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine        &#123;            awaiter.OnCompleted(stateMachine.MoveNext);        &#125;        // 7. AwaitUnsafeOnCompleted 同OnCompleted        [SecuritySafeCritical]        public void AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine        &#123;            awaiter.OnCompleted(stateMachine.MoveNext);        &#125;        // 9. SetStateMachine  将生成器与指定的状态机相关联        [DebuggerHidden]        public void SetStateMachine(IAsyncStateMachine stateMachine)        &#123;        &#125;    &#125;</code></pre><p>不用担心这个OnCompleted参数委托的GC问题，因为代码会在编译时被静态编译为一个状态机，实际上编译后的IL代码不是我们所见的这样。</p><h1 id="6-Delay方法"><a href="#6-Delay方法" class="headerlink" title="6.Delay方法"></a>6.Delay方法</h1><p>我写了一个例子来使用这个AsyncTask，由于全部从池内取出，并没有GC产出，而C#原生的Task类型显得十分臃肿，带有高昂的GC代价。</p><pre><code class="csharp"> public static AsyncTask Delay(float seconds)        &#123;            var task = Framework.Pool.Allocate&lt;AsyncTask&gt;();            var timer = Framework.Pool.Allocate&lt;TimerCall&gt;();            timer.OnCompleted += task.SetResult;            timer.OnCompleted += timer.Dispose;            timer.Start(TimeSpan.FromSeconds(seconds));            return task;        &#125;</code></pre><h1 id="C-3-0-反编译-System-Tasks-Task-的-IL-代码"><a href="#C-3-0-反编译-System-Tasks-Task-的-IL-代码" class="headerlink" title="C # 3.0 反编译 System.Tasks.Task 的 IL 代码"></a>C # 3.0 反编译 System.Tasks.Task 的 IL 代码</h1><p>被反编译的代码</p><pre><code class="csharp">        public async Task TaskTest()        &#123;            await Task.Run(() =&gt; &#123; &#125;);        &#125;</code></pre><p>反编译结果IL代码</p><pre><code class="csharp">    [CompilerGenerated]    private sealed class &lt;TaskTest&gt;d__1 : IAsyncStateMachine    &#123;        public int &lt;&gt;1__state;        public AsyncTaskMethodBuilder &lt;&gt;t__builder;        public ClassA &lt;&gt;4__this;        private TaskAwaiter &lt;&gt;u__1;        private void MoveNext()        &#123;            int num = &lt;&gt;1__state;            try            &#123;                TaskAwaiter awaiter;                if (num != 0)                &#123;                    awaiter = Task.Run(delegate                    &#123;                    &#125;).GetAwaiter();                    if (!awaiter.IsCompleted) //await修饰的状态未完成？把控制器交由该类                    &#123;                        num = (&lt;&gt;1__state = 0);                        &lt;&gt;u__1 = awaiter;                        &lt;TaskTest&gt;d__1 stateMachine = this;                        &lt;&gt;t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref stateMachine);                        return;                    &#125;                &#125;                else                &#123;                    awaiter = &lt;&gt;u__1;                    &lt;&gt;u__1 = default(TaskAwaiter);                    num = (&lt;&gt;1__state = -1);                &#125;                awaiter.GetResult();            &#125;            catch (Exception exception)            &#123;                &lt;&gt;1__state = -2;                &lt;&gt;t__builder.SetException(exception);                return;            &#125;            &lt;&gt;1__state = -2;            &lt;&gt;t__builder.SetResult();        &#125;        void IAsyncStateMachine.MoveNext()        &#123;            //ILSpy generated this explicit interface implementation from .override directive in MoveNext            this.MoveNext();        &#125;        [DebuggerHidden]        private void SetStateMachine(IAsyncStateMachine stateMachine)        &#123;        &#125;        void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)        &#123;            //ILSpy generated this explicit interface implementation from .override directive in SetStateMachine            this.SetStateMachine(stateMachine);        &#125;    &#125;    [AsyncStateMachine(typeof(&lt;TaskTest&gt;d__1))]    [DebuggerStepThrough]    public Task TaskTest()    &#123;        &lt;TaskTest&gt;d__1 stateMachine = new &lt;TaskTest&gt;d__1();        stateMachine.&lt;&gt;4__this = this;        stateMachine.&lt;&gt;t__builder = AsyncTaskMethodBuilder.Create(); //创那就状态机        stateMachine.&lt;&gt;1__state = -1; //初始状态-1        AsyncTaskMethodBuilder &lt;&gt;t__builder = stateMachine.&lt;&gt;t__builder;        &lt;&gt;t__builder.Start(ref stateMachine); //启动状态机        return stateMachine.&lt;&gt;t__builder.Task; //返回值    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Coroutine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YooAsset初始化</title>
      <link href="/2023/05/19/Unity/YooAsset/YooAsset%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2023/05/19/Unity/YooAsset/YooAsset%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="零、导入YooAsset"><a href="#零、导入YooAsset" class="headerlink" title="零、导入YooAsset"></a>零、导入YooAsset</h1><h2 id="0-注意结合官方文档一起看，他写的很清晰"><a href="#0-注意结合官方文档一起看，他写的很清晰" class="headerlink" title="0.注意结合官方文档一起看，他写的很清晰"></a>0.注意结合官方文档一起看，他写的很清晰</h2><blockquote><p><a href="https://www.yooasset.com/docs/Introduce">官方文档</a></p></blockquote><h2 id="1-UPM导入"><a href="#1-UPM导入" class="headerlink" title="1.UPM导入"></a>1.UPM导入</h2><p>在ProjectSetting里找到这个，这么填<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191648812.png" alt="在这里插入图片描述"></p><blockquote><p>package.openupm.cn<br><a href="https://package.openupm.cn/">https://package.openupm.cn</a><br>com.tuyoogame.yooasset</p></blockquote><p>然后在PackageManager里，选择MyRegistry ，导入YooAsset</p><h1 id="一、编辑器"><a href="#一、编辑器" class="headerlink" title="一、编辑器"></a>一、编辑器</h1><h2 id="0-创建YooAsset设置文件"><a href="#0-创建YooAsset设置文件" class="headerlink" title="0.创建YooAsset设置文件"></a>0.创建YooAsset设置文件</h2><p><img src="https://img-blog.csdnimg.cn/fdf9851314224fe68cc3e5f82ecbbaf4.png" alt="在这里插入图片描述"><br>在使用这些东西之前，我们需要在Project面板右键，选择YooAsset&#x2F;Create Setting创建这个文件<br>然后MainfestFileName就是我们的资源清单文件名，(不改也没事，不影响使用，只是名字)<img src="https://img-blog.csdnimg.cn/e34908e9d0cb4866adf1c86f4c923eba.png" alt="在这里插入图片描述"><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191648751.png" alt="在这里插入图片描述"></p><h2 id="1-AssetBundle-Collector"><a href="#1-AssetBundle-Collector" class="headerlink" title="1.AssetBundle Collector"></a>1.AssetBundle Collector</h2><p><img src="https://img-blog.csdnimg.cn/d000d17c75f64b3b9c3e38d5c523b1d2.png" alt="在这里插入图片描述"><br>第一个是是否显示包，第二个是是否采用中文，第三个是是否开启寻址，第四个是在包名前面加东西保证包名唯一。<br>接下来我们把前三个打勾，按下面的加号创建一些东西。<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191648779.png" alt="在这里插入图片描述"><br>其中Package就是包了，Group是分组，而Collector是收集器。<br>我们能编写自定义的收集规则，当Collector选择目录时，我们可以用自己的脚本来控制选择什么样的资源。</p><p>我们简单选择几个资源<br><img src="https://img-blog.csdnimg.cn/4707ea7b40cb40a89df3741e9c0564a1.png" alt="在这里插入图片描述"></p><h2 id="2-Builder"><a href="#2-Builder" class="headerlink" title="2. Builder"></a>2. Builder</h2><p><img src="https://img-blog.csdnimg.cn/9e4f904fbc8d46b7afa47ee064d60e90.png" alt="在这里插入图片描述"><br>第二个是构建管线，默认是默认的，否则可以改成可编程的（不介绍）。<br>第三是构建模式，<strong>ForceRebuild会删除原来的AB，重新打新的</strong>。<br>而<strong>Incremental是增量更构建，也就是打出来的包是多出来的资源，不会移除也不会生成之前的</strong>，所以在<strong>更新到CDN时可以直接覆盖到原来的包上</strong>，或者差异分析上传<br>然后是<strong>DryRun,只会产生一些Mainfest文件，不会打包，用于演练，</strong>。<br>接下来是<strong>Simulate，需要配合特殊的初始化方式才能模拟构建，只在编辑器有效</strong><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191648951.png" alt="在这里插入图片描述"><br>然后是版本号，这个版本号随着时间自动生成，不需要处理<br>Compressaion是压缩方式，LZ4时间略微优异，性价比比较高，LZMA保证最大的压缩率，其实差距不大，太大不会放在这里，说明都可用。<br>Encryption是加密方式，需要自己写一个，好像要实现一个接口，在<a href="https://www.yooasset.com/docs/api/YooAsset/IEncryptionServices">YooAsset官方文档</a>有的<br>最后一个就是是否拷贝到StreamingAsset<br><img src="https://img-blog.csdnimg.cn/28eecdbd5e324027ab08a370e84a618a.png" alt="在这里插入图片描述"><br>我们能根据Group的标签区分。</p><h2 id="3-Reporter"><a href="#3-Reporter" class="headerlink" title="3.Reporter"></a>3.Reporter</h2><p><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191648070.png" alt="在这里插入图片描述"><br>在目录里，Bundles是打包输出路径，SandBox是AB从服务器下载缓存的路径<br>我们进入Reporter，选择导入，选择这个打出的以时间命名的包下面的一个文件<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191648309.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b1b82b44f209442780bf264c5f3e8695.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191648064.png" alt="在这里插入图片描述"><br>就这个用处，简单吧，还有一个调试器，这个是在运行时检测资源直接有没有循环引用问题的，基于引用计数的方案最害怕这个。</p><h1 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h1><h2 id="0-每一个模式都要做的初始化"><a href="#0-每一个模式都要做的初始化" class="headerlink" title="0.每一个模式都要做的初始化"></a>0.每一个模式都要做的初始化</h2><pre><code class="csharp">// 初始化资源系统YooAssets.Initialize();// 创建默认的资源包，这里是需要先在Collector里创建同名Package的var package = YooAssets.CreatePackage(&quot;DefaultPackage&quot;);// 设置该资源包为默认的资源包，可以使用YooAssets相关加载接口加载该资源包内容。YooAssets.SetDefaultPackage(package);</code></pre><h2 id="0-1-选择一个运行模式"><a href="#0-1-选择一个运行模式" class="headerlink" title="0.1 选择一个运行模式"></a>0.1 选择一个运行模式</h2><pre><code class="csharp"> public EPlayMode PlayMode = EPlayMode.EditorSimulateMode;switch (PlayMode)        &#123;            case EPlayMode.EditorSimulateMode:                &#123;                   //开启协程                    break;                &#125;            case EPlayMode.OfflinePlayMode:                &#123;                //开启协程                    break;                &#125;            case EPlayMode.HostPlayMode:                &#123;                           //开启协程                    break;                &#125;        &#125;</code></pre><h2 id="1-编辑器模拟运行"><a href="#1-编辑器模拟运行" class="headerlink" title="1.编辑器模拟运行"></a>1.编辑器模拟运行</h2><p>执行完这个协程之后，就可以任意加载，不过<strong>注意只能在编辑器里用</strong>，传入的package就是上面创建的DefaultPackage</p><pre><code class="csharp">  private IEnumerator EditorInitializeYooAsset(ResourcePackage package)    &#123;        var initParameters = new EditorSimulateModeParameters();        initParameters.SimulateManifestFilePath = EditorSimulateModeHelper.SimulateBuild(&quot;DefaultPackage&quot;);        yield return package.InitializeAsync(initParameters);    &#125;</code></pre><h2 id="2-单机模式运行"><a href="#2-单机模式运行" class="headerlink" title="2. 单机模式运行"></a>2. 单机模式运行</h2><p>这个运行模式<strong>要求在打AB包的时候，在调整最后一个设置选择，把AB包拷贝到streamingAsset&#x2F;buildIn里面</strong>，不然加载资源会失败！！注意不是自己手动拷贝</p><pre><code class="csharp"> private IEnumerator SingleInitializeYooAsset(ResourcePackage package)    &#123;        var initParameters = new OfflinePlayModeParameters();        yield return package.InitializeAsync(initParameters);    &#125;</code></pre><h2 id="3-联网模式运行"><a href="#3-联网模式运行" class="headerlink" title="3.联网模式运行"></a>3.联网模式运行</h2><h3 id="（0）本地测试环境"><a href="#（0）本地测试环境" class="headerlink" title="（0）本地测试环境"></a>（0）本地测试环境</h3><p>首先我们从网上找个软件叫做HFS，Http File Server，搜一下就有。<br><img src="https://img-blog.csdnimg.cn/ba7f19fc165941ff94b95d6e71807fbc.png" alt="在这里插入图片描述"><br>把右边的FTP文件夹拖进去。我们就能访问这个地址了<br><img src="https://raw.githubusercontent.com/yueh0607/MyPicueres/main/202305191648399.png" alt="在这里插入图片描述"><br>然后把我们的AB包扔进去</p><h3 id="（1）初始化资源包"><a href="#（1）初始化资源包" class="headerlink" title="（1）初始化资源包"></a>（1）初始化资源包</h3><pre><code class="csharp">public string netPath = &quot;http://127.0.0.1:9999/FTP/2023-04-20-1108&quot;; private IEnumerator NetInitializeYooAsset(ResourcePackage package)    &#123;        var initParameters = new HostPlayModeParameters();                initParameters.QueryServices = new QueryStreamingAssetsFileServices();                //主资源服务器地址        initParameters.DefaultHostServer = netPath;        //备用资源服务器地址        initParameters.FallbackHostServer = netPath;                yield return package.InitializeAsync(initParameters);    &#125;     // 内置文件查询服务类，这个类只需要返回ApplicationstreamingAsset下面的文件存在性就好    private class QueryStreamingAssetsFileServices : IQueryServices    &#123;        public bool QueryStreamingAssets(string fileName)        &#123;            // StreamingAssetsHelper.cs是太空战机里提供的一个查询脚本。            string buildinFolderName = YooAssets.GetStreamingAssetBuildinFolderName();            return File.Exists($&quot;&#123;Application.streamingAssetsPath&#125;/&#123;buildinFolderName&#125;/&#123;fileName&#125;&quot;);        &#125;    &#125;</code></pre><h3 id="（2）更新资源版本"><a href="#（2）更新资源版本" class="headerlink" title="（2）更新资源版本"></a>（2）更新资源版本</h3><pre><code class="csharp">string packageVersion = &quot;2023-4-20-1108&quot;; IEnumerator UpdatePack(ResourcePackage package) &#123;        //2.获取资源版本        var operation = package.UpdatePackageVersionAsync();        yield return operation;        if(operation.Status!=EOperationStatus.Succeed)        &#123;            Debug.LogError(&quot;版本号更新失败，可能是找不到服务器&quot;);            yield break;        &#125;        //这是获取到的版本号，在下一个步骤要用        packageVersion = operation.PackageVersion;&#125;</code></pre><h3 id="3-更新补丁清单"><a href="#3-更新补丁清单" class="headerlink" title="(3) 更新补丁清单"></a>(3) 更新补丁清单</h3><pre><code class="csharp"> IEnumerator UpdatePack(ResourcePackage package)    &#123;        //3.获取补丁清单        var op=  package.UpdatePackageManifestAsync(packageVersion);        yield return op;        if(op.Status!=EOperationStatus.Succeed)        &#123;            Debug.LogError(&quot;Mainfest更新失败！&quot;);        &#125;    &#125;</code></pre><h3 id="（4）下载补丁包"><a href="#（4）下载补丁包" class="headerlink" title="（4）下载补丁包"></a>（4）下载补丁包</h3><pre><code class="csharp">int downloadingMaxNum = 10;int failedTryAgain = 3;int timeout = 60;         IEnumerator Download()    &#123;        var package = YooAssets.GetPackage(&quot;DefaultPackage&quot;);        var downloader = package.CreateResourceDownloader(downloadingMaxNum, failedTryAgain, timeout);        //下载数量是0，直接就完成了        if(downloader.TotalDownloadCount==0)        &#123;            yield break;        &#125;        //注册一些回调        downloader.OnDownloadErrorCallback += OnError;        downloader.OnDownloadProgressCallback += OnProcess;        downloader.OnDownloadOverCallback += OnOver;        downloader.OnStartDownloadFileCallback += OnStartDownOne;        //开始下载        downloader.BeginDownload();        //等待下载完成        yield return downloader;        //检查状态        if(downloader.Status==EOperationStatus.Succeed)        &#123;            Debug.Log(&quot;下载完成&quot;);        &#125;        else        &#123;            Debug.Log(&quot;下载失败&quot;);        &#125;    &#125;</code></pre><p>当这些步骤执行完，初始化完毕。随心所欲的使用yooasset吧。</p><h1 id="三、针对各个平台的方案"><a href="#三、针对各个平台的方案" class="headerlink" title="三、针对各个平台的方案"></a>三、针对各个平台的方案</h1><h2 id="1-编辑器模拟"><a href="#1-编辑器模拟" class="headerlink" title="1.编辑器模拟"></a>1.编辑器模拟</h2><p>为了加载更快，我们可以专门的按照上面的编辑器模拟初始化方式进行运行，节约开发时间。</p><h2 id="2-纯单机不联网"><a href="#2-纯单机不联网" class="headerlink" title="2.纯单机不联网"></a>2.纯单机不联网</h2><p>只需要在打AB的时候调最后一个选择，拷贝到streamingAsset&#x2F;BuiltIn<br>然后按照上面给出的单机初始化方式进行即可。</p><h2 id="3-单机弱连网"><a href="#3-单机弱连网" class="headerlink" title="3.单机弱连网"></a>3.单机弱连网</h2><p>先按照联网模式的初始化步骤走，然后在获取版本号那一步，如果成功则继续按联网的走，否则直接按</p><pre><code class="csharp">private IEnumerator Start()&#123;//先获取包    var package = YooAssets.GetPackage(&quot;DefaultPackage&quot;);    //更新版本号    var operation = package.UpdatePackageVersionAsync(60);    yield return operation;    if (operation.Status == EOperationStatus.Succeed)    &#123;        // 如果获取远端资源版本成功，说明当前网络连接通畅，可以走正常更新流程。继续从服务器按照联网模式更新    &#125;    else    &#123;        // 如果获取远端资源版本失败，说明当前网络无连接。        // 在正常开始游戏之前，需要验证本地清单内容的完整性。        //如果清单都没了，那就不用继续了，请联网进行清单的补全        string packageVersion = package.GetPackageVersion();        var operation = package.PreDownloadContentAsync(packageVersion);        yield return operation;        if (operation.Status != EOperationStatus.Succeed)        &#123;             ShowMessageBox(&quot;请检查本地网络，有新的游戏内容需要更新！&quot;);            yield break;        &#125;        //注意这里没真的开始下载，只是用本地清单看看需要下载数量有几个        int downloadingMaxNum = 10;        int failedTryAgain = 3;        int timeout = 60;        var downloader = operation.CreateResourceDownloader(downloadingMaxNum, failedTryAgain, timeout);        if (downloader.TotalDownloadCount &gt; 0)           &#123;            // 资源内容本地并不完整，需要提示玩家联网更新。            ShowMessageBox(&quot;请检查本地网络，有新的游戏内容需要更新！&quot;);            yield break;        &#125;               // 开始游戏        StartGame();    &#125;&#125;</code></pre><h2 id="4-联网"><a href="#4-联网" class="headerlink" title="4.联网"></a>4.联网</h2><p>按照联网模式走就行，有一步失败就不能让玩家进去</p>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> YooAsset </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> YooAsset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圆角</title>
      <link href="/2023/05/16/Unity/Shader/%E5%9C%86%E8%A7%92/"/>
      <url>/2023/05/16/Unity/Shader/%E5%9C%86%E8%A7%92/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-效果与引言"><a href="#一、-效果与引言" class="headerlink" title="一、 效果与引言"></a>一、 效果与引言</h1><p><img src="https://img-blog.csdnimg.cn/4f83fe89e91e4c01bc0a3a49ec0cc0c1.png" alt="在这里插入图片描述"><br>相信很多小伙伴都会遇到做<strong>圆角矩形</strong>的需求，网上的shader还不明白是怎么实现的，甚至还有一部分是错误的，本文讲从原理到代码讲解<strong>圆角矩形shader</strong>的实现</p><h1 id="二、-原理分析"><a href="#二、-原理分析" class="headerlink" title="二、 原理分析"></a>二、 原理分析</h1><p>想要实现一个圆角矩形，常见的是抽象成一个数学模型，如下图紫色区域，就是我们应该保留的区域，为了更准确的描述这个图形，我们在四个角创建四个相等的圆形。<br><img src="https://img-blog.csdnimg.cn/442e59ea0670471cba764ba3847d4b16.png" alt="在这里插入图片描述"><br>因为控制每个像素的颜色主要是由<strong>片元着色器</strong>负责的，所以我们也通过<strong>Fragment Shader</strong>去实现这个效果，可以看到在这个函数里我们只能拿到 <strong>uv</strong>和vertex，所以我们<strong>根据uv坐标判定是否在上图的紫色区域，如果在则返回原本的颜色，如果不在返回完全透明的颜色。</strong><br><strong>(对每个像素都会执行一次frag函数获取真正渲染的颜色)</strong></p><pre><code class="c">struct v2f            &#123;                float2 uv : TEXCOORD0;                UNITY_FOG_COORDS(1)                float4 vertex : SV_POSITION;            &#125;;             fixed4 frag (v2f i) : SV_Target &#123;     //....省略 &#125;</code></pre><p>因为我们通过uv来判断是否是紫色区域，所以我们需要先了解uv坐标系<br>首先我们要了解<strong>UV坐标系</strong>，这并不是什么高深的数学概念，而是一个简单的道理。<br>首先，我们<strong>把水平方向定义为X轴，竖直方向为Y轴</strong>，<strong>把图片左下角定义为(0,0)，右上角定义为(1,1)，其他的坐标以此类推</strong></p><p><img src="https://img-blog.csdnimg.cn/3df0da07d60f46798bde3a0d56feeb62.png" alt="在这里插入图片描述"></p><p>读者可能会产生疑惑，为什么xy两个轴长度不同，但是坐标却不相同？<br>笔者暂时只能这样描述：我们就如此定义一个坐标系，x轴和y轴单位长度不同</p><p>我们需要用户去调整四个<strong>圆形的半径 设为Radius</strong>，因为uv坐标系的xy单位长度不同，我们设<strong>Ratio &#x3D; Height&#x2F;Width</strong>，Ratio即为y轴单位长度与x轴单位长度之比。</p><blockquote><p>float Radius   圆形半径<br>float Ratio  Y单位长度&#x2F;X单位长度</p></blockquote><p>接下来我们在图上画四个圆形并作辅助线</p><p><img src="https://img-blog.csdnimg.cn/f52b351e1ab24bc0b6d321c896481bba.png" alt="在这里插入图片描述"><br>通过观察，我们可以发现以下特征</p><blockquote><p>1.<strong>只有在红色区域才有可能被舍弃</strong><br>2.<strong>三个圆形R2，R3，R4对应红色区域的任意一个位置，都能在R1内找到等价位置</strong><br>3. <strong>UV坐标转正常坐标的公式为 f (x ,y)&#x3D; (uv.x  , uv.y * Ratio)</strong></p></blockquote><p>在UV坐标内，我们无法通过x^2^ + y^2^ 来计算长度，因为uv坐标的xy单位不同，所以我们通过上述的坐标转换公式来转化为相同的坐标系</p><p>我们需要按以下步骤进行处理</p><blockquote><p>1.<strong>将白色区域坐标在左下角找到等价uv坐标，position &#x3D; abs(step(0.5,uv) - uv)</strong><br><img src="https://img-blog.csdnimg.cn/9035592a474d407da93ab0822a6c62c5.png" alt="在这里插入图片描述"><br>2.<strong>判断等价uv是否在左下角可能舍弃区域，</strong>uv.x&lt;Raduis &amp;&amp; uv.y &lt;  Radius * Ratio**<br>如果不在，则返回原色，如果在则进入下一步**<br><img src="https://img-blog.csdnimg.cn/0d7d8edfa97546aebaf72c19d218ee6a.png" alt="在这里插入图片描述"><br>3. <strong>求圆心距 distance &#x3D;   [f(uv.x,uv.y) - f(Radius,Radius)]的长度<br>如果大于半径则返回fixed(0,0,0,0)，否则返回原色</strong><br><img src="https://img-blog.csdnimg.cn/85804ca51346416087dbe24c1f42f0ec.png" alt="在这里插入图片描述"></p></blockquote><h1 id="三、着色器代码"><a href="#三、着色器代码" class="headerlink" title="三、着色器代码"></a>三、着色器代码</h1><p>在shader内尽量不要使用if语句<br><img src="https://img-blog.csdnimg.cn/5ab9a4806dba4180853100ab8094f6fe.png" alt="在这里插入图片描述"><br>以上来着自Hking_Auditore 大大的Shader入门书，通常我们用step和lerp等来代替if<br>step函数的逻辑可以等价为</p><pre><code class="c">step (a, x)&#123;  if (a&gt;x)  return 0;  else return 1;&#125;</code></pre><p>接下来的代码虽然看着多，实际上我们只写了两行<br>这就是这两行</p><pre><code class="csharp"> float2 p = abs(step(0.5,i.uv) - i.uv); fixed4 col =  tex2D(_MainTex, i.uv) * (step(_Radius,p.x) ||step( _Radius  ,p.y*_Ratio) || step(length(float2(p.x-_Radius,p.y*_Ratio-_Radius)),_Radius));</code></pre><p>这是完整的着色器代码</p><pre><code class="c">Shader &quot;Unlit/MyShader&quot;&#123;    Properties    &#123;        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Radius (&quot;Radius&quot;,float) = 0        _Ratio(&quot;Height/Width&quot;,float )= 1    &#125;    SubShader    &#123;        Tags &#123; &quot;RenderType&quot;=&quot;Transparent&quot; &quot;Queue&quot; = &quot;Transparent&quot;&#125;        LOD 100        Blend SrcAlpha OneMinusSrcAlpha        Pass        &#123;            CGPROGRAM            #pragma vertex vert            #pragma fragment frag            // make fog work            #pragma multi_compile_fog            #include &quot;UnityCG.cginc&quot;            struct appdata            &#123;                float4 vertex : POSITION;                float2 uv : TEXCOORD0;            &#125;;            struct v2f            &#123;                float2 uv : TEXCOORD0;                UNITY_FOG_COORDS(1)                float4 vertex : SV_POSITION;            &#125;;            sampler2D _MainTex;            float4 _MainTex_ST;            float _Radius;            float _Ratio;            v2f vert (appdata v)            &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                o.uv = TRANSFORM_TEX(v.uv, _MainTex);                UNITY_TRANSFER_FOG(o,o.vertex);                return o;            &#125;            fixed4 frag (v2f i) : SV_Target            &#123;                  //坐标等价到左下角                float2 p = abs(step(0.5,i.uv) - i.uv);                //三个条件同时成立则乘0，否则乘1                //1.在左下角  ，2.长度超过半径                fixed4 col =  tex2D(_MainTex, i.uv) * (step(_Radius,p.x) ||step( _Radius  ,p.y*_Ratio) || step(length(float2(p.x-_Radius,p.y*_Ratio-_Radius)),_Radius));                UNITY_APPLY_FOG(i.fogCoord, col);                return col;            &#125;            ENDCG        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊-毛玻璃</title>
      <link href="/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/"/>
      <url>/2023/05/16/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/../../../Pic/Unity/Shader/%E6%A8%A1%E7%B3%8A-%E6%AF%9B%E7%8E%BB%E7%92%83.png" alt="效果"></p><pre><code class="cg">Shader &quot;UI/UiObscure&quot;&#123;    Properties    &#123;        _Radius(&quot;Radius&quot;, Range(1, 255)) = 1        _MainTex(&quot;Tint Color (RGB)&quot;, 2D) = &quot;white&quot; &#123;&#125;        _Interval(&quot;Blur Nuance&quot;,Range(0.1, 100)) = 1        [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)] _StencilComp (&quot;Stencil Comparison&quot;, Float) = 8        [HideInInspector] _Stencil (&quot;Stencil ID&quot;, Float) = 0        [HideInInspector][Enum(UnityEngine.Rendering.StencilOp)] _StencilOp (&quot;Stencil Operation&quot;, Float) = 0        [HideInInspector] _StencilWriteMask (&quot;Stencil Write Mask&quot;, Float) = 255        [HideInInspector] _StencilReadMask (&quot;Stencil Read Mask&quot;, Float) = 255        [HideInInspector] _ColorMask (&quot;Color Mask&quot;, Float) = 15        [Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip (&quot;Use Alpha Clip&quot;, Float) = 0        // Outline properties are drawn via custom editor.        [HideInInspector] _OutlineWidth(&quot;Outline Width&quot;, Range(0,8)) = 3.0        [HideInInspector] _OutlineColor(&quot;Outline Color&quot;, Color) = (1,1,0,1)        [HideInInspector] _OutlineReferenceTexWidth(&quot;Reference Texture Width&quot;, Int) = 1024        [HideInInspector] _ThresholdEnd(&quot;Outline Threshold&quot;, Range(0,1)) = 0.25        [HideInInspector] _OutlineSmoothness(&quot;Outline Smoothness&quot;, Range(0,1)) = 1.0        [HideInInspector][MaterialToggle(_USE8NEIGHBOURHOOD_ON)] _Use8Neighbourhood(&quot;Sample 8 Neighbours&quot;, Float) = 1        [HideInInspector] _OutlineMipLevel(&quot;Outline Mip Level&quot;, Range(0,3)) = 0    &#125;     Category    &#123;        Tags&#123; &quot;Queue&quot; = &quot;Transparent&quot; &quot;IgnoreProjector&quot; = &quot;True&quot; &quot;RenderType&quot; = &quot;Opaque&quot; &#125;         SubShader        &#123;                     Stencil            &#123;            Ref [_Stencil]            Comp [_StencilComp]            Pass [_StencilOp]            ReadMask [_StencilReadMask]            WriteMask [_StencilWriteMask]            &#125;                        Cull Off            Lighting Off            ZWrite Off            ZTest [unity_GUIZTestMode]            Fog &#123; Mode Off &#125;            Blend One OneMinusSrcAlpha            ColorMask [_ColorMask]                    GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM                #pragma vertex vert                #pragma fragment frag                #pragma fragmentoption ARB_precision_hint_fastest                #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                    v2f o;                    o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                    float scale = -1.0;                    #else                    float scale = 1.0;                    #endif                    o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                    o.uvgrab.zw = o.vertex.zw;                    return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                float _Interval;                half4 frag(v2f i) : COLOR                &#123;                    half4 sum = half4(0,0,0,0);                                 #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                                 sum += GRABXYPIXEL(0.0, 0.0);                    int measurments = 1;                                 for (float range = _Interval; range &lt;= _Radius; range += _Interval)                    &#123;                        sum += GRABXYPIXEL(range, range);                        sum += GRABXYPIXEL(range, -range);                        sum += GRABXYPIXEL(-range, range);                        sum += GRABXYPIXEL(-range, -range);                        measurments += 4;                    &#125;                    return sum / measurments;                &#125;            ENDCG            &#125;        GrabPass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;            &#125;            Pass            &#123;            Tags&#123; &quot;LightMode&quot; = &quot;Always&quot; &#125;                CGPROGRAM            #pragma vertex vert            #pragma fragment frag            #pragma fragmentoption ARB_precision_hint_fastest            #include &quot;UnityCG.cginc&quot;                struct appdata_t                &#123;                float4 vertex : POSITION;                float2 texcoord: TEXCOORD0;                &#125;;                    struct v2f                &#123;                float4 vertex : POSITION;                float4 uvgrab : TEXCOORD0;                &#125;;                    v2f vert(appdata_t v)                &#123;                v2f o;                o.vertex = UnityObjectToClipPos(v.vertex);                    #if UNITY_UV_STARTS_AT_TOP                float scale = -1.0;                    #else                float scale = 1.0;                    #endif                o.uvgrab.xy = (float2(o.vertex.x, o.vertex.y*scale) + o.vertex.w) * 0.5;                o.uvgrab.zw = o.vertex.zw;                return o;                &#125;                    sampler2D _GrabTexture;                float4 _GrabTexture_TexelSize;                float _Radius;                    half4 frag(v2f i) : COLOR                &#123;                            half4 sum = half4(0,0,0,0);                float radius = 1.41421356237 * _Radius;                                #define GRABXYPIXEL(kernelx, kernely) tex2Dproj( _GrabTexture, UNITY_PROJ_COORD(float4(i.uvgrab.x + _GrabTexture_TexelSize.x * kernelx, i.uvgrab.y + _GrabTexture_TexelSize.y * kernely, i.uvgrab.z, i.uvgrab.w)))                            sum += GRABXYPIXEL(0.0, 0.0);                int measurments = 1;                            for (float range = 1.41421356237f; range &lt;= radius * 1.41; range += 1.41421356237f)                &#123;                sum += GRABXYPIXEL(range, 0);                sum += GRABXYPIXEL(-range, 0);                sum += GRABXYPIXEL(0, range);                sum += GRABXYPIXEL(0, -range);                measurments += 4;                &#125;                            return sum / measurments;                &#125;            ENDCG            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Unity </category>
          
          <category> Shader </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Shader </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书写方式</title>
      <link href="/2023/05/15/README/"/>
      <url>/2023/05/15/README/</url>
      
        <content type="html"><![CDATA[<h2 id="sadasda"><a href="#sadasda" class="headerlink" title="sadasda"></a>sadasda</h2><h4 id="57d8a"><a href="#57d8a" class="headerlink" title="57d8a"></a>57d8a</h4><ul><li>哈哈哈</li><li>康康康<ul><li>777</li><li>888</li></ul></li><li>999</li></ul><pre><code class="csharp">public class A&#123;    public void DO()&#123;&#125;&#125;</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><img src="/../Pic/R-C.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
